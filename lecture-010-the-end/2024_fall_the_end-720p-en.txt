[MUSIC PLAYING]

DAVID MALAN: All right, this is CS50, and this is the end,
our final lecture together here this week.
But it's not all of the course that itself remains because, of course, we
still have our final project, CS50 Hackathon, CS50 Fair, and more.
And so among the goals for today really is
to be a bit of a recap for where you started and where you now hopefully are
and to have some fun and some games along the way.
But recall that this was the image with which we
began the course, the sort of proverbial drinking from a fire hose.
And indeed, if it's felt like that each and every week,
realize that behind you each week is all the more content, all the more
skills that you've acquired and understood over time.
And in fact, I dare say, if you think back today
on how hard something like Mario was some 10 or so weeks ago,
I mean, that's the measure of just how far you
have come because we, of course, introduced something new, something
more each and every week to build on that previous week.
And so even though it might feel like you never quite got your footing,
odds are you very much have.
And indeed, among the goals for the final project
is to convince you that you don't need us.
You don't need a homework assignment.
You just need nowadays, friends, colleagues, Google, ChatGPT,
and the like to teach yourself new things
now that you have hopefully this conceptual foundation
and these practical skills in your tool kit.
What ultimately matters, though, recall in this class
is not so much where you end up relative to your classmates,
but where you end up relative to yourself when you began.
And that then brings us to today.
That is the delta by which you should measure
what it is you've been accomplishing over the past semester alone.
In fact, think back to my very own CS50 assignment,
which I pulled up from the archives that very first week.
Even I got sort of minus 2 on my very first assignment
on hello world of all things.
And hopefully, over time I sort of chipped away at that.
I ended up doing OK in CS50.
And clearly, I went on to study more computer science and other things.
So that too odds are will very much be you as well.
And at the end of the day, CS recall is really just about this picture, problem
solving.
Computer science is not about programming per se.
That's just been a tool in our toolkit via which
you can express yourself a little more methodically, more algorithmically,
solve problems, build solutions to problems,
build products that are of interest to you.
But at the end of the day, it really is about taking inputs and ideally
correctly producing outputs as well.
Toward that end, I also went into the archives
and pulled up some of my very first notes
from that very first CS50 class I took in 1996.
And this was page one of my notes.
And if we highlight a few details, I myself back in the day,
per Professor Kernighan's explanation thereof,
to find an algorithm as precise sequence of steps for getting something done.
Moreover, programming specifically, I see
was this process of taking on algorithm and putting it into a language
a computer can process.
But perhaps most importantly of my first days'
notes way back when were these two things.
And I even used exclamation points apparently
to reinforce this to myself, that precision and correctness are very much
important.
And so we thought we'd put those principles,
hopefully those takeaways, those learning objectives to the test
today with the first of our fun and games.
And if I can ask for one volunteer who bravely volunteered before class even
began.
Jordan, come on up.
[APPLAUSE]
Jordan, would you like to introduce yourself to the group?
JORDAN: Hello, everyone.
My name is Jordan.
I am a freshman dorming at Wigglesworth.
DAVID MALAN: Welcome to the stage, Jordan.
So hopefully in your hands you all have a sheet of paper
that you might have gotten on the way in.
If you don't, find any sheet of paper in your backpack or binder or person
next to you.
And if you really can't find that, that's
OK if you want to just listen along with this.
But everyone in the audience now, Jordan hopefully
has a sheet of paper and hopefully a pen or a pencil
with which to write something.
And so what we thought we'd do is a two-step approach here,
whereby the very first round of this here game we'll have Jordan
program you all by giving you step-by-step instructions for solving
some problem.
And the problem to solve is going to be to tell you
exactly how to draw a picture on that sheet of paper,
keeping in mind precision and correctness being our overarching goals.
If you want to step into the middle of the stage
here, actually in front of the lectern first,
I'm going to go ahead and dim the screen and show Jordan and only
Jordan what is on my screen here.
So the picture I'd like you to have folks draw is this picture here.
And in fact, I think we can leave this on the screen for just you,
so that you can look back and forth on it as needed.
So only Jordan can see that there screen.
And I'll pivot this around, so if you want
to step over there and give everyone in the audience
their first instruction to draw this.
JORDAN: I can describe it however I want to describe it?
DAVID MALAN: You can say anything that you want verbally.
JORDAN: Great.
So visualize a cube.
And we're looking at it only from the three sides.
And the middle of the cube is where everything intersects.
So we have three diamond-looking shapes connected to make a cube.

DAVID MALAN: From the chuckles, I'm not sure that's enough.
Go on.
JORDAN: OK.

Imagine you're looking at a Rubik's cube, but without all the
three by three grid and everything.
And one of the pointy edges of the Rubik's Cube is literally in the middle.
And you're looking at it from a very weird perspective of--

yeah, I'm not too good at this.
DAVID MALAN: That's OK.
Want to take one more stab?
JORDAN: One more stab.
Let's see.
DAVID MALAN: Maybe lower level.
JORDAN: Lower level.
OK, so
DAVID MALAN: [INAUDIBLE]
JORDAN: Yes, [INAUDIBLE].
So first, draw a hexagon.
Hexagon is six sides.
OK, yeah.
Draw a hexagon with a Y-looking shape connecting the top left, top right,
and center bottom together.

I hope that helps.

DAVID MALAN: Want to stop there?
Do we need a little more instruction?
Maybe for the chuckles, but one more instruction, even lower level.
Tell them where to put the pen on the paper.
JORDAN: So start from the center of the paper.
From that center point, you're going to draw one line to the left,
one line to the right, and one line all the way
from the bottom from that center point.
And then you're going to want to make a hexagon
shape that will eventually result in a cube that has three sides, pretty much.
DAVID MALAN: OK, I think we've covered all possible approaches here.
So let's do this.
If some of my colleagues could very quickly collect, if you're comfortable
sharing, as many sheets of paper as we can in just a few seconds.
It's OK if we don't collect all of them, as many as we can, though.

All right, we have one, two, three sets of hands collecting.
Yuli, I think that'll be enough of the hands.

OK, OK, everyone's very eager to give us their sheets.
OK.
All right.
Coming in.
We have a whole lot.
OK, thank you, Vlad.
OK.
Nice.
OK, thank you.
OK, thank you.
We'll go through all of these later.
OK, so I'm going to cut over to my laptop's camera
here so I can show you, Jordan, a few of what
your classmates have drawn based on your description.
Here we have a teeny, tiny version thereof in the top corner there.
This classmate took a different approach.
OK.
This one here took several approaches.
There's that Y though, and a cube in the bottom
there, a few different cubes rotated a few different ways.
And maybe here's, how about one last one here,
a different sort of interpretation altogether.
So what Jordan was actually trying to get you to draw
was indeed a cube looking simply like this.
But I dare say it is hard.
But notice the different levels of abstraction
I was trying to nudge Jordan to operate at.
So you took the highest level abstraction first,
like, hey, all, draw a cube.
That alone is pretty useful information.
But how is it oriented?
Which way is it angled?
It's sort of non-obvious unless we go down a little layer below that.
And so then, of course, you proposed drawing a hexagon and then a Y.
And so that was getting a little more concrete, but even then,
it might have been a little non-obvious.
And then the last attempt I dare say you tried
was to say what you should draw concretely with the pen or pencil.
And here's where we could have gotten to the lowest level,
daresay, where maybe you could have even gone further and said, OK, everyone,
put your pen at the top of your page.
Now draw a straight line to the southeast of the paper,
then maybe go south on the paper.
And much like old school childhood drawing
games, where it's sort of up, down, left, right and frankly, like scratch,
we could have really gotten into the weeds had you drawn something
that you didn't necessarily know where you were going.
But eventually, voila, now you actually see the cube on the screen.
So wonderful attempt.
Let's go ahead and give Jordan a round of applause here.
Thank you so much.
All set.
Why don't we go ahead and reverse the roles a little bit here?
Could we get one other volunteer who has not been summoned before?
How about here, come on up.
Who do we have here?
Come on over here on the edge of the stage.
All right, for round two, which is going to be a little bit different,
we have coming up--

we have, what's your name?
VIREN: My name is Viren.
And I'm dual majoring in cybersecurity and computer science.
DAVID MALAN: Wonderful.
Nice to meet you.
Come on over to the middle of the stage.
We have to ask you now on the honor system here not
to look up because everyone else now is going
to see what it is you're going to draw.
And we'll reverse the roles and have the audience now program you verbally
by giving you step-by-step instructions for drawing
a different picture altogether.
Goal being for you to draw with this black marker on the easel.
And then every time you draw something, just step aside
so everyone can see what you have done.
But no looking up.
All right, here we go.
I'm going to show now the audience only what it is we'd like you to draw.
Step one, from anyone.
Just call it out.
AUDIENCE: Start with a circle in the center.
DAVID MALAN: Start with a circle in the center.

I'm hearing some uh-ohs.
But that's OK.
Step two.
AUDIENCE: There's a line like [INAUDIBLE] it's saying hi.
The circle is saying hi.
DAVID MALAN: The circle is saying hi.

Not wrong, but OK.
AUDIENCE: You start from the bottom of the circle [INAUDIBLE] Y.
DAVID MALAN: Start from the bottom of the circle and draw an upside down
Y. OK, nice.
Yeah.
OK, another step.
Shout it out.
Yeah.
AUDIENCE: Draw some arms.
DAVID MALAN: Draw some arms.
[LAUGHTER]
OK.
Other instructions?

Yeah.
AUDIENCE: Draw a line from the circle to hi.
DAVID MALAN: Draw a line from the circle to hi.
And albeit with some artistic liberties, I think that's pretty darn close.
Do you want to look up finally?
And a round of applause here.
[APPLAUSE]
Thank you.
Very nicely done.
Thank you.
So here, too, that was actually extraordinarily well done
for the instructions that were given.
So the hi, of course, is off to the wrong side.
But this, too, sort of speaks to the importance of precision.
It's not just enough to say that the circle is saying hi.
Probably should have specified top left versus some other angle.
And instead of, if I may, draw arms, we could
have been a little more specific as to the shapes or the angles of the arms
that we wanted to draw.
But of course, once you have implemented this solution to this problem,
drawing a stick figure, now you can abstract it away,
put it into your tool kit, call it a function.
And maybe that function in the future has certain parameters or inputs
we can pass in that specify the angles and the size and the word and so forth.
And again, that brings us back to abstraction,
being able to take something that first has to be done at a fairly low level,
but then all of us can build on top of that idea again and again
and hopefully, avoid ever having to solve precisely that same problem again.
I will review all of these later, if I may.
So that then is maybe our first activity in computational thinking.
But we did so much more this semester as well.
And in fact, if you think back from this week backwards,
we started, of course, with Scratch, this graphical language for dragging
and dropping puzzle pieces.
And some of you had played with that in middle school
or high school or sort of dabbled just for fun.
But the goal of Scratch wasn't so much Scratch,
but to introduce some of those fundamental concepts
that you see in a lot of programming languages, functions, and arguments,
and return values, conditionals, loops, variables, and more.
And it gave us this very comfortable place to experiment with those ideas
and to really hammer home the point that once things escalated quickly
in week one and we got to see in more traditional syntax still just
the same ideas, but just a lot of annoying parentheses,
and semicolons, and quotation marks, and sort of distractions
that hopefully by now you appreciate is not what programming is about.
It's not the intellectually interesting part.
It's just the annoying aspect of learning some new language
and understanding what that new grammar, that new syntax, that new vocabulary
actually is.
Thereafter, we began to explore how you can solve problems in memory.
We talked about arrays as really the first sort of way
to represent or to store information readily in memory
and solve problems like keeping track of multiple values at once.
We then took a step back from code and focused
on algorithms, step-by-step instructions for solving problems
for searching and sorting, and a lot of problems that, though we chose,
simple versions thereof are really omnipresent in the Googles,
and the Microsofts, the ChatGPTs of the world
that are constantly navigating super large data sets nowadays.
We talked at the lowest level about memory and pointers.
And rest assured that in almost any subsequent programming
language you learn, odds are you're building on top of those ideas,
instead of taking a deeper dive.
Those of you destined to major or concentrate in computer science
might dabble at that same lower level, especially if you like that there world.
But then data structures is really what characterizes a lot of computer science
and all of those trees, and tries, and hash tables,
and just using this canvas of memory to create things that only exist
sort of in memory and in our minds.
But if we draw pictures of them, they really do come to life
and solve problems all the more efficiently.
Then why Python, why SQL, why all of these more recent web languages?
Well, Python is much more useful in a lot of cases than C.
In fact, personally, I only use C between September and October
of each year.
And then I sort of have to relearn it the next year
because I just don't use it that much.
It's still incredibly popular and omnipresent,
but for fairly low-level applications, where performance and speed and memory
are really precious and important.
But most of us, when we start solving problems with code,
are probably going to reach for something like Python or R
or Java or some higher level language, like JavaScript
as well, just because it's easier to solve common problems with those
there languages.
SQL though, in particular, was a different type of language.
And it let us talk about something we might now
know as declarative programming, where it doesn't really
matter how you get the data or how you select it,
but just that you want to select some data,
and this is the type of data you want to select.
And there's no more loops and variables and conditionals.
The language just takes care of all of that for you.
And then, of course, there's the web, HTML, CSS, throw in some JavaScript.
This is what most every application with which we are familiar every day
nowadays uses for the web, for mobile devices as well.
But there too, once we got to JavaScript, if briefly, we explored,
we revisited those same ideas, functions, conditionals, loops,
again and again.
Now, this isn't the entirety of the world of programming.
There are other types of languages out there.
SQL hints at this.
Python hints of this.
Besides declarative programming, there's functional programming,
object oriented programming.
And there's still therefore, much to learn.
But we focus in CS50 on procedural programming,
step by step truly instructions for solving problems in code.
But there's even more out there to learn.
And indeed, when we end the course here with Flask,
the motivation there in particular is not
to teach some library or framework because those are a dime a dozen,
but to choose a simple one, so that you can really
explore the confluence of a lot of these ideas in your very own last problem set
and ultimately, final project, which of course, brings us now to week 10.
So the final project really is meant to be this opportunity
to take your newfound knowledge of programming and CS out for a spin
and build something of importance or of interest to you
without being handed a specification and told exactly what to do.
And you will find that this too is challenging.
And you will find that you're Googling and ChatGPTing, which
for this stage of the class is now welcome and encouraged
because a lot of computer science, a lot of programming, in particular,
is about just learning new things, some new functions, some new APIs,
some new library or the like.
That's never going to stop.
But you're going to get better at it.
And you're going to have all the more instincts
for how to read the documentation, how to recognize
that, oh, this language I'm now just learning
is actually pretty similar to this other thing I learned.
And in fact, if the best thing we hopefully have done in the class for you
ultimately is just to teach you how to teach yourself new things, because
in a few weeks' time, poof, we're all going to disappear from the stage here.
But you'll still have some problems presumably in the real world
to solve with code or otherwise.
This is the tagline from the specification.
All that we ask is that you build something of interest
to you, that you solve an actual problem, that you impact campus,
or that you change the world.
No pressure.
But ultimately, you strive to create something
that outlives this course, whether it's for your student group,
your personal life, your professional life,
just some proof of concept you've wanted to play with.
The final project capstone is your own.
And to get you there, we have this tradition of the CS50 Hackathon,
which will be starting at 7:00 PM later this week,
ending at 7:00 AM the next night.
It's meant to be one of these memorable collegiate experiences,
academic more so in nature, that is really
meant to be an opportunity alongside classmates and staff and friends
to collaborate on or struggle your way through some problem you want to solve.
Here, for instance, are some visuals from the most recent year.
A certain CS50 duck will await you to greet you.
But it really is just meant to be an evening and early morning
of solving problems, writing code, figuring things out, getting a jumpstart
on your same problem set.
Around 9:00 PM will first dinner be served.
Around 1:00 AM will second dinner be served.
And if you still have the energy around 5:00 AM,
we'll hop in some CS50 shuttles and head down the street to IHOP as well
for pancakes in the morning.
So if your schedule allows, do join us for this particular tradition
in a few days' time.
The CS50 Fair, meanwhile, after Thanksgiving break,
will be this opportunity to showcase the work that you
create via the final project for classmates and staff and faculty
across campus.
You'll gather here in a space on campus where some balloons and music
and food and others will await.
And it'll be an opportunity to take delight in the projects that each of you
have created over these past several weeks, exhibiting for the world
to see what it is that you accomplished and more importantly, learned
along the way.
The CS50 duck even lost his head, so to speak,
last year, was so impressed by this project.
So too will you meet Varun perhaps in that their costume as well.
And ultimately, will you receive, as have all of your predecessors
past, your very own, I took CS50, t-shirt
that hopefully you can wear proudly beyond the end of the course itself.
So that brings us now to our second game,
another opportunity to test just how much has sunk in from that fire
hose over the past several weeks.
If Yulia wouldn't mind coming up here on stage.
For this I think we need a set of six volunteers that have kindly
volunteered just before class began.
If teams one and two would like to come up.
A round of applause for having so proactively volunteered.
Come on up.
[APPLAUSE]

Come on up.
And let's go ahead.
And as we set up the tables and chairs over there,
if you guys want to come on over here into the middle.
We should have our one, two, three, four, five, six volunteers, team one
and team two.
So let me invite you to say hello to the world.
ISHIKA: Hi, everybody.
My name is Ishika.
I'm a sophomore in Lowell House.
And I'm concentrating in bioengineering.
HAYAT: Hi, everyone.
My name is Hayat.
I'm a first year in Matthew's studying computer science and applied math.
[APPLAUSE]
ANALISE: Hi.
I'm Analise.
I'm a first year in Canaday.
And I'm planning to study econ and CS.
[APPLAUSE]
JOHNNY: Hi.
I'm Johnny.
I'm a first year staying in Hurlbut Hall,
studying statistics and the history of science.
PRISHA: Hi.
I'm Prisha.
I'm staying in Greenough.
And I plan on studying computer science and economics.
[APPLAUSE]
PETER: Hi.
I'm Peter.
I'm a first year in Pennypacker.
And I'm studying applied math.
DAVID MALAN: All right, wonderful.
Thank you all.
Let's see if-- how about you three-- actually, hold on to the microphone.
If you three want to come over here.
If you three want to step off to the side.
We're going to have team one go first, and then team two.
And what we're going to have these teams do is play some CS50 charades.
Now, as they say in engineering circles, we have beta tested this idea.
That is, we tried this once with just the staff.
It went pretty well.
We've never done this live during class.
So we'll see how well our algorithm works.
But the goal of charades, of course, which
I didn't tell the six before they came up on stage,
is to act something out based on a word, a key word that we
put on screen for them.
And then your other two teammates are going
to have to guess what it is that person is acting out.
Each of you will have one minute to act out a sequence of CS50-related terms
that we've collected from the audience just before class began.
I love these faces that you're making right now.
And then after one minute, we'll switch to the next person,
switch to the next person.
So at any given time, one of you will be acting something out
and the other two will be guessing.

OK, we have one blank stare.
So let's repeat.
So one of you-- let's do this.
Let's act it out.
So you two come over here and sit down.
And you will be standing roughly right here facing the audience
so that everyone can see you.
But what you're going to be doing is acting out some word
that we are going to tell you what it is.
And that word is going to be over here.
That word is going to be on the screen.
So here too honor system.
You two cannot look up.
And when you're seated, you two cannot look up.
OK, in the future, we'll figure out how to use fewer words to explain this game.
So does that make sense now?
OK, so let's go ahead and let's give the microphones to these two people.
Yes.
All right.
And what you have in your hands, too, are these fancy Ray-Ban sunglasses,
which when you put them on, hold the button at the top right.
And that will start recording for 90 seconds.
And a little white light will turn on.
And then we'll have your little POV, point of view,
as your teammate is trying to act out on stage.
I'm not sure we should have chosen you as the first volunteer, but that's OK.
All right, so you want to go ahead and put those on?
If you want, yeah, it's just for fun.
I guess, yeah, we didn't expect to invite two people with glasses
already on stage, but all right, slight bug.
All right, so I think I've somewhat explained how this works.
I'm going to keep score with this marker using unary notation on the easel.
So each time these guys shout out the word that you're trying to act out,
I'm going to give you a point.
And then after all of this, you guys will have three minutes
to do the exact same thing, one, two, three.
And we'll see if your score is lower, or higher,
or hopefully not exactly equal to this team's score
because we have no contingency plan for that.
All right, are you comfy, ready?
All right, so you guys may not look up or behind you now.
OK, here we go.
Yulia, let's generate the first word.
And as soon as you see the word, you should start acting out this concept
and generally try to face the audience too, as well as your teammates.
OK, go.
PETER: What?
OK.

JOHNNY: Search.
PRISHA: Search algorithm?
Detecting.

JOHNNY: Algorithm.
DAVID MALAN: You can say skip if it's too hard.
JOHNNY: Skip.
PRISHA: Skip.
DAVID MALAN: It was inspect page from a browser.
Right click.
Control click.
Inspect page.
PRISHA: Run.

JOHNNY: Test?

Flask run?

DAVID MALAN: No.

PETER: Skip.
DAVID MALAN: Skip.
It was race conditions from databases.
PRISHA: Circle.

JOHNNY: Drink?

PRISHA: Drink.
Eat.
DAVID MALAN: Time's up.
That one was cookie.
PETER: Oh, my--
DAVID MALAN: OK, so the score is now this.
So let's go ahead and do this.
Let's rotate.
So you're off the hook.
A round of applause because that was difficult.
[APPLAUSE]
Who's up next?
I think what happened was the words we came up with in advance
were actually relatively simple.
And the ones you just saw were added by the group before class.
So here we go, round two.
So in two minutes, your team will be up.
All right, same thing.
You two may not look up now, but either of you may skip as needed.
And if you want to just stand back here so everyone can see you
and they can see you, too.
All right, here we go.
Generate.

JOHNNY: Iterate.

Loop.

PETER: Ladder.
JOHNNY: Tree.
PRISHA: Skip.
DAVID MALAN: Skip.
It was query, like from a browser.

Q equals query.
OK, next up.
PRISHA: [INAUDIBLE]
DAVID MALAN: Sure.
PETER: CS [INAUDIBLE].
JOHNNY: Student.
PETER: CS50 duck.
Artificial intelligence.

TF student.

CS50 project.
CS50 final project.
DAVID MALAN: Three, two.
PETER: Hackathon.
DAVID MALAN: No, time is up.
It was CS50 Fair.
So close.
All right, score remains the same.
Final round for first team.

OK, and again, for this round too, hit the button again
to record for 90 seconds.
If you want to stand back there slightly,
you can say skip whenever needed.
You have 60 seconds.
Go.

PETER: Hash map.
List.
PRISHA: Query.

PETER: Counting.
PRISHA: Sort.
PETER: For loop.
PRISHA: Iterate.
One, two, three, four.

Iterate.
For loop.
While loop.
Do while loop.

DAVID MALAN: Do you want to skip?
JOHNNY: Skip.
PRISHA: Skip.
DAVID MALAN: It was index.
PRISHA: Oh.
DAVID MALAN: Like directory index.

PRISHA: CS50 duck.
CS50 lecture.
PETER: CS50 stage.
PRISHA: Theatre.
Memorial Hall.
Stage.
Charades.
CS50.
PETER: Final lecture.
Oh, my God.

DAVID MALAN: Time is up.
The first was, this is CS50.
And that was bootstraps, pulling yourself up by your bootstraps.
OK, a round of applause.
[APPLAUSE]
OK.
All right, come on over.
All right, if you guys want to step aside, the first two of you
may sit down.
I'm going to--
OK, yep.
You got the glasses, too.
All right, all right.
All right, I'm going to clear the score.
And so same game.
Three minutes now.
One minute each.
And if you want to stand just over here, and then just
is being held the button at the top right.
Let me hit it over here.
And that'll start recording.
OK.
Right here.
OK, hopefully that worked.
OK, go.

HAYAT: Binary tree.
DAVID MALAN: Nice.
Binary tree.

We could end there.
But why don't we keep going?
HAYAT: OK.

ANALISE: Hashmap.
HAYAT: Tree.
Binary.
No.

ANALISE: Dictionary.

DAVID MALAN: I don't think we ever used this term in CS50.
ANALISE: OK.
DAVID MALAN: Skip.
Data trees.
ANALISE: OK.

Body.
HAYAT: Food.
In.
In.
Side.

Stomach.

In.

DAVID MALAN: Time.
Internal server error.
OK, let's go ahead and rotate.
But very well done.
One point.
[APPLAUSE]
Still close.
OK.
Oh, and if you want to stand over here.
And you guys, again, no looking up.
Yeah.
Just hold this button above your eye.
All right, there we go.
And here.
OK, go.

ISHIKA: Duck.
ANALISE: Hackathon.
CS50 hackathon.
ISHIKA: Look.
ANALISE: Search.
ISHIKA: SQL.
Duck.
Look for the duck.
Looks like a duck.
Code for the duck.
Oh, duck debugger.
No?
ANALISE: Check 50.
PRISHA: Skip.
DAVID MALAN: Skip.
Was 50 [INAUDIBLE].

ANALISE: One word.
Iterate.
Loop.
ISHIKA: Conditional.
For loop.
While loop.
DAVID MALAN: Yes, while.

ANALISE: Box.
ISHIKA: Dictionary.
ANALISE: Phone book.
ISHIKA: Database table.
Form.
Dictionary.
ANALISE: Hash table.
Hash table.
ISHIKA: Hash.
ANALISE: Hash function.
DAVID MALAN: Yes.
[APPLAUSE]
DAVID MALAN: And time.
All right, we have time for one more round.
Go ahead and rotate in.
So close.
ISHIKA: Is it still recording?
DAVID MALAN: It'll stop after 90 seconds.
OK, good.
OK.
And if you want to stand right here as well.
You're going to bring us home here.
Final round.
All right, ready, go.

Skip.
Main function.
ISHIKA: Duck.
HAYAT: CS50.

ISHIKA: Duck debugger.
HAYAT: Check50.
Does it-- duck.

ISHIKA: Rubber duck.
HAYAT: Rubber duck.
DAVID MALAN: Yes.

ISHIKA: Table.
Box.
Screen.
Hash.
DAVID MALAN: Yes.

ISHIKA: Iterate.

Concatenate.

ANALISE: Skip.
DAVID MALAN: OK, bubble sort.
Five seconds.

And time.
That one was break.
A round of applause for our volunteers.
All right, congratulations.
We have some wonderful prizes for you all.
Nicely done.
Thank you.
And congrats.
All right.
And congrats to our second team, too, for which we have some prizes as well.
Congrats to you guys also.
All right.
So thank you all.
And thank you all, since that was version one of that idea.
All right, so a bit remains before we wrap up with
one final audience participation opportunity.
So over these past several weeks, we've been using this tool, the Visual Studio
Code for CS50.
That said, it is an industry standard tool.
It's a popular, largely open source project,
which means that people in the real world use this as well.
Even though we've branded it as CS50-specific, that's only in the sense
that when you logged into cs50.dev, we gave you a customized version of VS Code
that frankly had a lot of features turned off, just to keep things simple,
that had a lot of settings pre-configured for you
so that at the beginning of the term, we don't
have to give you these long instructions for downloading something, installing
something, configuring something.
And then with so many of us having different versions of operating systems,
you just inevitably run into technical support headaches.
We don't want that in week one when hello world is already
a challenge in a language like C. However,
now that you're at the end of CS50 and perhaps
the beginning of your final project, we would strongly encourage you
to transition to Visual Studio Code itself or some other tool, if you
prefer, by actually downloading and installing it
now because even though you haven't done this particular process before,
odds are you're just a little more comfortable now
and perhaps a little more aware of what is code-related,
what is technology-related or the like.
And hopefully, you're just more comfortable troubleshooting problems
like this.
That said, it should be hopefully, a relative breeze
to install, except for maybe one or two things that
invariably arise in the real world.
But now hopefully, you're equipped for that.
That said, if you go to CS50's documentation,
we additionally have some steps there that
will allow you to configure your own version of VS Code similar to what
we did for CS50, just to get you back into a comfortable space.
But this is maybe one of the best things you
can do for your final project is, if you're willing, stop using cs50.dev,
get it working on your own Mac or PC, if only so that by the end of the class,
you're truly decoupling yourself from all of and the last of CS50's
so-called training wheels.
That said, other things that you can do as you now have some 10-plus weeks
of CS50 under your belt, install some command line tools on your Mac or PC.
At least if you are now all the more computer science inclined,
the reality is that a lot of us, myself included,
tend to prefer operating at a command line environment instead of a GUI
because you can do things faster with code.
You can automate more things.
And so it turns out that if you install the developer tools from Apple or these
here from Microsoft, you can have a very similar environment and capabilities
on your own Mac and PC.
And funny enough, on Mac OS at least, and in some form on Windows,
you actually have a command line environment
that you might just not have ever used.
So there's good documentation online for actually exploring those features too.
Learning Git.
So we've been using github.com for quite some months using
your accounts to log in.
And we're also storing backups in the cloud on GitHub servers and the like.
But the reality is in industry, GitHub is used not just for those things,
but so much more.
GitHub and tools like it are really the de facto standard
for collaborating on code with other people and for versioning your various--
versioning your code.
So for instance, Google Docs nowadays and other tools
have a revision history type menu that you can scroll back
in time through changes you've made.
That's incredibly useful for code as well.
But generally, in the world of code, even though in CS50.dev we
have automatically been backing up your code
like every five minutes just to make it a little easier
to roll back in time if need be.
In the real world, what programmers would generally use
is a command line tool called Git.
And when they're ready to save a new version of their code,
they would run a few commands, maybe push it optionally to the cloud
so that it's a little more thoughtful.
And it's not just this massive, long chronology
of changes, but very deliberate milestones
that the programmer is reaching.
So CS50's own Brian Yu has a wonderful video at this URL
here that you might find useful for just onboarding yourself
to a very popular tool that if you ever work in industry on code, invariably
you'll end up seeing or using the same.
Hosting a website.
So if you're thinking of having a portfolio website or your resume
or just something fun or personal or professional online statically,
there's some good websites out there.
For instance, GitHub has its own service, which is free,
called GitHub Pages, which allows you to use your existing GitHub account,
write some HTML files or even things called
markdown files, some CSS files, JavaScript.
And with the right commands, you can post it to the internet at a domain name
either from GitHub itself or one that you buy and use for the same.
So these are two such websites via which you can host static websites pretty
easily as well.
When it comes to full fledged web applications,
so using Flask or maybe server side JavaScript or some other framework,
then you might want to use different set of tools altogether.
So among the big cloud providers out there, Amazon and Microsoft and Google,
these are URLs to free versions of their cloud services
that at least while you're formally a student
generally have free access to for some amount of time or some amount of credit,
so to speak.
GitHub has its own student education pack,
which similarly gives you capabilities that to date CS50
has made available to you for free thanks to our friends in industry.
But you as an individual student can also take advantage of these resources
without subsequently using any of CS50's infrastructure.
Here are two other popular websites nowadays too
that are more easily used, I do think, than the bigger cloud providers at top
there to just deploying your Flask application or something
else to the cloud.
Which is to say this is a good list of ways
you can put your very own final project, if it's a web app,
on the actual web and outside of your code space.
Asking questions.
So this is kind of a new slide.
We weren't really talking about ChatGPT a year ago,
but now it's sort of omnipresent.
And indeed, even I sort of when it's come to preparing for classes,
learning some new language, learning some API or framework, I mean,
among all the technologies I've seen over the years,
this was probably the one that changed my own behavior
over just a matter of days or weeks, as opposed to being more evolutionary.
And indeed ChatGPT, which you're now welcome and encouraged to use
for your final projects instead of just the duck,
is pretty game changing because one, it's
been trained on a lot of computer science and programming data.
Two, a lot of the human content on the web
tends to skew technological when it comes to those same domains.
And so frankly, too, because CS50 has long been OpenCourseWare,
you can even ask ChatGPT about CS50 concepts.
And they're already built in there as well,
which is to say that in the absence of a friend, a sibling, a colleague, a boss,
a parent, or anyone else, asking ChatGPT is your virtual teaching
assistant next to you or colleague that's already pretty game changing.
And there's features too in cs50.dev and in VS Code
more generally that we've actually turned off by default for months
because it would have just taken away the opportunity to develop some muscle
memory.
So a very popular tool nowadays in industry
is something from GitHub too called Copilot,
which essentially is an extremely more useful version of autocomplete
in your browser.
And it can actually write many more lines of code
than, say, traditional autocomplete and certainly more than the duck by design
allows.
So that too is something that you might want to play with in your own accounts
as well.
But there's still humans out there.
And these are some popular places and websites
just to ask questions of actual humans.
Remains to be seen how websites like this evolve over the coming years
if we're turning more so to AI.
But these are some of our favorites.
And then just keeping abreast of news, two good sources
that you might be reading already are TechCrunch and then
Hacker News, the URLs for which are on the screen here.
And if you just generally want to stay abreast of changes in technology,
these are two popular spots among others as well.
And then you can take classes.
So there's certainly the traditional program here on campus,
be it at Harvard or Yale, through the college or extension school or beyond.
But even CS50 over the years for incoming students and outgoing students
has been putting together a set of free, OpenCourseWare courses
that you can take for fun for free over winter break, over the summer,
just at your own pace or leisure, including these URLs here.
And just to give you a wave of the hand at what each of these courses
allows you to do after CS50 itself ends, we
have a course called CS50P for short, which is a Python-specific class.
And it does assume from the get go no experience with Python,
but very quickly goes more into depth than CS50 itself does,
covering topics like these, only some of which we've seen in CS50 itself,
but really do round out your comfort with
and understanding of a language like Python.
So over winter break, if you just want to get better with Python,
this might be one place to start.
If you're more leaning toward the sciences, and the statistics, data
science world and the like, we have thanks to CS50's own Carter
Zinke, a CS50 course on R specifically, a popular programming
language for those domains covering topics like these.
A course called CS50W by CS50's own Brian Yu, which really does pick up
where CS50 leaves off this week and focuses all the more on web programming
specifically, going more deeply into other frameworks, other technologies,
other trends, including some of the topics you see here on the screen.
There's a games class, if you skew a little more artistically or game
oriented and you want to actually build your own two-dimensional games as well
by understanding already a bit of programming.
There's CS50AI by Brian as well, which goes more deeply and theoretically
into artificial intelligence and how you can build on top of it
yourself using Python as the language of choice.
And then if that weren't enough to do over winter break,
there's a class specifically from CS50's team on SQL,
which goes more deeply into what we dabbled in over the past few weeks
to round out your knowledge there.
So this too really speaks ultimately to one of the design goals of CS50,
is that it's not meant to be a course in C. It's not
meant to be a course in Python.
It's not meant to be a course in JavaScript or anything else
we discussed, but a course in programming period so
that by the end of this course, which is effectively now followed
by your final project, hopefully you'll exit the class with not having mastered
each and every one of these languages, which frankly, will take months
or years unto themselves, but rather feeling comfortable with
and confident with your ability to teach yourself new things by finding patterns
in future languages, future projects that, oh, that's like that thing
we learned in CS50.
And that really is the goal, to enable you to think like a computer scientist
and also program like one as well.
Of course, there's a lot of threats in the real world.
And so the last of the courses I'll put on the screen
here is CS50's own Introduction to Cybersecurity,
which will allow you to explore some of the threats, all of the things
that can go wrong when you are writing code or using someone else's, only a few
of which we touched upon in this class, like SQL injection attacks and the like.
There's so much more, unfortunately, underneath the hood to beware.
And in the months to come, the years to come, whether you're
still on campus or off, we hope you'll consider
applying to be a teaching fellow, a teaching assistant, a course assistant.
Stay tuned for emails from us so that you can join CS50's team over time.
And too even after you graduate from CS50 or college more generally,
do consider staying in touch.
We have a vibrant community of alumni of the course from Harvard, Yale,
and beyond, online as well.
Before we turn to our final fun and game,
allow me to just give some thank yous to folks in and outside of the class.
So one, the team at Memorial Hall who brings us into this space each week
and gets everything ready for us.
Two, the ESS team who kindly makes everything sound so good
as we're playing demos and having everyone walk in and hear things.
[INAUDIBLE], our friends up the road that so many of you
have joined us for lunches at, they're open outside of CS50 hours too,
so feel free to stroll up Mass Ave to join them another time.
And then of course, CS50's production team who is often there and there
and there.
Maybe a round of applause for--
[APPLAUSE]
Ironically, making it possible for you to not have to be here all of the time.
Thanks to the team for making all of this hopefully look so good.
And then most importantly, the humans that have been behind CS50, CS50's team
here at Harvard, CS50's team here at Yale,
that you too can become members of over time if you so choose to join us.
And then lastly, of course, this here, that there, that there,
CS50 duck thanks to CS50's team, Rongxin,
and others for having brought that duck to life, so to speak.
And that brings us to our final segment today
before we'll adjourn to the transept for cake.
This being the CS50 quiz show, which is something in which all of you
can partake.
So we need no more volunteers other than everyone here in the room.
You're about to experience a sequence of 15 CS50-related questions
and an opportunity for us to really assess or really check, if you will,
your understanding of the same.
And upon the 15th question, we'll be adjourned for that cake.
I think we are just about ready.
Hopefully, on your phones now, you see an interface
via which you can respond via multiple choice to this question.
Which statement is correct in C, printf, "hello" semicolon, print "hello",
print hello, printf "hello"?

And we'll see as the responses come in.
93% of you are voting for the first answer.
4%, 3%, and 2% of you disagree slightly, but I
suspect that percentage is realizing missing semicolon,
missing quotes, missing semicolon.
And we see the answer already.
The answer with 92% correct is indeed the first answer.
Very well done.
How about the next question?
When using malloc, what should you always do
when you're done with the memory, let it be, free the memory,
break out of the program, delete everything?

OK, 97% this time.
I'll note, too, that these are questions you all
wrote as part of the prior problem set, wherein
we asked you for some review questions.
These are your questions and your answers.
I guess let it be is not wrong, but OK.
Free the memory is the correct answer there.
All right, nicely done.
How about question three?
Which of these was the first widely recognized computer
bug, a spider in the vacuum tubes, a moth stuck
in a relay, a mouse in the keyboard, a cockroach in the power supply?

All right, 61%, 60% voting a moth stuck in a relay.
But a cockroach in the power supply is a strong 22%.
Spider in vacuum tubes.
All right, the numbers are still coming in a little bit.
Yulia, should we reveal that only 61% of you were correct this time.
This is the old--
this is the old story involving Admiral Grace
Hopper, who was reported to having documented the phrase formerly
in her log book.
Moving on.
Which of the following is the correct way to create a variable in C
and assign a value to it, var x equals equals 10 semicolon,
x equals 10 semicolon, int x equals 10 semicolon, int x colon 10 semicolon?
In C. All right, should we see the chart?
All right, int x equals 10 semicolon with 92%.
Shall we look at the answer?
That of course, is correct.
Moving on to question five.
What does FIFO stand for?
Spoiler.
Well, it's definitely not last in, first out, anyway.
First in, first out.
First in the far.
Far in the farther.

97% voting this time.
I think we can click to the solution.
Indeed, very well done.
First in, first out refers to our discussion of queues
because you put it in first.
And that hopefully for equity sake, is the first thing to come out as well.
All right, moving on.
Question six, which data structure in Python
uses key value pairs, strings, lists, arrays, or dictionaries?
Which data structure in Python?
Huge voting turnout for dictionaries.
And I think we can just say yeah, that's the right answer.
So dictionaries, of course, are all about key value pairs,
can be implemented underneath the hood as something like a hash table recall.
Number seven, which Sesame Street character
was the star of David Malan's scratch game I think in week zero,
Oscar the Grouch, Big Bird, Elmo, or Bert?

Week zero.
Wow, 79, 80, 81%.
None of these characters have made an appearance here.
And 80% voting for Oscar the Grouch.
And indeed, that's the correct answer.
All right, number eight, what's the time complexity
of inserting a new node at the beginning for a linked list in C, big O of n,
big O of 1, big O of n squared, big O of log n?
Well, this one's going to be interesting.
All right, it's much more of a mix.
The time complexity of inserting a new node at the beginning of a linked list,
keeping in mind that the beginning never moves,
never gets longer because it's always right there.
So I dare say, Yulia, with 52% reporting in, big O of 1 is in fact correct.
It might not take one step.
It might take two or three, depending on how many pointers you
need to manipulate.
But if you're always inserting it, inserting it, inserting it,
or prepending it in front of the list, odds
are you can do that indeed in constant time.
All right, getting more challenging.
Number nine, getting less challenging.
Number nine, what does exclamation point equal sign mean in C, equal to,
greater than, less than, not equal to?

Correct.
All right, means not equal to when you have the exclamation point, a.k.a. bang,
equals sign, which negates the meaning of equal.
All right, 10, in SQL, what keyword sorts the results of a query,
group by, sort by, organize by, order by?

A majority are saying order by.

Organized by was not a thing.
Sort by is a reasonable incorrect guess.
Group by does something different.
That's when you actually want to do some kind of aggregate query
by grouping by some common value.
Order by was in fact correct.
Order by ascending, order by descending were the two things we saw there.
All right, few questions to go.
Number 11, what's the main advantage of using a linked list over an array,
they give faster access to elements, they have dynamic size,
it is easier to sort, less memory is used?

Linked list over array.
Interesting.
All right, so only 70%, but I think we've
gotten every question right by a majority at least,
is indeed, if we want to reveal the correct answer.
So linked lists are advantageous because you can insert.
You can remove.
And you don't have to worry about moving everything around in memory,
like you would for an array.
They don't really give faster access to elements, though,
because you lose binary search, at least as we discussed,
because you don't have random access to any of the nodes directly.
Easier to sort, not really because there's so much more work
to do back and forth, back and forth.
Whereas, with arrays, you can just swap things using their indices.
Less memory is used, your opposite is true.
You're using more memory, like an extra space for all of those pointers as well.
All right, few final questions.
What sort algorithm swaps adjacent items in a list until the list is in order?
I think we saw that Acted out before, hint, hint.
All right.
Yes, bubble sort with 90% I'm pretty sure it's correct there.
All right, three questions remain before we get cake.
And what can result in a stack overflow, touching areas of memory you are not
supposed to, accessing an array out of bounds,
incorrectly modifying a variable, calling too many functions?
This one will be interesting too.

We have no majority vote this time.
Which can result in a stack overflow?
So as the votes continue to come in and change,
recall that when we depicted memory as being this abstract rectangle,
we had the stack down here.
We had the heap up here.
And every time we called a function, we added another frame
to the stack, another frame to the stack,
like trays on a stack in a cafeteria.
So the more functions you call--
you can change your answers.
The more functions you call, the more and more memory
you use that at least pictorially are growing up, up, up, up, up, up.
And if you finally do--
OK, so I guess--
OK, calling too many functions is what we were getting at.
39% though.
So not a majority.
But two questions left.
Let's see if we finish strong.
What do we call a reference to a memory address in C, a determiner, a pointer,
a resolver, a compiler?
Question 14 out of 15.
OK, strong 96% for pointer.
I think we can agree that's, in fact, correct.
And lastly, with a final flourish and maybe
before we see 15, a round of applause for our CS50's preceptor,
Yulia, for having run the show here.
[APPLAUSE]
Let us look at question 15.
Quack, quack quack, quack quack quack, quack quack quack quack.

Before there was AI, this was literally all the virtual duck did.
So it's pretty split between one, two, three, and four quacks.
48, can we get to 51%?
No?
Yes.
Yes.

There's not even a correct answer here.
But in any case, how about that's it for CS50.
Cake is now served.
[APPLAUSE]
[MUSIC PLAYING]
