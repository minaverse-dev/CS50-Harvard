[VIDEO PLAYBACK]
[MUSIC PLAYING]

[END PLAYBACK]

DAVID MALAN: All right.
This is CS50 and this is our last week in this year's studio
as we focus finally on web programming using not only Python,
but a framework within Python called Flask,
and combining with web programming--
HTML, CSS, perhaps some JavaScript-- and so many
of the ideas that we've been exploring over the past several weeks.
Indeed, today is really about combining all of those various building blocks
so that ultimately you can build something of your own
not only for this week's problem set, but perhaps if you so
choose, for your final project as well.
Now let's consider where we left off last time, which
was introducing HTTP, hypertext transfer protocol, whereby we introduced you
to how the browsers of the world and the web servers of the world inter
communicate using HTTP and a whole bunch of other protocols underneath those
like IP and TCP in particular.
So last week, though, when we began to write HTML and CSS and even
a little bit of JavaScript, recall that we served up the web pages
that we wrote by using a very simple command in VS Code
that we pre-installed for you, namely http-server.
This was a little program whose purpose in life
was just to listen for HTTP requests coming from your browser, or really
any browser, and respond to them by sending the contents of files
from your code space to the browser.
Typically a .html file, but if you had an image like a PNG or a GIF,
it too could get sent, a JavaScript file, a CSS file.
Really, any files stored in your code space
could be served up by http-server statically.
And indeed, that's the key word here is that everything we did last week
was, within the context of HTML and CSS, static.
We wrote it, we saved it or autosaved it,
and then we loaded it in our browser.
If we wanted to make a change, we would go edit the file,
resave it or let it autosave, and we would reload in the browser.
But only once we got to JavaScript did we have any kind of dynamism.
When I demonstrated, for instance, very briefly how we might implement something
like autocomplete, searching for all of the words that
start with C-A-T in that big dictionary from problem set five.
But today, we're going to focus on things more server side.
In fact, even a little bit of JavaScript that we introduced last week
was all client side.
That JavaScript code was written once on the server, downloaded to the browser,
and then executed in the browser.
But as a result, that JavaScript code didn't have access to, for instance,
any information that might be stored in a database,
unless somehow we enable it to somehow communicate
again and again with that server.
So really what we're going to do today is
dive into the world of web programming where
we're actually going to write code in Python using functions and loops
and conditionals.
And unlike last week, we are going to use code
to generate our HTML for us so that we can stop doing everything by hand,
especially for websites that might have dozens,
hundreds, thousands of web pages.
There's no human in manually generating each of those web pages.
It's somehow dynamically generated through web programming.
So let's begin where we began last time, focusing
on the structure of how we might request web pages,
because we're going to make a little tweak this week.
In particular, last week, we looked at a canonical URL like this.
Https-- which is the protocol or scheme--
://www.example.com/.
And recall that the slash typically indicated that we wanted the default web
page for the website.
Now, that wasn't really germane last week
when we were playing with a whole folder of files,
but if you were to request the default web page on a website,
it's typically, by convention, literally a file
called index.html, at least on a lot of platforms.
Sometimes it might be called index.htm, sometimes
it might be called default.aspx.
There's different conventions, but very often when you just request slash,
you're technically referring to a very specific file that
has been configured on the server to be the default page that's served up.
But you can, of course, be specifying specific files or even folders.
So we looked at URL formats like this.
If you want file.html, you simply append that to the end of the slash.
If you want the default web page inside of a folder, you might do /folder/,
and the server would serve that file up for you.
If you want it to be more explicit, you could specify /folder/file.html so that
you can actually grab a specific file from a specific folder.
And suffice it to say, you can nest these things again and again
if you've got multiple folders and subfolders.
But today, and really onward, we're going
to start talking about everything after the TLD as really being the path
that the browser is requesting.
So /path is just meant to generically mean whatever files and/or folders are
being requested in URLs.
And we're also going to introduce slightly different nomenclature
this week to that, yes, technically that's
a path specifying a specific file in a specific folder or a set of folders.
But in the context of web programming, what's especially powerful,
those files and folders don't actually need to exist.
Using web programming, using Python, for instance,
you can specify specific paths that don't actually exist in your code space,
but that represent a resource--
indeed, Uniform Resource Locator for URL--
a resource that you want to be able to access via your browser.
So route generically means, what path do you want to select on a web server?
Now, what's this going to mean for us?
Well, once we have configured a route in code,
we can even specify that that route takes user input.
And recall that from last time, we introduced you to how google.com works.
And we didn't implement the back end of Google.
We let Google do that.
But we did implement our own front end for Google
that allowed you to fill out a very simple form, click Enter,
and the web browser would then send automatically a request to Google server
that somehow had key equals value.
Particularly Q for query equals, for instance, cat.
And all of that followed a question mark.
So this same URL format here whereby we have /route, which refers to some path,
and then question mark key equals value, and maybe an ampersand and more key
equals values, means that today we're going to have the ability to implement
the back end of Google if we so aspire.
Or really, the back end of a website.
And back end just means the part that really the programmer
implements and touches.
Front end generally means the part that the human, the user, interacts with.
All right.
So with that said, let me propose that if we
want to be able to read URLs of this format that
have some key equals value and maybe some other key equals value,
we actually do need to introduce a bit of code.
So let's consider now how this request, this HTTP request,
is getting to the server.
Well, recall that when you request something like cats via web page
submitting to Google via form, technically inside of that virtual
envelope is a message like GET /search?q=cats.
Then some mention of the version of the protocol being
used, like version 2 of HTTP.
Maybe a reminder of the host of the server
that's specifically being requested.
And then a bunch of other stuff that we saw last time as well.
And ideally, we want the server to respond to that request.
But here's where things get interesting.
How in the world do you go about writing code that opens up that virtual
envelope, reads that get line and the /search and the question mark and all
of those keys and values?
Well, we could write code very methodically, maybe using a for loop
and iterating over every character, but that sounds like a lot of work.
And in fact, it's been much better in CS50
alone that once you understand some concept, rather than reinvent that wheel
yourself, use a framework, or rather, use a library instead.
And indeed, that's what we're going to focus
on today is a very popular micro framework in the world of Python,
which means a relatively small library that solves some very common problems
and saves us the trouble of having to write all of the code that reads
the insides of those virtual envelopes and figure out exactly what web page is
requested or route and exactly what keys and values were passed in.
To do so, we're going to go ahead ultimately and not
use http-server anymore.
That recall is a command that only serves up static content.
Starting today, we're actually going to run a command, namely flask run.
So not only is Flask a library, as we'll soon see,
which means we have functions and other features of it we
can use in our own code.
It's also, once you install it, a command
that you can run in a terminal window like your own code space.
And so ultimately, instead of running http-server today,
we're going to run flask run to still start a web server,
but a web server that's even smarter than http-server because it's not just
going to spit out the raw contents of files to the browser.
It's actually going to execute your and my Python code to generate those web
pages dynamically.
So in order to get to that point, we're going
to have to start creating some files of our own
and really writing some programs of our own.
And the convention when using Flask, this popular micro framework-- which,
again, is just a library that standardizes how you and I solve
some common problems-- we're going to need typically at least two files,
one by convention called app.py and a second one
called requirements.txt or T-X-T. And each of these files in conjunction
will be understood by that flask command because Flask
knows to look for a file like app.py and knows how to execute it.
And as we've done so many times in past languages
here, for instance, now in Python, while using the Flask framework,
is how we might implement the simplest of web applications.
So at a glance, this is going to look a little strange because there's
a lot going on on the screen.
But clearly that first line indicates that we
are importing, from a library called Flask, some kind of feature
known as Flask capital F.
So it's a little weird, but that's often a convention
to import from something lowercase, something that's
capitalized to make clear that it's really
what's called a class in the world of object oriented programming.
But more on that down the line.
And then the second line of code says to Flask,
please turn this file into a web application.
So this is a little arcane, but underscore underscore name underscore
underscore is something we saw so briefly a few weeks back in week six
when I said at the time, you sometimes need to check what the name of this file
is and does it equal, quote, unquote "underscore underscore main underscore
underscore." because that enables you to more correctly implement libraries
of your own.
Which we did not do, but I just mentioned
that you might see it in the wild.
Well, here it is again in a different form.
Underscore underscore name underscore underscore is essentially
a special variable that refers to the name of this current file.
So the second line of code is essentially
telling Flask, please turn this file into a web application
and let me refer to it via variable called, quite simply, app.
A-P-P. Now, after that, there's some new weird syntax,
but this is technically just Python, a feature we haven't yet seen.
Technically, you're seeing now at sign for probably the first time, app,
which is that same variable, dot route, then an argument there too.
So this is what's an example in Python of what's called a decorator.
And a decorator is a feature of Python whereby you can
wrap one function inside of another.
For our purposes today, what this third line of code essentially means is,
hey, Flask, please turn the following function
into a route that can be served up by the server to a browser.
What is that function?
Well, the function that I want to associate with that route
is literally a function called index, but I could call it anything I want.
I could call it foo, bar, baz, or anything, but index makes sense.
If this is meant to be the index of my website.
And the only thing that function does for now
is literally return a string or str, in Python speak.
Namely, quote, unquote "hello world."
So that is it.
And the fact that the argument to the app.route function whereby route is
a function or method inside of that app variable or object, the quote,
unquote "slash" just tells flask whenever the user visits example.com/,
please call this function and send to the browser whatever this function
returns.
Now, long story short, this is not the only way to implement a web application,
but this is the way to do it using Flask, this very popular microframework.
If you were to use something else-- like in Python,
there's a framework called Django, and there's many others
in many other languages as well.
This just standardizes for us what are the conventions when
I want to create a route and I want to return some HTML,
because you can solve that problem any number of ways.
But what's important today is really the application of last week's ideas,
even though we're using a very particular framework.
And this is not meant to say that you're learning Flask in CS50, per se,
but you're learning a web framework that's
going to be representative of many others out there as well.
But we chose one that's both popular and relatively simple.
So with that said, I think let's go ahead and implement the very first
of our web applications here, namely by switching over to VS Code here.
And within my VS Code environment, I've sort of hidden some distractions.
I've already closed my activity bar and I've closed the File Explorer so that,
as always, we have room for some code tabs
and we have my terminal at the bottom.
But like last week, I also have an additional tab inside
of my terminal area here for not only the terminal window itself, but also
these here ports.
Recall that last time we talked about TCP ports
in particular, unique integers that identify certain services like 80
for web servers or 443 for the secure version, HTTPS thereof.
Here again we see port 1337, which is meant to connote leet,
because this is a CS50 specific use of this TCP port.
But soon we'll see another port, just like we did
last week when I launched HTTP server.
So let's go ahead first and create a file, for instance, called app.py.
And just to keep things simple, I'm going to isolate all of these files
to a specific folder.
So I'm going to create a new folder with mkdir,
and I'm going to call it hello for my first application called hello.
I'm going to cd into hello.
And indeed, now I'm in there.
And now I'm going to run code of app.py to begin
writing the contents of this here web application.
And for this, I'm pretty much just going to use
the contents of the sample program we saw a moment ago by doing the following.
I'm going to say from flask, import Flask, lowercase f and uppercase F
respectively.
Then I'm going to say app equals capital Flask underscore underscore
name underscore underscore, which is the line of code that says, hey,
Flask, turn this file into a web application
and give me a variable called app via which to reference it.
And then down here, I'm going to do at app.route, and then in parentheses
pass in a single argument.
Slash.
I could use single quotes, I could use double quotes.
For consistency with C, as we did in week six,
I'm going to keep using double quotes most of the time.
Now I'm going to go ahead and define a function in Python called index,
but I could call it anything I want.
This particular function is not going to take any arguments,
so all it's going to do is return a string or str of text, hello comma world
and that's it.
Now, just to be consistent with style50, I've
actually deliberately left a couple of lines
a blank in between my function and everything above it.
And that's just a stylistic convention in Python.
But otherwise, this is just some relatively little Python code,
albeit using a couple of new features, a new library
and using a new piece of syntax, the at sign, for that so-called decorator.
And again, to be clear, all a decorator does in Python or in this particular
case, is it says, hey, Python, turn the following function into one that should
be called automatically whenever the user requests the /route.
All right.
I need to do one more thing, at least on some systems.
Let me go ahead and run code of requirements.txt.
And in this file, I'm going to simply specify what are all of the libraries
that I want this web application to use.
And I'm quite simply going to say Flask, capital F here.
But strictly speaking, it's not necessary because in cs50.dev
because we've pre-installed Flask for you.
But in general, and certainly in the real world, what I'm doing now
is associating with this application zero or more list of dependencies,
libraries that I want someone to install in order
to ensure that this thing here works.
That's all I need to put in this file.
But even though it's already been installed, what I can do is this.
Let me go ahead and maximize my terminal window here
and let me run that command we ran briefly back in week six
when we wanted to install libraries.
I'm going to do pip install, and instead of installing cowsay or something
silly like that again, I'm going to do pip install -r requirements.txt.
And what this command would do for me if Flask is not already installed
is it would install it for me on this here system.
So I'm not going to bother executing that because I already did it
earlier for everyone's code space, but that's
indeed how we could use that requirements file
to automatically install things without the manually typing
that and other things out.
All right.
Well, let's go ahead now and do something incorrectly.
Suppose I'm in the habit of forgetting things
and I run http-server server in my terminal window.
I can certainly run it and it's certainly
going to work, especially if I override this helpful reminder we put in place
to discourage you from doing this.
But I'm going to say, nope, I want to go ahead and run it.
I'm going to see the same kind of output as I saw last week.
I'm going to be prompted to open in a browser that particular web application.
But that particular web application is not really my own, per se.
It's just the contents of this folder.
So if I go ahead and zoom in on the directory index of that there folder,
we see my two files, app.py and requirements.txt.
If I click on app.py, I'm not going to get a hello world.
In fact, it was a little subtle, but what my Mac just did was
it downloaded app.py, which is not the goal I want.
And in fact, you've just let the world access your source code
if there's anything sensitive in that their program
because the browser doesn't know what to do with an app.py file
inside of my browser.
So that was incorrect.
So I'm going to go ahead and go back here.
But just to make clear that we do indeed have a second port running now,
just like last week, because http-server can't use port 80 or 443 because code
spaces--
that is cs50.dev-- is already using that for you.
It did choose the default port of 8080, which is commonly
used for development purposes.
And that's why we see not only 1337, but 8080 now as well.
So let me go ahead and back to my terminal window, hit
Control-C to interrupt http-server.
And let me now do things the right way by running flask run, Enter.
And what we'll see now is that my application
is running not on 8080, but on 5000, which happens
to be Flask's default choice of ports.
But you can override this if you so choose.
But I'm going to stick with that one.
And now, even though it's a little underwhelming, I'll zoom in.
Now I see hello comma world.
And in fact, if I right click or Control click
on Chrome here or your browser more generally and, for instance, View Page
Source, you will see that there's really no even HTML here, just text,
because what I've essentially sent to the browser
is just literally hello comma world.
But already we have a building block here.
Clearly I can write Python code that generates
output that is sent to the browser.
So really, there's nothing stopping me from now sending not just raw text
but actual HTML to the browser.
Let's do this poorly at first.
Let me go ahead and hide my terminal window
just so we can focus on code now for a moment,
even with Flask actually running.
And this is going to look deliberately ugly for the moment, but let me go ahead
and do this.
If I want to send the browser a proper web page--
heck, I remember some HTML from last week.
So open bracket, exclamation point, DOCTYPE html, close bracket,
and then open bracket html, then lang equals quote, unquote "en" for English.
Then I'm going to go ahead and do head for the head of the page,
and then title for the title therein.
And I'm just going to say something like hello comma title, like I did last time.
Let me close that title tag.
Let me close that head tag.
Let me open now my body tag.
Inside the body I'll say hello comma body.
I'll close the body tag, I'll close the HTML tag, and I'll close my quotes.
But I'm going to be careful here.
Notice that I used an attribute value in here with double quotes.
That's probably going to confuse Python because I
have these outermost double quotes, so I can fix this in a couple of ways.
I'm going to go ahead and use therefore single quotes
on the outside of this Python string, which unlike C is fine for strings,
not just chars as in C, and I think that will at least assure that the quote
marks don't get confused.
All right.
This is probably not going to be the best design,
and hopefully this is not how we generate web pages.
But let me go ahead back to my other browser
tab, which previously said hello world.
Let me reload now.
And I seem to have changed not only the output of this web program,
but really, the contents underneath the hood as well.
Let me right click or Control-click on the white portion of my screen here.
And there is some proper HTML.
It's not particularly pretty printed.
There's no new lines, there's no indentation.
But if I scroll from left to right in my browser here,
there is a well-formed web page as I intended.
So again, not particularly fun, not particularly pretty,
but we seem now to have the capability of writing code that generates not only
text but HTML as well.
So how can we go about improving this program further?
Well, let me do this.
This is not really the nicest design, so let me go ahead
and highlight all of this HTML I just wrote and let me go ahead
and cut it to my clipboard.
And let's come back to that code file in a moment.
Let me go ahead and reopen my terminal.
I don't want to kill flask run just because it's
convenient to keep it running.
So I'm to create a second terminal window by clicking plus,
and I can toggle between them at right here.
So one is still running Flask, the other is now a blinking prompt.
I'm in the wrong directory by default, so I
do need to go back into my hello folder with cd hello.
But in here, what I'm going to do now is this.
I'm going to go ahead and create another folder inside of this that,
by convention, is called templates.
And when I hit Enter here, I'm going to then do cd templates to go inside of it.
And now I'm going to create an actual full fledged HTML
file, index.html by convention.
Enter.
And inside of this file, I'm going to go ahead and paste
that long string of HTML, and I'm going to go ahead and clean it up
to look a little bit more like it looked last week.
And I'm going to even stylize it further here so everything's
very pretty printed and human readable.
And I'm going to put the head up there.
I'm going to put the body down here.
And below that, I will close my HTML tag.
So no different in terms of the content, but now
I have all my HTML in an actual file.
All right.
What do I now do with this?
Well, wouldn't it be nice if I could go back into app.py
and say, don't return just hello world.
Don't return this long, messy string of HTML.
But return the contents of a file called index.html.
Well, to do that, I can import not just Flask capital F from the Flask library.
I can also import a function called render template.
This is a function specific to Flask, but it does exactly that.
It will render a template for you in the sense of it
will go open an HTML file for you.
It will then send it from server to browser.
And as we'll soon see, it can even do some fancier stuff than that.
But now instead of returning quote, unquote "hello world" or quote,
unquote a big long string of HTML, what I'm actually going to do is something
like this.
I'm going to say HTML equals render_template.
And what template do I want to render?
Index.html.
And I'm going to store that template, so to speak, in an HTML variable.
And then I'm going to return that variable.
Of course, as we've seen in C and Python and even JavaScript,
we don't really need variables, per se, if we're just
defining them and using them once.
So I can actually tighten this up a bit.
Let me go ahead and highlight the actual function call, get rid of the variable,
and let me just immediately return the return value of render_template
passing in index.html.
Now notice the subtlety.
If I back to my terminal window, recall that I
created index.html inside of my templates folder, which
is inside of my hello folder.
But render_template is smart.
As its name implies, its purpose in life is
to render a so-called template-- more on what we really mean on that in a moment.
But by default, Flask knows that if you're
trying to render a template, oh, sure, it must be in your templates folder.
It's got to be all lowercase, templates.
Your file has to be exactly named as I'm specifying here.
But this is now how a web server can associate a route like slash
with a specific file on the actual server,
no matter what folder it might be in.
So let me go and go back to my other tab.
Let me go ahead and cross my fingers as always and click reload.
And so far so good.
And in fact, just to prove to you that this is the new version of my HTML
that was pretty printed, let me go to View Page Source.
And there indeed it is, printed in the browser's memory
just as I wrote it on the server.
All right.
So now let's take a look at the code as we left it, whereby for the /route,
we are returning the return value of the render_template function once passed
an argument of index.html.
And let's see if we can't make our web application truly more dynamic
so that it's not just saying hello title, hello body all of the time,
but ideally saying hello to a particular person.
Now, how can I possibly pass user input to a web application?
Because my users on the internet certainly don't have
access to my keyboard, let alone my terminal window.
They only have access to my website via browser.
But of course, as we saw in the Google example,
if you were to pass in somehow at the end of the URL
not just a route but also a question mark and key equals value, maybe
an ampersand, key equals value, maybe another ampersand, key equals value,
we can somehow send from the browser to the server user input.
Of course, that user input ideally does not
come from the human typing it in manually to the URL,
but filling out a form, hitting Enter, and letting the browser
convert that form to the appropriate get request in the URL.
But let's start to simulate this for now.
Let me go back to this URL here, put my cursor at the end of it,
and say question mark name equals, for instance, David.
The intent being that I want this site to say hello David instead
of hello title and hello body.
Enter.
Unfortunately, when I hit Enter, nothing changes.
And I can confirm as much by viewing source,
and indeed, nothing about the page has changed because we
haven't done anything dynamic in code.
But I do think we can fix this.
Let me go back over to VS Code here and let
me propose that we go into the template first, which currently only says
hello title, hello body.
Let's go ahead and simplify the title for now
and focus on just dynamically changing the body.
And let me propose that what I really want this thing to say
is hello and then a placeholder.
So I don't want to literally say placeholder, where placeholder is just
something into which we plug in a value, because now I'm
going to see a website that says hello comma placeholder.
So the syntax you're about to see is a little bit different,
but it's going to be a technique via which
I can tell Python, specifically Flask, to substitute a value for this here
placeholder.
And the syntax for that when using Flask is
to do two curly braces on the left and two curly braces on the right.
It's a little different from our f strings or format strings in Python
alone, but in the context of an HTML template, the way you specify hey Flask,
substitute a value here, is indeed with two curly braces
on the left and the right.
Now, of course, nothing's going to happen yet until I go back to app.py
and actually tell the template somehow to plug in a value therein.
Now, how can I go about doing this?
Well, the simplest way, which is as follows.
In addition to importing Flask and render_template,
I'm also going to import another variable that comes with the Flask
framework called request.
And this is a special object that's going to give me access
to all of the HTTP parameters, the user input in the HTTP request
that's causing this code to be executed.
So how do I use that?
Well, let me go down here and let me create a variable called anything,
but I'll call it name.
And I'm going to go ahead and set that equal to something
like request.args, open bracket quote unquote name, close quote.
Now, what in the world is going on here?
Well, it turns out what we've introduced here now
is a special variable, request.args, that somehow magically automatically
stores all of those key value pairs.
And here again is why we're using a framework like Flask, because it's not
going to be particularly fund code to have
to write code that opens that virtual envelope, reads the HTTP message
inside of it, parses--
or that is analyzes and figures out what is each key, what
is each value, what route is requested.
Like, every website on the internet practically
is probably doing exactly that nowadays.
We might as well not reinvent that wheel ourselves.
So in request.args, we have this special variable
that comes with Flask that just gives us a Python dictionary that
contains all of those key value pairs.
And in fact, think back to week five when
I proposed that dictionaries or dics in Python
are so very useful because they allow you to associate keys with values,
keys with values.
That's what Flask is doing here.
So if I go back to my code, what we really see
is that I'm creating a variable called name
and I'm setting it equal to the value of the name key inside of this dictionary.
That is request.args is a Python dictionary at this point.
How now do I pass in the value of that variable to my template
so that we actually see hello comma David or hello comma someone else?
Well, in app.py, I have to pass now a second argument to render template.
And the convention for that is placeholder equals name.
In other words, I can use Python's feature
for named parameters, which we've seen before.
Like the print function in Python has that end parameter that we can use
to override the line ending, which is by default /n.
Here I'm passing in a positional parameter in Python, which just
means the first one, first position.
But then I'm passing in a second parameter that has an explicit name,
and the name I'm giving it is literally placeholder.
Why?
Because I want Flask to replace placeholder
in this template with the actual value of the name variable.
So if I go back to my second tab here, which previously
said hello title, hello body, but notice a moment ago
we passed in question mark name equals David, which was previously ignored.
Now if I reload this page, having changed my Python code in app.py,
there is my hello David and my tab is more simply now just hello.
All right.
Unfortunately, this is not the best solution.
Why?
Because suppose that a user doesn't visit this URL
and certainly doesn't have the wherewithal to type in manually question
mark name equals David.
Let me go ahead and delete that HTTP parameter, the key value pair.
Let me go ahead and reload this page now.
And now I got a bad request, a 400 error,
which means I did not request this website correctly.
Now that's just kind of bad design, because surely the user
should be able to visit the URL without having to manually type in parameters.
So how do we fix this?
Let me go back to my other tab for VS Code.
Let me go ahead and open up app.py.
It seems to be the case that I'm just blindly assuming on lines eight
and nine at the moment that there will be a key called name
inside of this dictionary, and clearly that's not the case.
If the user has not visited a URL that has question mark name equals something.
So I think we just want to use some week one style
logic using Python syntax specifically to say something like this.
Let me go ahead and change line eight to ask a question first.
If there is a name key inside of request.args,
then and only then go ahead and create a variable called name whose value
is request.args quote, unquote name.
Else, if there is no name key in that dictionary,
we've got to handle that situation, which I wasn't a moment ago.
All right, fine.
Let's create a name variable and set it equal to some default value like world.
And now line 12 can remain unchanged because no matter what,
I'm passing in a legitimate value for name that's either
whatever the human typed in the URL bar, for instance,
or it is, by default, world.
So if I go back now to my other tab and without changing the URL I just
click reload, now we're back to something correct, if underwhelming,
that says hello comma world.
Of course, this is a little maybe suboptimally designed in that, well,
I've used my placeholder already.
What if I want to say two placeholders or three placeholders or more?
I probably shouldn't be in the habit of literally
using the word placeholder in my template, even though that's what it is.
Let me go ahead and be a little more descriptive, just
like with our variable names in general.
And let me go ahead and say what I really want here
is hello comma name, where I want the value of name to be interpolated,
just like in an f string, inside of these double curly braces.
But I now need to change my code, because I've now changed my placeholder
to literally be name.
This is going to look a little weird, but the convention
in using this library is quite often to say now name equals name.
Why?
Because the name of the parameter I'm passing in to the left of the equal sign
must match the name of the parameter that I'm using in my template,
though the value that I want to pass in for that placeholder can be anything
I want.
It can literally be quote, unquote David.
But if the value is in a variable, then what I want to do
is pass in the name of that variable.
So this looks a little stupid, admittedly,
but this is the convention, for better or for worse.
Name equals name means plug in the value of the name
on the right for the template placeholder called name on the left.
That's all.
But this is indeed a common convention.
Now, is there a better way to do this?
Well, this feels a little bulky to have four lines of code,
if this, else that, just to check if an HTTP parameter was passed in.
And in fact, there is.
The convention in Flask would actually be to not bother with this explicit
if else but instead to do something like this.
Name equals request.args, and then specifically call
a method or a function called get, whose purpose in life
is to get the value of a key.
What key?
Well, the name key.
And what the get function also does for us is if it can't find a value there,
you can specify a default value.
So if you want the default value to be world,
you pass that in as a second argument.
So the behavior now is going to be no different,
but if I go back to my other tab and click reload,
nothing changes but it's still working.
It's not showing some error.
However, if I go into my URL bar at top and add slash question mark name equals
David, zoom out, and hit Enter, it's still working in that case as well.
But I've distilled those four lines of logic
now into something a little simpler by actually having now a use of the
get method, which is doing more of that logic for me.
All right.
So suffice it to say this too is not the best design, because you certainly
don't want to make a web application where your users to provide user input
have to manually edit the URL.
That would be like searching for Google by only
being able to edit the URL by adding slash search question mark q equals cats
any time you want to search for cats, let alone some other value.
And certainly if you want to type in your email address
or a credit card number or anything that we're
in the habit of typing into forms on the web,
you don't want to have to manually do that instead in the URL.
Which is to say, how can we make this now a more typical web application
that still takes user input but takes it via proper web form?
We saw how to make forms last week.
For instance, we made a front end for Google.
Let's now implement the back end thereof.
So let me go back over to VS Code here now
and let me propose that we will create an actual form in index.html.
So index.html's purpose in life is no longer
to be a template that says hello comma so-and-so.
All it's going to display is a template.
So let me go ahead and delete this line here
and let me delete this use of a placeholder,
and let me go into index.html and remove the body here
that we had for that placeholder.
And let's actually now in this here body create a web form.
So I'm going to do form, and then inside of the form tag
I'm going to create an input, and the name of that input
is going to be name, because I want the human's name.
And the type of that text--
the type of that input is going to be text,
even though that's the implied default.
But recall from last time, there's some nice features
I can enable anytime I make a form.
I can turn off autocomplete so it doesn't remember the previous person's
name.
I can autofocus that input so that the cursor is blinking and ready to go.
And so that the human knows what to do with it,
I can say placeholder equals quote, unquote
name so that there's little gray text that's explanatory text.
Now, notice there's some potential confusion here.
My use of name here is to define the name of the HTTP parameter
that I do want to end up in the URL.
The name here is the name of the HTML attribute that comes with the input tag
if you want to use it.
Placeholder here is another attribute that can be used with the input element.
So even though we're seeing lots of names and lots of placeholders,
they're the same idea, but they mean different things in different contexts.
Now we're looking at HTML alone.
All right?
Besides that input field, let me go ahead and create a button.
The type of this button is going to be submit so it knows to submit this form.
And I'm going to have that button say greet,
so it's obvious that I click on this button to greet that person's name.
All right.
What more do I need in here?
Well, this is just a form, which is fine visually,
but I haven't told the browser where to submit it just yet.
And if I don't specify that, it's actually
going to submit back to the same URL, for instance,
slash, if that's what's serving this up.
So if I actually want to change the action that the browser should really
take, there turns out there is indeed an action attribute which allows me
to specify where I'm submitting this.
And I'm not going to submit it to Google, for instance, this week.
I'm instead going to submit it to my very own route, which doesn't yet exist,
but it will in a moment, /greet.
And the method I want to use is going to be specifically
get in contrast with post, because I do want
to use get so that the parameters very visibly appear in the URL,
if only so that I can show you what's happening.
If I were to use post instead, recall that sort of hides the input still
in the envelope but more deeply inside of it
so it's not exposed in the URL, which is appropriate for anything personal.
Maybe an email address, maybe a credit card number, a password or the like.
But this is just a person's name, so I'm OK for now with revealing it in the URL.
All right.
Let's now go back to my other tab.
If I delete the URL parameters there and hit Enter and go back
to my default template, I see, indeed, a form asking for a name and a button
to greet someone.
So I'm going to type in my name, David, and I'm going to click greet.
And notice what happens to the URL at top.
It does automatically bring me to /greet?name=David.
So I, the human, did not need to type all of that in as I have been.
The browser knows when submitting a form via get, do that.
Unfortunately, I get a 404 not found.
Why?
Because my app.py file only has one route for slash.
There is no root yet for /greet.
So I think we can fix that too by just practicing what
I've been preaching here as follows.
Let's go into app.py and say app.route quote unquote "/greet."
And here too, I could call it anything I want,
but I want parity with what I just put in my form.
And inside of this, under this decorator, so to speak,
I now need to specify exactly what function I
want to be called when this route is visited.
I can call this function anything I want, but to keep myself sane,
I'm going to use a name for the function that kind of matches the route itself.
So I'm going to call this function greet,
even though it can be anything I want.
And then after this function, which is not going to take any arguments,
I'm going to go ahead and do this.
I'm going to say in here, name equals request.args.get quote, unquote name
to get the value of the name parameter from the get string.
But if there's no such value there, let's grab a default value of world.
And then as before, I'm going to return the return value of render_template.
But this time, I'm going to render a different template that, to be fair,
does not yet exist, but I can solve that problem too.
Greet.html.
And I'm going to pass into that template,
once it exists, the value of name equaling the value of that variable.
So same ideas as before, but I've now moved a lot of my logic
into a brand new function and route called greet.
All right.
So what's now going to happen here?
Well, let me go back to my browser, which previously was 404 not found
because the route didn't even exist.
I'm going to click reload and I'm going to see a new problem,
I think, because the route exists, but I don't think that template exists,
greet.html yet.
So let me hit reload.
And now I've got an internal server error,
which, welcome to web programming.
This is going to be the new segmentation fault of C,
but in the context of web programming.
When you see 500 internal server error, as much
as you might like to hope otherwise, it is your fault.
You have made a mistake somewhere, as I just did.
So let's see how to diagnose this.
Let me go back to my other tab.
Let me reopen my terminal window.
And thankfully, within my terminal window,
I should see, among any number of other errors, some hint as to what went wrong.
So to be clear, when you see a 500 error in your browser,
internal server error, one, it's your fault. But two, there's
probably diagnostically useful hints in your terminal window.
If you've created two terminal windows, that's fine.
You have to realize that your commands are going to be left alone.
You have to go back to your other terminal window
where flask run is still running and you might want to scroll up and down,
look at the most recent error in there, and hopefully you'll
see something useful.
And indeed, I do think I do.
Template not found, greet.html.
And that's pretty much hitting the nail on the head and telling me
exactly what there is wrong.
But interestingly, we haven't seen this word yet.
Jinja exceptions.
Exceptions, we've seen before.
You might recall that we can try to do something, but if an error happens,
an exception might indeed be raised.
Jinja, though, is a new term and this is just referring to another library
that anyone on the internet can use.
But the folks who invented Flask decided to adopt this other library themselves
called Jinja.
And what Jinja is is essentially a templating library.
Its purpose in life is just to handle everything inside of that template's
directory.
So if I go back to my own, index.html, it
is technically a library called Jinja that
is reading that template top to bottom, left to right,
looking for, among other things, pairs of curly braces
so that Jinja can do the substitution for you.
Now why is Flask using Jinja?
Well, Flask realized the folks who invented it,
we don't have to reinvent the wheel of templating
because some other people on the internet
already created a templating library called Jinja,
so we might as well use those in conjunction.
And this is going to be more and more common.
Even though when we started using libraries in C, they were very small
and well defined and only did one thing, once you get to web programming
and really software engineering in the real world,
you're going to be using multiple libraries, often
in conjunction with each other, some of which
are dependencies for other libraries.
So we're just seeing an example of that.
So this is to say ultimately this problem is still mine.
Internal server error means I messed up.
We know now from my terminal window that the template is not found.
So what's the solution?
Well, let's go ahead and create that template.
Well, let me go back into my terminal window, but not the one with the error,
but my other terminal window that gives me access to a working command prompt.
Let me go ahead and type code greet.html and hit Enter.
And just to make the point, let me pedantically type out this whole file
again.
So open bracket exclamation point DOCTYPE html.
Then below that, html lang equals en.
Then below that, let's put the head of this page.
Inside of that, let's put the title of this page.
We'll call it greet, just so I know which template is which.
Then let's put the body of the page here.
And then let's go ahead and do hello comma name,
using the same placeholder as before.
So in essence, my greet.html template is now
what my index.html template used to be before I deleted the latter
and replaced it with that interactive web form.
But now if I go back to app.py, we'll see
that greet.html, which is to be rendered, should now work as intended.
And I'm passing in name equals name so that I
can have that template use of this placeholder substituted
with the actual person's name.
All right.
Let's cross our fingers, go back to my other tab, and reload this page.
And there we have it.
Hello comma David.
Let's now go back to the code via which this current application is implemented
and consider what could be done better.
In fact, let me reopen my terminal window
and clear it temporarily and type in ls in my templates folder,
just to confirm that I do indeed have two files.
Let me do cd dot dot ls in my hello folder
just so that you can see what files are therein.
And in fact, what you see here now is a pretty representative structure
for a web application implemented in Python using the Flask framework.
Before long, we'll see one more folder in here.
Not just templates, but something called static, because up until now,
we haven't served up any images, any JavaScript files, any CSS files.
We can, and by convention, those such files
will be stored in another folder called static.
So indeed, what you're seeing here is the representative list of files
and/or folders that you typically need to create at some point
when building a Flask application.
But I dare say, even though we're following these conventions,
we haven't necessarily done things the best way.
Why?
Well, case in point, let me hide my terminal window
and open up again index.html.
Let me go ahead and open up greet.html.
And if I toggle back and forth between these,
you can clearly see that they're not changing all of that much.
There's a lot of commonality.
The DOCTYPE at the top, the html tag, the head tag, the title tag,
the body tag.
It's really only the contents inside of the latter, head, title,
and body, that are actually changing.
Moreover, let me point this out.
Let me go back to my user interface here.
Let me go back to my web form here.
And you'll see that I've zoomed in a few times, so everything's very visible.
But let me go ahead and open up this feature.
Let me go to right click or Control-click on my viewport.
Let me click Inspect to open the developer
tools that we talked about last time.
And notice that I can actually click this button here
at top left, which is a useful toggle for changing the type of device you're
visiting a website on.
So for instance, if I type this now, what you'll see,
if I shrink my developer tools, you'll see a mobile version of this web page.
So what that button does in Chrome at least--
and other browsers have similar features--
you see what this web page would look like on a mobile device.
And suffice it to say, I can barely tell what's on the page.
The default font is clearly way too small, and at least on my phone,
there really is no easy way to zoom, zoom, zoom.
You can tinker with the settings, but you
don't want your users having to zoom in just to use your website.
Which is to say that my website, as implemented now,
is not responsive to the type of device that's visiting it.
It is not mobile friendly.
Now, there's many different ways to address this, including using libraries,
but minimally a solution to this problem typically
is to go in and add an additional tag to the head of your web pages.
So let me go back to index.html.
Let me go into the head here.
This is a bit of a mouthful, but I'm going
to use a tag called meta, which refers to metadata.
I'm going to give it an attribute called name and set that equal to viewport.
Why?
I'm just following the documentation.
Then I'm going to specify that the content of this meta--
of the content for this meta tag is going to be cryptically initial-scale
equals 1 comma width equals device-width.
This is a mouthful, and technically I'm reading it off of a sheet
of paper because I can never remember exactly what to type here.
But this tag alone will make my application,
and my website more generally, more mobile friendly.
It's not going to fix all of my potential problems,
but it is going to tell the browser in particular that it should
size things to the specific device width, be it an iPhone,
an Android device, an iPad, a tablet of some sort, or the like.
And case in point, if I now go back to my other tab, which
is still in my mobile view mode, let me click reload now.
And notice, even though there's the tiniest of forms
up there in the top corner, when I reload now,
now it's at least more usable.
It's still relatively small, but it's at least readable at this point.
So that one meta tag alone goes a long way
to making your website responsive in the sense
that things are going to be resized automatically by the browser based
on the device's type.
I mentioned that only because it's going to lead to another design opportunity.
Let me close my developer tools.
Let me go back to VS Code here.
And you know what?
My greet template still doesn't have that mobile friendly tag, so, all right,
fine.
Let me just save myself some keystrokes.
Let me highlight this whole line six.
Let me go into greet, into its head, paste that there.
And OK, now I could argue that I've solved this problem on this page too.
But where are we going with this?
Well, most any time in CS50 when I've copied and pasted something,
it's almost always been the wrong solution to a problem.
It suggests a poor design because why Copy-Paste
if I can somehow factor out commonalities?
And indeed, this is the point now to be made.
If we toggle back and forth between these two files,
index.html and greet.html, there is so much commonality.
I dare say now, all of this is common from line one
through part of line seven.
All of this is common from line 15 down through line 17.
Wouldn't it be nice if in HTML, we can somehow factor out that code too?
And here is where templates start to get very powerful, because the answer is
indeed yes.
We can actually factor out all of those common lines of HTML in such a way
that we don't need to type them again and again.
So now let me propose that we'll create one more file,
even though this will allow us to make these two files simpler, as follows.
I'm going to go into my terminal window where I have a command prompt.
I'm going to cd back into my templates folder
and I'm going to create a new file called
layout.html, which is a file name you need to adhere to when using Flask
because that's the default name.
All lowercase, one word.
Layout.html.
Enter.
I've now got a new tab.
I'll close my terminal window.
And for the last time, hopefully, I'm going to type out DOCTYPE html.
Then I'm going to do html lang equals quote, unquote en.
Then inside of that I'm going to have the head of my page, inside of which I'm
going to have the title of my page.
And because this application doesn't really
need to change that much, I'm just going to say
the title for every page in this application is hello.
But we could parameterize that if I wanted.
I'm also, though, going to add that meta tag.
So meta name equals quote, unquote viewport.
Content equals quote, unquote initial-scale
equals 1 comma width equals device-width, close quote,
close bracket.
And then I'm going to have the body of my page.
But here is where the website really varied by template.
In index.html, it was a form.
But in greet.html, it was hello so-and-so.
So what I really want is a whole block of content potentially to go in here.
So in fact, what I'm going to do inside of the body
is use some weird looking syntax.
This is more Jinja syntax.
And I'm going to say this.
Open curly brace, percent sign, block body, close percent, close curly brace.
And then with nothing in between there, I'm
again going to go open curly brace, percent sign.
And this time I'm going to say endblock.
One word, no space.
Percent sign, close curly brace.
So this is weird syntax.
You'll have to look it up to remember it over time.
But this is the way to specify to Flask, plug in the contents of another template
here.
Not just a variable's value, but another file should go here.
You can call this anything you want.
I could call this foo or bar or baz, which are
the go-to terms in computer science.
But I'm going to call it body only because, one,
I only have one such placeholder for now.
And it's in my body, so let's just say this
is the placeholder for the body of this web page.
Keep it simple.
So now, what can I do in my other files?
Now that I have that template here, I can go back to, for instance,
my index.html, and I can delete all of this and I can delete all of this.
So now in index.html is literally only the form
that is going to vary for this particular page,
though I now need to tell Flask how to embed this snippet into my full layout.
And the way to do that is as follows.
At the top of your template, open curly brace, percent sign,
extends, as a verb, quote, unquote layout.html.
And this is a line of saying-- this is a way of saying in Flask,
please extend layout.html with the contents of this file.
I do need to do one more thing.
I need to define the block of code that I want Flask to substitute for me.
And so here too, I'm going to say block body, just like I did a moment ago.
And then in here, I'm going to-- below this, I'm going to say endblock.
And it's weird.
This is a Jinja thing.
It's block space body up here, but it's just endblock down here.
The word E-N-D is prepended to the name of this Jinja tag.
Just to be a little nitpicky, I'm going to go ahead and indent this properly
so it's only indented once there.
And that's it.
And admittedly, this looks a little weird, but what's important
is that now I've only implemented in this file
the minimum amount of HTML that differs for this particular route.
What am I going to do in greet.html?
Well, I'm going to delete all of this up here,
and I'm going to delete all of this down here.
At the top of this file I'm again going to say extends quote,
unquote layout.html, close quote, and then another percent sign
and close curly brace.
Below that, I'm going to say block body, percent sign, close curly.
And then down here, I'm going to say as before endblock and close that tag.
I'm going to fix the indentation here just to be consistent.
And now I have a second block that will be plugged in when greet.html is used.
So again, these files now differ only in terms of the contents of that block.
So if I toggle back and forth here, you'll see that--
let me add spacing just for consistency here.
Index.html has the form.
Greet.html has the hello and the placeholder for name.
All right.
After all of that work, let me go back to app.py, and surprise.
Don't need to change anything.
Because I'm using the render_template function,
it knows not only how to handle those curly braces with variables
as placeholders, it also understands curly
brace percent signs, percent signs curly brace,
as per the documentation for Jinja itself.
So in fact, what I'm going to go ahead and do now is go back to my web page
without changing anything in app.py.
Just for good measure, I'll reload this page here.
Wasn't expecting this to happen, but I've clearly induced a problem.
I'm now getting one of these 500 internal server error.
So how do I diagnose this?
Well, a good programmer would know to go back to their terminal window,
go specifically to the one that's running Flask.
And here we have another Jinja exception, template syntax error.
Expected token end of statement block, got string.
Now where is that?
Let's go back into my layout.html.
And this looks correct.
Let me go back into index.html.
Ah.
Super subtle.
I did something dumb.
Can anyone spot the mistake before I reveal?
Anyone see it?
Very subtle.
And I think, yes, we have someone pointing it out.
I stupidly forgot my double quotes.
So that's all.
And that's why it was seeing a string or a str instead of the tags,
as it expected.
So subtle, and I was holding my breath that I was actually
going to be able to solve that in front of everyone.
But the solution was clearly-- or the hint to the solution
was clearly in my terminal window.
So now let's hide my terminal window, go back to my other tab, cross my fingers,
which maybe I forgot to do before which is the problem.
Reload.
There we go.
Index.html is working, and if I type in my name and hit Enter or click Greet,
now the whole thing is working again.
But more importantly, if I View Page Source,
notice that I indeed see that the same template has been used,
the same blueprint, if you will, for this page,
as well as, if we go look at the other, all of this stuff
is common to these files.
Now as an aside, once you're in the browser viewing
the output from the server, it's OK if not everything
is pretty printed perfectly.
What matters when it comes to style with web programming,
as with programming in general, is what you and other developers
see on the server.
The browser is perfectly OK with there being less or more whitespace
just because it was all dynamically generated.
But indeed, if I go back now not just to hello, not just to my greet route,
but this one and View Page Source, you'll
see that what's been generated by the server
is indeed almost the same up until a point.
All right.
So up until now, we've only been using HTTP
get requests, whereby any user input, whether it's from the form
or manually typed in, is indeed being sent from browser to server
via the URL itself.
But it turns out there are other methods that we can use besides get.
Recall that there's also post.
And post treats your data little more privately in the sense
that it still kind of puts it into that virtual envelope,
but it shoves it down deeper such that it doesn't appear in the user's URL bar.
This, of course, is compelling if it's a password, credit card, or anything
personal or private.
So how can we switch our own application, for instance,
from using get to using post instead?
Well, let me propose that we go back first to index.html,
because it's in index.html that we explicitly
specified a method of get before.
So it's very easy in HTML to change the method
that this form is going to use from get to post.
Now weirdly, again, in HTML you should lowercase get and post
even though when you see them inside the actual virtual envelope
or in your developer tools, it's capital,
it's an uppercase GET and an uppercase POST.
But that said, let's go ahead and see what
happens when I make that simple change from get to post in my form alone.
Because I've changed my HTML, I'm going to reload the page just
to make sure I have the latest HTML in my browser's memory.
I'm going to type my name as before and I'm going to click Greet.
And notice this time that the URL is not going to display name
equals David, because I've switched from get to post.
Enter.
But even though I'm ending up at /greet and I'm not seeing question mark name
equals David.
The method is not allowed.
This is a weird 405 error.
Now why is that?
Well, it turns out if I go into app.py, by default,
when you create a route using Flask as in line 6 or in line 11, by default,
only get is going to be supported.
But if you read the documentation or follow along here,
you can tell Flask what additional methods, if any, to actually support.
So in fact, if I want this greet method to actually support not
get, but instead post, what I can do is pass in a second argument, a named
parameter, and say methods equals, and then
pass in a Python list of methods that I want to support.
If I only want to support post, I can literally just do quote, unquote post.
If I want to support get and post, I can do both as a comma separated list
inside of this Python list.
Because again, from week six, recall that square brackets imply
that this is indeed a Python list.
But for now, I'm fine with just supporting post.
And so I just pass in, as the value of methods, a list with one value quote,
unquote POST in all caps.
All right.
Let's now go back to my browser tab.
Let's go back to the form.
Let me type in my name again, crossing my fingers, and greet.
And now, ugh, so close.
The error is gone, but it's not greeting me.
It's using that default value, hello comma world.
Now, this makes sense at a glance because clearly there's
no parameter being passed into the URL.
But my code, it turns out, was assuming that if there were a parameter
it would come in via get, not via post.
And this is among the weirder design decisions in Flask.
But whereas get parameters are stored in request.args, as we saw,
a dictionary that gives you all of those key value
pairs from the URL, post requests' key value pairs
are stored in Flask using request.form.
So it makes sense that they come from the form,
but it's a little ambiguous at least to me why we say args here and form here.
You just kind of have to memorize it or look it up.
Request.args is for get.
Request.form is for post.
The implication then is if I go back to VS Code here,
it's a pretty simple change.
I just have to change request.args to request.form
so I look in the right place for that key value pair.
Let me go back to my other browser tab, click reload.
Noticing that, the browser is now going to caution me,
are you sure you want to resubmit this form?
And that's useful because you don't want to accidentally pay
for something twice on a website by submitting your credit card twice.
You don't want to type in your password maybe more times than needed.
And so in this-- or send your password more times than needed.
So the browser is cautioning me, because I'm using post underneath the hood,
do I actually want to resubmit this form?
So yes, in this case.
So I'm going to click Continue.
And now I do see hello comma David, because it's
been passed in underneath the hood, if you
will, inside more deeply that envelope.
And we can actually see this.
Let's do one other thing here.
Let me go back to the form.
Let me right click or Control-click on my viewport
and click Inspect to open up the developer tools.
Let me go under Network here, and let's go ahead and do this.
Let me go ahead and type in my name and then click Greet.
And like last week when we were poking around all of the HTTP requests
going back and forth from browser to server,
let's see what the browser is actually sending.
When I click Greet, I indeed see that the URL at the top changed to /greet,
but there's no mention of David or name.
But if I go down here into my developer tools and click on that HTTP request
in my log, I can now scroll down and see, ah,
the request method was apparently post.
And if I scroll down further, I'll see not only the response,
but if I keep going, I'll also see the request headers, which are sent inside
of that envelope as well.
But what I really care about in this case is payload.
If I click on payload, this is a term of art
that means what inputs are you sending from browser to server.
You'll see a list here of all of the form data, name colon David.
So you can actually see in your browser's developer
tools exactly what was sent.
And you can do this on any website.
The next time you log in to a website, buy something online,
you can poke around the Network tab of your developer tools
and see all of the key value pairs.
And frankly, you're going to probably see many more values
than you might have expected because browsers, of course,
have lots and lots of features.
More than we're implementing in these simple examples,
but it's just key value pairs again and again.
All right.
So we've solved a bunch of problems now.
In fact, we've even added a layer of privacy,
if you will, insofar as the data is still being sent, yes.
But it's not showing up in the URL, which
means it's not going to end up in my autocomplete, which means it's not going
to end up in my history in the same way, which is indeed great for anything
private, like credit cards or the like.
But what more can we do here?
Well, as we've often done in the past, let
me see if we can tighten up our code a little bit.
For instance, could we use a single route
and still implement the same application?
Now, this might not be desirable, so consider this
an example of how you could collapse some of your code into fewer lines.
But this isn't necessarily to say it's the right way or the only way
to do things.
But I do think it's compelling in some cases.
As you'll see, for instance, in the problem
set for this coming week, wherein we adopt a similar paradigm
to try to keep the code a little bit simpler.
So let me go back into app.py and let me propose to do this.
Let's just have one route slash that does
everything, including presenting the form
and also displaying hello so-and-so.
But let's support both get and post for this route.
So I'm going to say methods equals, and then in a Python list quote,
unquote GET comma quote, unquote POST, overriding the default, which,
again, is just get.
Then inside of this function, what I'm going to do is this.
If request.method equals equals POST, then let's do this.
Else, let's do this.
In other words, if the request coming in happens to be post--
and this is just another special variable inside of the request object
which we imported earlier.
Turns out there's another variable, if you will, called method,
and you can check what is the method that came from the browser.
Is it get, is it post, is it something else too?
And if it is, let's go ahead and do this.
Else if it's not, it's presumably get, so let's just render
the default template.
So what can I now do?
I can grab this code from greet and delete it.
Let me delete the greet function entirely.
And I think what I can do is just move all of this functionality in here.
Let me fix my indentation.
But now, if the request method is post, then I'm
going to do exactly what we did before.
Else, I'm going to display the form to the user.
So what more do I need to change?
Let me go back to my index.html, wherein previously I had an action value
of /greet.
But this is no longer applicable.
There is no more greet route.
I just want to submit to slash.
And frankly, at this point, I can also just get rid of action
altogether because the browser, by default, will assume,
you want to submit to the same URL from whence you came.
But to be explicit, I'll go ahead and leave it for now.
Let me go back now to my browser tab and go back.
Let me reload to get the very latest of everything.
Let me go ahead and type in David.
And watch now that the URL does not, in fact, change to /greet.
But I am, in fact, greeted.
There's no /greet anymore, but it was, in fact,
sent from browser to server using post and my web application now,
using just a single route, is handling both methods now in this case.
All right?
So we've tightened things up, which might be useful for larger web
applications wherein we might want to not have as many functions
and complexity in our app.py.
But what more can we now do?
Well, it turns out Jinja, the templating library that Flask uses,
has its own documentation page.
And frankly, it's super long, but there's
some fairly simple features documented therein, and I'll show us at least one
of them here.
So in Jinja, thus far, it allows us to place values inside
of those curly braces.
It also allows us to do that block feature, which is really
templating by definition, to grab the contents of layout.html and plug
in this particular templates block of code.
But we can do other things, conditionally, even, in Jinja as well.
So for instance, suppose I want an app.py to just get rid of this logic
whereby I am not only getting the form from--
the value from the form, I'm also passing in a default value in app.py.
Suppose that I want to relegate these default values to the templates,
because after all, if the templates are what the humans actually see,
it's pretty reasonable, then, for whoever's creating the templates,
put the default values closest to the user in those templates.
So this is to say, let me just get rid of this default value for name of quote,
unquote world.
And just no matter what is in the form, go ahead and just
pass it into the template.
And frankly, as before, we don't strictly need this variable at all.
I can get rid of this whole line nine and just replace name equals
and then the return value of request.form.get
quote, unquote name in order to get that value.
Same thing, just getting rid of a variable, if nothing else.
But I have gotten rid of two, the default value, quote, unquote world.
How can I restore that?
Well, here's what's cool about Jinja and templating techniques in general
with web programming.
If I go back to greet.html, I don't want to just blindly say hello comma name,
because name might be blank.
It might not have an actual value.
But it turns out that's OK.
What I'm going to do here is the following.
Instead of just saying hello, I'm going to go ahead and say
hello comma, and then, if there is a name value, then let's go ahead
and spit it out inside of these double curly braces.
Else if there is no name value, then let's go ahead
and spit out the word world.
And then, as before, use end and the same name as the first tag, endif.
So we haven't seen the syntax yet, but it's clearly similar in spirit
to the block syntax.
And this is Jinja's syntax for doing something conditionally.
If name has a value that's not empty, like quote, unquote,
then go ahead and just display the name right here.
Else if it is a blank value or absent altogether,
go ahead and spit out world instead.
And that's it for the if conditional.
Now, notice I've used several lines of code here, which seems weird
because I don't want it to say hello comma
and then the person's name on the next line.
But remember how HTML works.
It's going to ignore anything more than a single whitespace.
So even though the name or the word world are on different lines,
all of that whitespace is going to get collapsed into a single space
visually for the user in the browser.
So if I did this right, let's go back over to my tab here and let's go ahead
and hit reload on the page itself by clicking on the URL and hitting Enter.
I didn't want to hit Command-R or Control-R because I
don't want to resubmit the form.
I want to reload the page, and the best way to do that would be,
indeed, to just go ahead and click on the URL and hit Enter.
Let me go ahead and type my name in and click Greet, and hopefully--
there I am again.
Hello comma David.
If I view page source here, notice you see the template,
and you even see that my name is on a new line
because that's where it was in the conditional.
But the browser doesn't care.
It's consolidating all of that multiple whitespace into a single whitespace
instead.
So that's a lot of examples just to say hello world.
But the overarching goal here thus far has
been to implement, really, the simplest of web applications
that takes user input, produces dynamically HTML
that corresponds to that input, effectively implementing
our very first back end.
Of course, all of these examples thus far really just say hello world
to the user.
So let's go ahead, though, take a break, and when we come back in, say--
let's say five minutes, we will see how you could implement your very
own website for a freshman intramural sports program,
just as I did, like, 25 years ago by teaching myself web
programming after having taken CS50.
Unfortunately, the internet back in the late '90s looked quite like this.
I don't know to this day why I used a repeating background image,
but that's what the web looked like.
But we'll see ultimately how you can implement something like this
when we return in five minutes.
See you soon.
All right.
We are back.
So back in 1997, the way that Harvard undergraduates
would register for freshman intramural sports, otherwise known as Frosh IMs,
was they would pick up a piece of paper.
They would write down their name on it.
They would check off a box for any of the sports
that they wanted to participate in.
And then they would walk across Harvard Yard,
open up one of the dormitory doors, and slide the sheet of paper
under the door of what's known as a proctor, a resident advisor who
was running the sports that year.
Suffice it to say there was an opportunity to move all of this online,
even though the internet itself was still rather in its infancy,
or at least as we now know it.
However, I had already taken CS50 in fall of 1996.
This was probably the spring or fall thereafter.
And I decided, even though CS50 at the time
didn't even introduce people to web programming,
I actually tried to learn a bit of it on my own,
and I undoubtedly did not do things very well, and certainly not the best way
possible.
But at the time, I taught myself a language called Perl, which
was very popular for web programming.
Nowadays we have languages like Python and PHP and Java and Ruby and JavaScript
and many others as well.
But the point is that even after just CS50 and maybe one other programming
course, you really should have this solid foundation via which
to teach yourself new languages, much like the trajectory
we've had you on from Scratch to C to Python to SQL to JavaScript,
and now bringing it all together in the context of web programming.
So let's, without the ugliness, recreate a little bit
of what I built way back when to allow students
to register for frosh IMs via web browser instead of a piece of paper.
Let me flip over here to VS Code, where, in advance of this demonstration,
I prepared a few files based on the hello demos from before.
In particular, in a frosh IMs directory, which I created anew,
I have the following files already.
App.py, requirements.txt, and templates.
And inside of templates, I have index.html and layout.html.
And let me go ahead and hide my terminal window.
You can see in the latter the following layout, which
is identical to what we used a moment ago for our hello examples,
but I've changed the title from hello to froshims.
The index template, meanwhile, extends that layout or equivalently
inherits from that layout.
But I haven't put any body inside of this block here.
I deleted what we had before just so I don't have
to type as much to get us started now.
And then in app.py, similarly, I copied the first couple of lines of code
but deleted all of my routes just so that I, again, don't
have to type all of those from scratch.
But let's go ahead now and implement the simplest of registration forms
for some number of sports.
And what I'm going to do is the following.
I'm going to go over to my index.html, which,
again, extends already layout.html.
And let's begin to put together a registration form.
I want this page to very clearly be about registration.
So I'm going to use an h1 tag and I'll say register, for instance.
And then below that I'm going to have the start of a form tag,
the action of which I could make anything, including slash itself.
But let's keep things clear and let's have the action be /register for this
one.
And the method for this one will be quote, unquote post.
Inside of this form tag, notice now I'm going to have an input.
I'm going to turn off autocomplete, as before.
I'm going to turn on autofocus for that input.
And I'm going to specify that the name of this input
is itself name, because this is going to be for the students' name who's
registering.
The placeholder value I'm going to use is capitalized name
to make clear in gray text what they should type in.
And the type of this, just to be explicit,
is indeed going to be a text box.
Now I'm going to introduce another form element
that you see all over the place on the web,
even if we haven't necessarily had occasion to use it ourselves.
I'm going to have a select menu, which is equivalent to a dropdown
menu in a browser.
And the name for this menu is going to be sport,
because I want this dropdown menu to be a list of sports
that the student can select.
Inside of that, let's come up with three sports for now.
Option value equals basketball.
And then inside of the open tag and close tag for option,
I'm going to just repeat myself.
Basketball.
Then below that I'm going to have another option
whose value is going to be soccer, American football in this case.
Then I'm going to type soccer inside of the open tag and close tag.
And then the third and final option will have a value
of quote, unquote ultimate frisbee.
And then inside of that open and close tag, I'll say again ultimate frisbee.
So this clearly evinces some redundancy.
However, what this reveals is that with a select menu, much like with links,
with the anchor tag, you can have the human see one thing,
but the value actually used is another.
Even though for simplicity, I'm keeping them exactly the same.
Now let me go ahead and go into my other tab, which, up until now,
has been saying hello David and hello world.
But I haven't stopped running Flask.
And so if I keep doing this and reload, if I keep visiting this URL,
I'm going to keep seeing that form.
And if I type in David, I'm going to click Greet, because my previous web
application is still running.
So I can't just start making a new web application
and expect that this browser tab is going to work,
even though it's still port 5000.
Let me go back to VS Code, open my terminal window,
go to my very first terminal, wherein we see all of the logs from Flask
that have been running.
And in fact, among the error messages there
is actually some diagnostically useful output sometimes.
What Flask is showing you in this terminal window,
even though I've hidden it most of the time,
is a log that is a recording of all of the get requests
and all of the post requests that came from a browser to the server.
And you're seeing dates and times, the IP address and so forth, some of which
is going to be not very useful in this environment
because we're using a codespace instead of putting
this website on the actual web publicly.
Everything is private now to me, but there is some diagnostically useful
information there.
For instance, this get request at the top returned a status code of 200,
as did every post and get below that.
But this, too, is, again, where we'll see any errors.
And if we start introducing SQL before long,
we'll even see copies of our SQL queries so that we
can diagnose any problems in those.
But this is all to say that I don't want Flask to be running in my hello folder
anymore, so I'm going to hit Control-C to interrupt that.
I'm going to hit cd to get back to my default folder.
I'm going to type cd froshims now, which my other terminal was already in.
And indeed, if I type ls in here, I see those same files.
But now I'll clear my terminal, and I'm going
to rerun flask run in my froshims folder.
Turns out that's going to open up the same port 5000 by default. So in fact,
I can just directly go back to this tab, which previously was my hello app.
And just by reloading that URL, Enter, now I see, huh, not found.
404.
So I've clearly broken something.
But why is that?
Well, I don't have any routes in this froshims application
yet because I started almost from scratch.
So let me go ahead and close my terminal window for now and go back to app.py,
and let's just start serving up that default template quite simply.
Let's do app.route as before, quote, unquote slash.
Let's create a function as before called index,
though we could call it technically anything we want.
And let's have this function do very little.
Let's just return render_template passing in index.html.
Now for this new web application, that /route exists.
Which means if I go back to my other tab,
hopefully it will be found when I click reload.
And sure enough, there is my registration form with a name field,
and the cursor is autofocused inside of it with the cursor blinking.
And there is my select menu.
Indeed, if I click on it, I see basketball, soccer,
and ultimate frisbee.
So this form doesn't really do anything yet,
and frankly, I'm not sure I love the fact
that basketball is the implied sport.
It would be nice to maybe see a default value or a blank value.
That's just an aesthetic detail.
If I go back to VS Code here, go back into index,
there's a few ways I could fix this.
I could do, for instance, option value equals quote, unquote maybe nothing,
because it's a default value.
And I could just say something like sport
to be sort of a title for that dropdown.
Let me go back to my browser, reload.
And yeah, sure enough, I now have sports as the top option.
But this is a little weird because I don't want the user
to be able to register for sport.
I don't really want it to be a selectable option.
So it turns out there's some other attributes
we can play with in this context.
And in fact, if we want to display a title like that, sport,
we can actually specify that the option itself is disabled.
But it is selected by default. So these are two other HTML attributes that you
can use with the option tag in HTML.
They don't need values, so they don't need equal signs or quote marks.
You can just say disabled and selected.
But now when I go back to this tab and reload once more,
notice that it indeed still says sport, but it's grayed out.
So I can't actually submit that value.
I can only choose from these three things here.
And using libraries like bootstrap for CSS,
you can style these things even more beautifully than this,
but this is perhaps the simplest way to at least have
a title for that there select menu.
All right.
I need one more thing in this form.
Let me, below my select menu here, let's do a button, the type of which
is submit.
And then that's going to be a register button now instead of greet.
So if now I go back here and reload one more time,
now I have the name, the sport dropdown, and the registration button as well.
But we're not yet in a position to do anything with that information
until I think we implement another route.
So let me go back to VS Code.
Let me open up app.py.
And in addition to my index route, which is just serving up that web page,
let's create another route, app.route, quote, unquote register.
This one, just for privacy reasons, is going to use post instead of get.
So I'm going to say, quote, unquote post inside of a Python list there.
Let's define another function called register.
Though again, it can be anything I want, but I like to name them exactly the same
as the routes themselves to keep things straightforward.
And then let's go ahead and do this.
Let's go ahead and check whether the user has registered or not,
and then tell them whether we're successful or there's a failure.
So for now, let's actually--
well, let's do this.
How about we return this to keep it simple?
Return render_template, and let's pretend like a template
exists for success.html.
This suggests that I should probably have a template called success dot HTML,
so let's whip one up really quickly.
And in success.html, let me do this.
First, let me open my terminal and get to a prompt so I can type code.
Actually, first, cd templates to make sure it's in the right place.
Then code, success.html.
In this file, I do need a bit of boilerplate.
So extends quote, unquote layout.html, with the close quote this time.
Then block body over here.
Then I'll do an end bloody body.
Oh, so close.
Block body.
Then let's endblock down here.
And inside of here, let's just say something successful
like you are registered.
Well, not really, because we haven't actually done the hard part yet.
Let me go back now to app.py just to confirm that,
OK, when this route is called, no matter what for the moment,
we will render success.html.
So let's try it.
Let's go back to the browser here, type in David.
Let's choose, say, basketball for the sport, and click Register.
And ugh, internal server error 500, which we know is my fault.
So let's go back to VS Code.
Let us open up my terminal window.
Let's go to the first one that's running flask run.
And ugh, I did it again somehow.
A template syntax error, unexpected curly brace.
All right, well, where could that be?
I did it again, but this time with a different character.
OK.
So I was so focused on adding the double quote, I did not add,
in fact, the curly.
I was so focused on adding the double quote,
I did not add the second percent sign.
So now let's go back to my internal server error.
Click reload.
Resubmit the form that I just submitted.
And now I'm told you are registered.
Well, not really.
That's because the route's not doing anything intellectually interesting yet.
It's just rendering that template blindly.
All right, well, let's improve upon that.
I think what we should require is that to register for a sport,
the student should have to provide a name and have to provide a sport.
Unfortunately, that is not a current requirement.
For instance, if I go back to the form and I don't type in a name
and I don't type in a sport and click Register,
I'm still told you are registered.
To be fair, I'm told, well, not really.
So let's make clear that this is a bug.
Let's get rid of the parenthetical.
Let's go back to the form.
Let's not type a name.
Let's not choose a sport and click Register.
Now it's clearly buggy because I am not in fact registered.
I've done nothing with this information.
All right.
Let's go back to VS Code here.
Let's go back to app.py.
And let's express this idea of if there's not a name
or there's not a sport, it is a failure.
Do not let the user register.
So let's try this.
We can express this in a few different ways in Python.
I'm going to propose to do it like this.
If there is not a value for request.form.get quote, unquote name,
or there is not a value for request.form.get quote, unquote sport,
then go ahead and return render_template quote, unquote failure.html.
Else if there is a value for name and for sport, great.
Let's go ahead and render template success.html.
Now I can tighten this up slightly.
Strictly speaking, if I'm conditionally returning a template in line 14,
I don't really need the else.
So just to type this out, I'm going to remove that altogether.
But this is just the same kind of logic we could have done in C or in Python
before we introduced Flask or in JavaScript.
This is equivalent to an if else because returning, of course,
immediately returns from this register function,
so you don't strictly need the else.
I'm doing this just to tighten up the code, but it's not logically necessary.
Of course, failure.html does not yet exist, so
let me save a couple of keystrokes here.
Let me copy the contents of success.html.
Let me go into my terminal, create another file called failure.html.
I'm going to go ahead, just to save a moment in class
to Copy-Paste that there.
But I'm going to say in this template, you are not registered.
Now, granted, I'm copying and pasting, which almost always is a bad thing.
But when it comes to using templates in Flask using Jinja here you,
do still need lines one, three, and seven to make this work.
So those are necessarily Copy-Pasteable or retypeable.
But now I think we have two scenarios.
Let me now go back to the form.
Let me go ahead and type in my name and choose my sport and click Register,
and we're still good.
We haven't done anything with the data, but at least the human cooperated.
But if I go back now, reload the page, don't type a name, don't choose a sport,
and click Register.
Aha.
Now we're at least telling the user they are not registered.
All right, so we're making progress.
We are conditionally checking whether or not the user has actually
registered for a sport.
Let's now make sure that they can't really
hack us or do something malicious, because right now,
if they type in their name and they type in a sport, we will register them,
or as we say.
But recall that anything client side isn't necessarily robust.
In fact, let me go back to index.html and let me actually do this.
Let me add the required attribute here and let
me add the required attribute here.
You don't need to give it a value within an equal sign and quote unquote.
Let me go back to my browser and click reload.
And now let me try to click on Register without giving a name or a sport.
Unfortunately, the browser prevents me-- or fortunately, the browser prevents me.
So let me type in David.
Let me not choose a sport.
Register.
OK.
So we seem to have error checking now, preventing the human from submitting
this form without valid data.
But not quite, because indeed, all of this is happening client side.
If I View Source in my browser, I can see the required attribute
at the end of the input tag and at the end of the select tag here.
But recall that this is my copy of that HTML.
And if I want to be malicious, I could Control-click or Command-click
on my viewport and choose Inspect to open my developer tools.
Recall from last time, I can look at the elements of this page
pretty printed like this.
And notice here-- let me shrink the CSS part of this window.
Notice that I can actually edit this HTML if I want.
For instance, I can click on required, click Delete, and then save it.
And now the required attribute is gone.
I can do the same here on the select field and get rid of that,
and now it's gone.
And now I can type in David, but I can, for instance, skip the sport
and click Register.
And it doesn't stop me anymore from doing that because I've
disabled client side validation.
Moreover, things can get even more malicious.
Suppose that in a protest vote I don't want
to register for basketball or American football, a.k.a. soccer, or Frisbee.
Like, I want to register for actual football.
So in the European sense, for instance.
So let me go into my attributes here.
Let me change the value of soccer to football.
Let me change what the user sees from soccer to football.
And now let me go ahead and save that.
Now, let me confirm that I've still got my name.
But notice now I can register for football instead of soccer,
click register, and now I'm registered for a sport that at least semantically
is not even supported in the web application itself.
And frankly, by that logic, I could have registered for any sport
that I happen to type in into the web page's HTML.
Which is to say we need server side validation.
It is fine to use client side validation as
by adding the required attribute in places
if you just want to give the user immediate feedback
and prevent good users from doing something incorrect or foolishly.
You can't prevent the adversaries, the malicious users
from messing around with your form using client side techniques alone.
So let's go into VS Code again and let's this time open up app.py.
And in app.py, let's go ahead and make a canonical global variable containing
all of the sports that are officially offered this semester.
So let me create a variable.
And I'll call it sports in all caps.
Even though Python does not have constants, per se,
still conventional to capitalize the variable, just to make clear that you
shouldn't change this and it's global.
Let me go ahead and set this equal to the following Python list.
This list is going to contain basketball, quote, unquote, soccer,
quote, unquote, and ultimate frisbee here as well.
It's often conventional to have a trailing comma
even after the last element, just to make it easier
to Copy-Paste and reorder things and code,
even though logically it's not, in fact, necessary.
What am I going to go ahead and do next now?
Well, if I have now this variable containing all of these sports,
I don't actually need to hard code them into my template.
So I'm actually going to do this.
Let me pass in a placeholder called sports into this index template
and set it equal to that global variable's value.
And now in index.html, let me go ahead and, instead
of enumerating all of these sports manually,
let's use another feature of Jinja, which
is going to make our life easier and much more dynamic,
whereby I can use a Jinja for loop instead.
So let me go into my select tag here below that disabled option.
Let me use open curly brace percent sign for sports in sports.
So notice this is Jinja syntax, per the curly brace and per the percent signs.
But it's very Python-like.
It's very similar to the exact syntax you would use in Python,
but there's no colon, and strictly speaking, we're inside of the template
here.
Below that, let me just proactively say endfor.
And it's a little weird, but again, this is how Jinja does things.
You end the name of the Jinja tag that you began per its documentation to.
And then inside of this loop, let's just generate one option at a time.
So open bracket, option value equals quote, unquote.
And this is where templating gets really powerful.
Curly brace, curly brace, sport, curly brace, curly brace, close quote.
And then so that the human sees the same,
let's do it again out there as well.
But technically, those could be different values from what
the human sees and the browser sends.
So now we don't have three sports here manually typed in.
We're doing this dynamically because we're
passing in a placeholder called sports.
But instead of just spitting out its value, we're using a for loop
in Jinja to iterate over that loop and generate one, two, three
options programmatically instead.
So here is the programming in web programming.
We are generating all the more HTML now using some logic.
All right.
Let's now go back to my other tab, go back to the original page,
and click reload.
I screwed up somewhere else.
All right, so let's go back to VS Code.
Let's open up my terminal window.
Let's click on the first terminal and, oh, name error.
Sport is not defined.
Did you mean sports?
So now Python is very graciously trying to be nice to me here.
Yes, I did mean that somewhere.
So let's go back to app.py.
Stupid mistake.
Sports equals sports.
So now if I go back to my browser, click on reload, now I have another error.
So we go back to VS Code, reopen the terminal.
Now I'm just an idiot.
So it's not sports with two S's, so that was a misclick.
Let's delete that and let me stop touching the keyboard.
Let me go back to the browser.
Let me reload a third time.
And there we have it.
Very impressive, I know.
So now I've got my-- thank you for the applause.
Now we've got the name field, the sport field, all of which are still there,
but they were dynamically generated based on the value of that variable.
So what's valuable about that technique?
Well, one, I'm not manually typing out all of these options anymore.
And think about the extreme.
If it's not three sports, but 30 sports or 300 sports or whatever,
you don't want to manually type all of that out.
You probably just want to have a simple Python list of those values.
Or heck, we could even put it in a text file or a database if we wanted.
But moreover, now that the server knows what the valid sports are,
we don't have to just naively check if there is a value for sport
as we previously did.
I could probably do something logically now
where I make sure that the sport we did get is one of the supported values.
So now we have server side validation as well.
So how can we do this?
Well, relatively straightforward.
If we have this variable called sports, capital S at the end,
I can instead do something like this.
I can change my logic to say if there is not a value for name
or the current sport is not in the sports variable,
then consider it a failure.
It's a very nice Pythonic way to let Python essentially search
through the whole list of valid sports, checking for the value
that the human actually sent.
And if it's not there, we are going to return the failure template.
So now if I go back to froshims, let's reload
to get the fresh copy of the form.
Let's type in David.
Let's go ahead and not choose a sport and click Register.
Ugh, I still have the client side validation.
That's fine, but let me go ahead and hack that by removing it.
Let me open up Inspect.
Let me go under elements inside of this form.
Let's get rid of the requirement for the name, even though I gave one.
Let's get rid of the requirement for the sport, even though--
so that I don't have to give one.
Close my developer tools.
Notice I still have not chosen a sport.
Click Register.
It goes through, but we catch it and we tell the user, no, you
are not registered.
Moreover, watch this.
Let me go back to my developer tools.
Let me go into the form again.
Let me not only delete the required aspect of this from both of those tags.
Let's also change soccer to football, which,
while technically the same sport across countries,
is not the same string that we want in the server.
So let's change soccer to football here and soccer to football here.
And now close my developer tools, type in my name,
but choose an invalid sport that the server does not know about.
Click register.
Still catches it, because now we are doing server side validation.
And I cannot express this enough.
If you proceed after CS50 or even for your final project, let alone problem
set nine, to implement validation of user input,
you should never, ever trust what the human themselves are sending
and you should never rely on client side validation alone.
It's all too easy for someone who's just taken
a single introductory course to disable all of your client side validation.
So if you value the safety of your server, the integrity of your data,
always check server side for valid values.
All right.
So what more can we do to improve this kind of application?
Well, we can tinker with the user interface, a little bit,
if only so that you've seen different UI, user interface mechanisms.
Let me go back to the form here, and indeed we have now this dropdown menu,
otherwise known as a select menu.
Well, there's other ways we could get input from the user.
In fact, let me go back to my index.html.
And we don't have to strictly use, for instance, a select menu.
We can actually use input tags to achieve what are called radio buttons,
those little circular things that you can choose among,
sort of like old timey car radios where you would push one button
and it would pop another out.
You push in that button and it pops another one out.
Same thing with radio buttons in the web.
They are mutually exclusive.
You can choose one but not multiple radio buttons by design.
So how can I do this?
Well, in my index.html, let me go ahead and get rid of the select tag
there and the select tag here.
Let me go ahead and get rid of the disabled option.
And then let me just go ahead and still iterate over all of the sports,
but instead of spitting out an option tag which
is only relevant for the select menu, let's go ahead
and spit out an input tag whose name is quote, unquote sport, the type of which
is no longer text but radio, the value of which
is the current sport in this current iteration of the loop, quote, unquote.
And then to the right of it, just so the human has something to look at, let's
also repeat the name of the sport.
So again here, we're making a distinction,
just like with anchor tags for links, what the human sees
and what the server sees.
But they can be one and the same.
Let me go back to my other tab.
Let me go ahead and reload this, and my select menu will now
be replaced with some pretty ugly but still functional radio buttons.
Let me go ahead and zoom out so it all appears on one line.
And now if I type in my name and I select something
like basketball and click Register, everything else is the same,
but I've changed the front end by changing the HTML.
Of course, whether we're using select menus or radio buttons,
we're still never actually telling the user why they're not
registered in those cases where something goes wrong,
where, for instance, they accidentally leave a field blank,
or even maliciously, they try changing those fields.
So how can we go about being a bit more informative?
Well, let me go back to VS Code here.
And inside of our register route, which is doing the validation,
let's do a little more validation than we are at the moment.
Let me propose this.
Let's be a little more verbose with our error checking.
And how about this?
Let's first go ahead and grab the name that the user typed in, if any.
So name equals request.form.get quote, unquote name.
And then let's ask a question just like we did before,
but with a shorter block of code.
If not name, then go ahead and return render_template.
But instead of just simplistically returning failure.html
with no clarity as to what has gone wrong,
let's return a different template, error.html.
And let's pass in a specific error message to the template
that the human will see that's somewhat informative.
And in this case, I'll say aptly, missing name,
quote, unquote, just so that there's more informative errors.
Otherwise, let's go ahead and do this.
Let's first get the sport from the user, from request.form.get quote,
unquote sport.
And then as before, if not sport, let's go ahead and return
an error but this time with a message.
Return render_template quote, unquote error.html.
But the message this time will be missing sport.
But there is something else that can go wrong here.
If the sport the user typed in is not in our sport's global array or global list,
then let's return render_template quote, unquote error.html.
But the message this time will be invalid sport.
Now, ideally, users should never see this latter message,
at least because only if they tried to hack our HTML, so to speak,
would they actually be able to submit an invalid sport.
But for good measure, you should assume the worst
and you should absolutely be handling this error
even if you don't, strictly speaking, need a user friendly error
message for those same adversaries.
But otherwise, I think we can assume it's a success, as before.
But we do need to create this here template.
So let's do this.
Let me go ahead and close success.html.
Let me go ahead and open failure.html but now close it.
And let me go ahead in my terminal window,
create a new file, code of error.html, paste the contents of failure.html
just so we have a starting point.
But in error.html, let's actually have a more useful message.
Instead of just saying you are not registered,
let's instead say something like h1 error,
to make clear that this is an error page,
and then maybe put a paragraph of text below it, even though it's succinct,
and plug in that message that we passed in via get template.
OK.
Let's now try to induce this here problem.
Let's go back to index.html.
Let's get rid of the required attributes so that I
don't have to keep hacking my own HTML.
But let's now go back to the tab with the web application, go back to the form
itself, which in its most recent incarnation
is indeed these radio buttons.
And let me not type a name and not type a sport.
Click Register in just a moment, at which point previously I saw you
are not registered.
Hopefully this time I'll see a more useful error.
Indeed, missing name.
It's not a very pretty page, but at least it's giving me some information.
So let me go back and type in my name.
Now let me click Register without choosing a sport.
Aha.
Missing sport.
And if I did again hack my HTML, so to speak, by changing soccer to football,
that too would show an error but invalid sport according to my logic.
Now, just for fun we could make these error pages
look a little more interesting.
And in fact, what I'm going to go and do is this.
Let me go back into VS Code.
Let me go ahead and open up error.html, and below that informative error
message, let's use an image tag.
Let's specify that the source of this image tag
is going to be that of a file, maybe a picture of a cat.
However, as I hinted earlier, when we have static files like images
or CSS files or JavaScript files, by convention
they should be in a folder called static.
So in my HTML, I'm going to literally say /static/cat.jpeg.
I happen to know already that this is going to be a Grumpy Cat, hence
the error message.
So I'm going to give an alternative text for accessibility
of Grumpy Cat, who's internet famous.
And now I'm going to open up my terminal.
I am going to clear it.
cd dot dot to go back into froshims, where again at the moment
we have just app.py, requirements.txt, and templates.
I'm then going to go ahead and make a new directory
called static, all lowercase.
I'm going to cd into it.
And then with a wave of my hand, I'm going
to go ahead and copy from today's distribution code
a copy of cat.jpeg so that now when I type ls,
I indeed have a cat.jpeg that I came prepared with earlier.
Let's now go back to my browser tab.
Let's click reload to still submit a form that's missing a sport.
But now we should see, per the image tag we've introduced
and the cat.jpeg in the static folder, that I indeed
now see a very Grumpy Cat for this error message.
Now using some CSS and such, I can make it prettier
and make the cat not take up the entire web page.
But for now we've at least demonstrated how
we can have a static file alongside dynamically generated content by putting
that static file in the static folder.
All right.
So now let's actually do the most useful thing and start storing in memory
these names and sports for which students have registered.
Let's go back to app.py and acknowledge that
at the bottom of this register route, all
I'm doing is blindly saying success.html.
You are registered.
Even though I've not done anything with the actual data.
So it's in app.py that we have the opportunity to save some of that data.
And so what I'm going to do is this.
At the very top of the file but below my sports variable,
let's create one other variable in all cap, REGISTRANTS.
And I'm using all caps again to signify that this is a global variable, even
though it's not constant.
Let me set that equal to open curly brace, close curly brace.
Which even though we've been doing those curly
braces all over the place in our templates per Jinja syntax,
we are just in app.py now.
This is Python syntax from week six wherein
I've now created an empty dictionary or dict object in Python
by using curly braces.
This is the same thing as saying dict, open paren, close paren, which
just returns to me an empty dictionary, but it's a little more Pythonic
just to use the syntax of open curly brace, close curly brace.
But why this?
Well, if I've got names and sports, names and sports,
that's like keys and values.
I might as well store that kind of data in a Python dictionary
where the keys are the names and the values are the sports.
So how do I do this?
It's actually pretty simple.
Right before I declare that the student is registered,
let's just go into that registrants array.
Sorry.
Let's just go into that registrants dictionary.
Let's index into it at the name, location
that I want to put into the dictionary, and set
it equal to the value of that sport.
And I'm simply using the variables that I
created earlier for the purposes of doing error checking
and using the name and sport in different places.
But I'm now using that same variable name and that same variable sport
as my key and value pair.
Now, as an aside, this is a little naive of me,
and it's not the best implementation.
As written, this will not let two Davids, for instance,
register for two different sports.
Why?
Because we're allowing one name to overwrite another identical name.
So if two Davids try to register for these sports, probably not
a good outcome because we're going to clobber or overwrite
the previous person's registration.
But let's consider a simple world in which there's only one
of any name in the world so that we don't have to worry about that just yet.
Now let's go back to my other browser tab, clicking back in that.
So we get back to the form.
Let's type in David.
Let's type in basketball and register.
Says that I'm registered, but who knows at this point?
Let me go back to the form.
Let me type in Yulia and let's register Yulia for soccer.
Click register.
Claims that she too is registered, even though who knows.
But hopefully in app.py before success.html is rendered,
we're indeed adding David and then Yulia and then anyone else
to that global dictionary.
And so long as the server stays running, that dictionary of keys and values
is just going to get bigger and bigger and bigger.
But let's see if we can't show ourselves those registrants.
Well, maybe the simplest way to do this is to give ourselves a third route.
So let me say app.route quote, unquote registrants.
And then below that decorator, let's say def registrants to define
a new function called exactly that.
And let's keep it simple.
Return register.
Sorry.
Return render_template quote, unquote registrants.html.
But I've got to pass in those registrants to the template
so it knows what registrants to show.
That's fine.
Registrants equals REGISTRANTS in all caps.
So same convention as before, but I'm providing the registrants.html template
with that global dictionary of names and sports.
Of course, I need another template.
So let's do that.
Let me open up my terminal window.
Let's go back out of the static directory.
Let's go into the templates directory.
Let's create a template called registrants.html.
I'll close my terminal, and up here I'm going
to do the same boilerplate as before.
Extends quote, unquote layout.html.
And I'm going to type every keystroke correct this time.
Then I'm going to say begin--
no, I'm not.
Then I'm going to say block body percent sign, close curly brace.
Down here I'm going to say endblock, and then the same.
And in here I'm going to output a list of all of the registrants.
And I can do this in a number of different ways,
but frankly, I think it suffices to maybe just do
maybe a bulleted list initially.
So how might I do this?
Well, I could do something like an unordered list tag
there, inside of which I have a whole bunch of list items or li tags.
How?
Well, I could do something like this.
For name in registrants, which is the placeholder or the rather the variable--
the parameter, which was the parameter that was passed in.
Then let me proactively close that for tag in Jinja.
And then in here let's do li, and then inside of the open and close tag,
let's just do name for now.
Before we take a look at the effect of these changes,
though, I am going to open my terminal window
and I'm going to hit Control-C just to stop the server,
and then I'm going to rerun flask run just
to ensure that Flask knows about this very
latest version of my code into which I've added that global dictionary.
Now I'm going to go back to my same browser tab
as before, which is still running on TCP port 5000,
and I'm going to try to register a couple of people.
So I'm going to register myself for basketball, for instance,
and I seem to be registered.
I'm then going to go back and I'm going to try to register Yulia,
say, for soccer, and I'm going to click Register.
And now my hope is that both David and Yulia
are in the server's memory in that global dictionary as key value pairs.
So if I go up to my URL here and zoom in and I
change register to registrants and hit Enter,
I indeed see now a bulleted list of all of the names of people who
have registered for sports thus far.
Now, it doesn't have to be a simple bulleted list
because it would be nice to know what sports we registered for,
but that's just a matter of HTML.
Let me go back into VS Code and hide my terminal window.
Let me go into registrants.html, and we can go all out in this if we want.
For instance, let me go ahead and do this.
Let me get rid of the unordered list tag there.
Let's give ourselves a proper title of registrants, this time in an h1.
Let's then begin a table inside of which is going to be a table head initially.
And inside of that table head will be a table row.
And inside of that table row will be two table headings, namely name
as well as another table heading of sport.
In other words, I want to have a two column table, if simplistic,
that shows me name, sport, name, sport, or more generally, key value pair.
Below the table head, let's go ahead and do a tbody for table body.
Inside of that table body, let's now iterate over that same dictionary.
But let's do it a little more pedantically such
that I'm going to do for each name in the dictionary,
in that registrants dictionary, then let's proactively
put an endfor below that.
And inside of this for loop, let's create a table row for each person.
Let's create a table data inside of that row inside of which
is going to be that current name.
Then, in the second column via second table data tag,
let's go ahead and put the value of that key, the syntax for which,
just like in Python, is registrants, but index
into that dictionary at that specific name with curly braces on both sides.
As in Python, when I iterate over a dictionary in Jinja here
in this here template, I'm indeed iterating over all
of the keys in that dictionary.
So if I want to get at the value, I need to use
that key that is named to index back into that dictionary.
Now if I go back to my browser tab here, previously I saw all of this
as an unordered list.
But if I now click reload on my registrants route,
I now see a big, bold h1 tag, registrants,
followed by a simple HTML table, one column for name, one column for sport.
It's not the best formatted, but I think if we
introduce some CSS, whether my own or Bootstrap, for instance, we
could make that even prettier as well.
All right.
With all that said, I think we've an opportunity for maybe one final version
of froshims whereby we can actually store all
of these registrations in a database.
The problem at the moment being this.
If I go back to VS Code here and open my terminal window and either intentionally
or accidentally hit Control-C such that the server stops, or worse,
the server loses power, or somehow the server reboots, everything
I've stored in the server's memory and that global dictionary
is going to get erased by default because I'm
going to get a brand new dictionary when the server restarts.
In fact, if I rerun the server now with flask run,
go back to that very same tab which had David and Yulia and click reload,
all of a sudden we're gone and the table is empty except for that heading.
So that's not the best way to persist data.
In fact, if that could happen, we might as well
go back to yesteryear's pieces of paper to keep track of everything.
But I think we can fix this.
So wouldn't it be nice if we could use a proper SQL database instead
to store all of these key value pairs?
Well, in fact, let me go back to VS Code here.
And inside of VS Code, let me show you a database file
that I prepared in advance.
Let me maximize my terminal window.
And I've just copied over already a file called froshims.db,
which is a database just for these intramural sports.
Let me run our old friend sqlite3 on froshims.db.
That puts me inside of the SQLite program.
And recall that if I type dot schema, I can see what table or tables are inside
of this database.
Sure enough, there's just one table here called registrants,
and it seems that that table has three columns.
An ID column, which is an integer, presumably the primary key,
a name column, which is text that cannot be null,
and a sport column that's also text that cannot be null.
And sure enough, the primary key of this table is that first column, ID.
So if I now take on faith that this table exists,
even though, at the moment, select star from registrants
seems to have no rows in it, I think I can write some code
to put registrants there.
So let me go back to app.py here.
And at the top of my file, let's do this.
From CS50, import its SQL feature.
And then down here a few lines later, let's
go ahead and create a connection to that database via variable called db.
Set it equal to SQL, quote, unquote, sqlite colon slash slash slash.
So even though it looks like a URL, you do need the third in this case.
Froshims.db.
And recall that from week seven, this is how I'm going to be able, from Python,
talk to that SQL database.
Let's now scroll down to this REGISTRANTS variable, which previously I
was using to store these key value pairs, and let's just get rid of it
altogether because I don't want to keep storing these registrations in memory.
Let's go down further to my register route
and get rid of the use of that dictionary,
because instead I want to do something now with SQL.
In particular, I'm going to do this. db.execute quote, unquote insert
into registrants maybe two things.
Name comma sport.
I'm going to let SQLite automatically fill in with autoincrement
the ID column therein.
The values I want to plug in though are these two,
with two placeholders, question mark, question mark, close quote.
And the two values I want to plug in for those placeholders in SQL
are name and sport respectively.
So here too, I'm using the same terms, placeholder, but in the context of SQL,
not in the context of Jinja.
The syntax and the purpose is a little bit different,
but that's exactly what we explored in week seven with SQL and Python.
Now after that, I think we're good with the register route.
What we do still need to do is get rid of this final use of that dictionary.
Previously, I was passing into my registrants
route that global dictionary, so I have all of those key value pairs.
Now a SQL table is not all that different from a dictionary
if we focus on just two of its columns, name and sport.
So how can I get at those columns inside of my registrants route?
Well, let's create a registrants variable, set it equal to db.execute--
and this part's easy.
Select name comma sport from registrants to select exactly those two columns.
That's going to hand me back a list of dictionaries,
each of which itself represents a name value and a sport value.
So if I now change this value from REGISTRANTS
in all caps to registrants lowercase, this
is the variable being passed into the template.
This is the value thereof.
And I think if I go now into registrants.html,
I just need to make a tweak whereby now if I'm iterating over those return
values from db.execute, I need to be a little more explicit.
So instead of iterating over a dictionary as I did before,
I'm going to more generally iterate over a registrant
in that list of dictionaries, and I'm going to spit out here registrant.name,
and down here I'm going to spit out registrants.sport.
And it turns out in some contexts I can use either the square bracket
notation or even the dot notation, the dot notation being a little easier
to read because there's less syntax.
But the reason I can do that is because, again, the registrants variable that I'm
passing into this template is itself a list of dictionaries,
and each of those dictionaries represents a row from the SQL table.
And so if I want to access the name column therein,
I can say registrant dot name, or the sport column
therein, I can access registrant, singular.
This one is about to be my next typo.
Registrant.sport.
And so now, crossing fingers big time this time,
let me go ahead and go back to the form itself.
Let me go ahead and register myself for basketball
because we cleared the memory when switching to SQL.
Let me now go back again and register, say, Yulia, this time for soccer.
And register.
And now let me manually change my URL to be registrants.
Big time crossing my finger.
And there we have it.
Now, David and Yulia.
I was as surprised as it worked this time.
But David and Yulia are registered.
And more importantly, if I go back to VS Code
here, select star from registrants in my database, there are those two rows.
Moreover, if I exit out of SQLite and I go into my other terminal and even
Control-C and restart Flask with flask run and go back to /registrants
in my browser and reload, the data is still there.
We have made now a full fledged web application, if ugly,
that is actually storing data permanently,
full time, that survives clearing of memory and even reboots of the server.
All right.
Still more to come.
Let's go ahead and take a five minute break, and when we come back,
we'll add some of-- lastly, some of the most familiar features
that you see in today's actual web applications.
See you in five.
All right.
So up until now, even though we've been building an application that's
very specific to froshims, it's actually representative of a paradigm
when it comes to web programming and software engineering more generally.
In fact, up until now, what we've really been implementing
is a couple of concepts.
One is what we would generally know in software engineering as a controller.
So app.py is representative of a type of program
that you might call a controller for exactly that reason.
It's controlling everything about your application.
It contains the so-called business logic for your application.
Meanwhile, though, there is a part of the application
that the user sees and interacts with, and that's generally
known in some circles as a view.
So everything in the templates folder really is a so-called view.
But in that most recent example with the froshims,
once we started writing and reading data to and from a database,
we introduced a third piece of the puzzle,
which is generally known as a model.
And model refers to the database or some kind of storage
that you're using to read and/or write data.
And collectively, these three ideas of model and view and controller
are generally referred to as MVC, model view controller.
And it just describes one type of architecture
when it comes to implementing a web application or really
other types of application whereby, when you sit down to design them,
you don't just implement everything in one massive file, which we've kind
of been doing throughout much of CS50.
But rather, you separate concerns.
You put all of your templates, a.k.a. views, over here.
You put all of your model related code over here.
And then you have a controller that's somehow orchestrating between those two
concepts.
It doesn't change anything we've yet done,
but it does slap some industry standard labels on top of them.
Speaking of industry, it turns out it's incredibly common on websites,
of course, to log in to them as your-- like your Gmail account,
for instance, if you use, or Office 365 or some other email service.
Or really any website nowadays for which you have a username and password
and log in.
And indeed, up until now, neither of the applications we wrote,
the hello world application or froshims, had any notion of individual users.
There was no login, which means anyone who sits down at the keyboard
could type in some input.
What that means similarly is that anyone who's at the keyboard
can see all of the information therein, including the form
itself, the list of registrations, the confirmation pages.
And that might not be ideal because if we really
are implementing the idea of those paper based forms
back in the day, well, really only that resident advisor or proctor should
have access to the forms once they're submitted.
Everyone shouldn't be able to just change their URL to /registrants and be
able to see something.
Which is to say if we did want to add the ability to log into a website
so as to exercise finer grained access control so that I can see this,
you can see that, we need to somehow add more functionality
to these applications, much like Google has added to their own Gmail page.
Unfortunately, the way HTTP is designed is
that every piece of information that goes between browser and server
has to be sent all at once for the browser to know about it.
And yet when the user then clicks on another link, ideally in some cases
the server would like to remember, oh, wait a minute, this is the same user
and I already logged them in before.
You don't want to have the user to have to log in every time they click
a link or every time they submit a form to prove to you
that they are who they claim to be.
In other words, you'd like to be able to remember
that someone has already logged in.
So, for instance, in the real world, if you
go into a club, an amusement park, or a bar,
sometimes they put a little bracelet on you or sometimes they stamp your hand.
And that hand stamp is meant to confirm if you come and go
through the same door, oh, we've already authenticated you.
We've already checked who you are so that we don't have to pull out your ID
and look at it again.
So, in fact, I actually have a little hand stamp here.
And so if you imagine that here is my hand with no stamp
on it being presented to get into some fun amusement park.
Once I've shown them my ticket or my ID, what they might very well do is,
if not a bracelet, put a stamp on my hand like this here smiley face.
And so long as I show that to the bouncer or the ticket taker
again and again, they will remember that I have already authenticated myself
by showing them my ticket or showing them my ID in the past.
Now it turns out that HTTP, funny enough,
can implement exactly this same idea, albeit more technically.
Recall that when using HTTP, you see a message like this in the browser being
sent to the server, for instance.
For instance, when you log in to Gmail specifically,
inside of that virtual envelope goes a post message
followed by slash or some such route, followed by the version number of HTTP,
and then maybe some reminder as to what hostname is being posted to.
Meanwhile, the server hopefully responds,
as we saw last week, with HTTP 200, which is a status code meaning OK.
But wait a minute.
If we have already this mechanism whereby
the browser can talk to the server and the server can talk to the browser,
could we implement, from the server to browser, this notion of a hand stamp?
Well, we can.
We haven't dwelled on these too much, but recall
that inside of that virtual envelope, such as one pictured here,
is a HTTP header.
One or more of those things-- and in fact, every time
I've pulled up developer tools, there's actually been a whole bunch.
This is just a key value pair.
So maybe if we could somehow implement this notion of a hand stamp
as a key value pair, we could remember that someone has logged in.
Moreover, we can remember who has logged in somehow as well.
And in fact, the way that HTTP has browsers and servers
do that is as follows.
When you log into Gmail or really any website,
what that server does in its response message to you is unbeknownst to you,
really, is it stamps your hand.
Specifically, it includes in the virtual envelope
among all of those HTTP headers, another key value pair.
Namely set-cookie, colon, and then some value.
And while you could somewhat foolishly just put the user's email address,
like set-cookie, colon, session equals malan@harvard.edu.
Generally the value inside of that HTTP header
is like a big random value, a big string of text and/or numbers
that somehow the server keeps track of and remembers that, OK, I gave David
this big random number.
I gave Yulia this big random number.
So we don't all get the exact same smiley face hand stamp.
But the next time the user from that same browser clicks a link,
submits a form, unbeknownst to you, the browser sends another header in addition
to the usual, namely a cookie header.
Cookie, colon, and then the exact same string.
Session equals value, for instance.
And session itself is kind of a term of art.
Session refers to the concept of maintaining state between the browser
and server, even though HTTP, by design, is really meant to be stateless.
Once the browser icon stops spinning, you've
gotten all the data you're going to get from the server.
But so long as the browser knows that once it receives a cookie,
send it back to the server, send it back to the server,
include it in every subsequent virtual envelope.
The server can remember that, oh, I've seen that smiling face before.
I've seen that big random number before.
That must be David.
That must be Yulia.
And so it's a very clever way of just reminding the server who you are.
And to be clear, the cookie itself could be your email address.
Heck, you could even use your password just to constantly remind the server.
Here's my username, here's my password, here's my username,
here's your password.
But that's generally not a good idea, and you should not
be doing that nowadays because it's all too easy potentially
for the data to get intercepted.
And certainly don't send usernames and passwords over the internet
more often than you need to just as a good principle.
So with that said, if we have the ability
to stamp the user's hand in this way and to remind the user what's there, what
you're looking at, indeed, are cookies.
And in fact, this class is so long already,
it's a good thing we brought some snacks for today.
So these here cookies, these are what cookies actually are.
And all of us have probably heard about cookies in the context of the internet
for some time, whereby cookies get saved on your computer from the servers
that you actually visit.
Well, what is a cookie?
There's really no academic value to what I'm doing here.
But what is a cookie in the context of the web?
Well, it is just typically a big random value that's stored on your computer.
And it doesn't have to be random.
It can be, for instance, your username.
It can be your email address.
Hopefully it's not your password.
But if you've ever checked that box that might remember your email address
and autopopulate it, it may very well be the server that's
reminding you of that same value.
The reason that cookies get kind of a bad rap,
though, is that there's a lot of cookies typically being stored on your browser
from servers around the world, and a lot of those cookies
are used to track you and me.
Now it stands to reason that if I've logged in to a website, well, of course,
the website's going to be able to track my behavior on that website
because I literally told them who I am.
But in the world of advertising, for instance,
it turns out that even if you're not logged into a website,
there are enough unique features to your computer and your browser and the way
that you use it that servers can typically
plant cookies on your computer, even without your logging in.
And even though they don't know that I am David and that is Yulia,
they do know that I'm the same user again and again,
and they can effectively build a profile of who you are
based on all of your clicking behavior.
So if you recall last week when I first was demonstrating
various features of HTML and the like, I was actually deliberately
using incognito mode sometimes because I wanted to start with a fresh slate.
And so among the things that incognito or private browsing mode
typically does is it gives you a brand new empty cookie jar, so to speak.
It clears the browser's memory just for that window
that you've opened privately, and it makes sure
that you have no cookies by default and you have no other settings by default
being sent back and forth to the server, effectively ensuring
that you're starting from scratch.
But if you're using the same non-incognito or non-private tab again
and again and again, you really are accumulating a lot of these cookies.
And in fact, if you open up developer tools, you can see under the Storage tab
or thereabouts in other browsers all of the key value pairs
that servers are storing on your computer.
So with that said, let's use cookies, though, not for evil but for good,
and to actually use them to remember that a user has logged into a website.
And to do that, we're going to leverage a feature of Flask that
is built on top of these cookies known as a session, which is, again,
just some form of memory that keeps track of that fact
that we have seen some user before.
In effect, a session is the technical way
to describe something like a shopping cart.
Any time you've bought something online or added something to your shopping
cart, you could come back a few minutes, a few hours, a few days later
and, depending on how the website is implemented,
it can remember what is in your cart thanks to these cookies.
Similarly, we can remember that you're logged in via these cookies using
this here feature.
So let me go into VS Code here, and in advance during break
I went ahead and created the beginnings of a login based application.
If I type ls in my login directory here, we'll
see app.py, requirements.txt, and a templates directory
inside of which, as before, is just index.html and layout.html.
But let's go ahead and implement a website
that now knows if I'm logged in or not, albeit simplistically.
Let me go ahead and open up my index template in templates
and I'll close my terminal window.
And in here I'm going to use some Jinja syntax that we've seen before.
If the current user has a name, well, then they're clearly logged in.
So let's go ahead and say, you are logged in as name, period.
And if it's not the case that there's a name value, then let's go ahead
and say you are not logged in, period.
And I'm going to add an endif down here.
So at the moment I'm just assuming that name is a thing
and that it actually exists, but I'm going
to need to implement now that logic next.
So let me go into my terminal window again,
this time opening up my app.py, which isn't really doing much yet,
and start to make a few changes.

In addition to importing Flask and render_template and request,
I'm also going to import a feature called session.
And then down here I'm going to configure
Flask to use sessions as follows.
And this is the kind of thing you can Copy-Paste from documentation
or these are examples.
But I'm going to say app.config, quote, unquote SESSION_PERMANENT equals False.
Capital F for false in Python.
And app.config, quote, unquote SESSION_TYPE equals,
quote, unquote filesystem in lowercase.
This essentially enables the ability to store sessions.
Put another way, this turns cookies on for this web application.
It ensures that the cookies are not permanent in the sense
that what cookies I'm using should disappear when the user quits
their browser, ultimately.
But I'm using, on the server, the file system,
like the files and folders locally, to keep track of who is logged in.
And then lastly, I'm going to say session capital S
and specify app there too.
And I'm going to import one other line that I forgot from flask_session import
Session capital S. Again, there's some hoops to jump through here.
I too have to check the documentation or my own examples to remember what.
But in short, I'm importing Flask's support for sessions.
I'm importing this session specific library as well.
I'm specifying these configuration options,
and I'm now turning on sessions with this final line of code.
Of course, for this to work, I actually need another requirement.
So let me open up requirements.txt, which, up until now,
we've not needed because we already put Flask in there.
But I actually now want to use the Flask session library as well.
Strictly speaking, you don't need to do this in cs50.dev
because we've pre-installed it.
But for a typical real world application,
we would need to tell the server that we indeed have another library,
and install it with pip.
All right.
So that's mostly Copy-Pasteable boilerplate.
Let's go ahead now and implement a route.
So app.route quote, unquote slash for my default route.
Define a function called index, as before.
And let's very simply return render_template, quote, unquote,
index.html.
And then that is it for now.
Let me hide my terminal, go back to my other browser tab, which still shows
the previous application froshims.
But so long as I run flask run in this tab here and go back to that tab
and click reload, I should now see this new application.
And indeed, I do.
It just says you are not logged in, because I haven't done anything related
to logging in yet.
Well, that's OK.
How do I want to go about implementing this then instead?
Well, let me propose that if we want the user to be able to log in,
we need a form via which they can tell us who they are.
So let me go back to VS Code.
I'm going to go back to my second terminal window here.
And I'm going to cd into my login folder to be in the same place,
into my templates folder to be in that place,
and I'm going to create one more template called login.html.
Inside of login.html I'm going to very quickly carefully type extends, quote,
unquote layout.html, close quote, percent sign.
Down here I'm going to say block body as always.
And then endblock down here.
And then in here, I'm going to whip up a very simple form.
So form action equals quote, unquote slash login.
The idea being, in a moment, I will create a new login form.
The method I'm going to use for logging in, for privacy's sake,
is going to be quote, unquote post.
Then inside of this form, I'm going to have
a text field where autocomplete is off.
Also, for privacy's sake.
Autofocus is on, for convenience's sake.
The name of this field is named for the user's name.
The placeholder they'll see is quote, unquote name.
And the type of this field, to be clear, is text.
For simplicity's sake, I'm not going to bother with the password.
In fact, we'll see that in the next problem set.
But for now, I'm just going to allow the user
to log in just by telling us their name and no password.
So I'm going to have a button, the type of which is submit,
and then the label for that button shall be log in.
How now do I actually render this template
so that the user sees it when it's time to log in?
Well, I think this is fairly straightforward.
If I go back to app.py, I can create another route down here.
App.route quote, unquote /login.
Then I can create a function called, for instance, login, to keep it simple.
And then I can simply do render_template quote, unquote login.html.
Now I could go manually to /login to access that page,
but let's make this template a little more user friendly that we began with.
Let's actually give the user a link. a href equals quote, unquote /login,
and then inside of that anchor tag, log in, period.
Otherwise, let's proactively do this. a href quote, unquote, logout,
and then inside of that anchor tag, log out.
That is backwards.
So let's do it correctly this time.
Here, we're going to say log out if the user is logged in.
Down here, we're going to say log in if the user is logged out.
So I think now it's consistent with the English I already had earlier.
Let's go back to the original URL whereby it says you are not logged in,
but it now gives me a link to log in.
If I hover over that, super tiny, but in the bottom of my screen,
I will see that it's going to the /login route.
And indeed, if I click on that, I find myself at the first--
well, the 10th of many errors today.
So let's go back into VS Code.
Let's open up my terminal window, click on the one that's running Flask.
And, ah, the view function for log in did not return a valid response.
The function either return none or ended without a return statement.
So user error on my part.
Let's scroll down, and sure enough, I did something dumb.
I need to return the return value of render_template.
All right.
Let's hide that.
Let's go back.
Let's click reload, enter, and now we see the login form.
Of course, it doesn't do anything useful.
If I type in David and click Log In, it goes to the login route.
But it's saying method not allowed because I haven't done anything yet
with post.
That's fine too.
Let's go back to my login route and let's do this.
If the request.method equals equals post, the implication being the human
clicked the Log In button after typing in their name, then let's do this.
Session, then in square brackets, name equals request.form/get quote,
unquote name.
And then we will, let's say, return redirect quote, unquote slash.
So what's going on here?
If the user indeed submitted the login form
using a request method of post, which is implicit because that is the method
I'm using in login.html, thereby allowing
me to distinguish between whether the user just visited the form
or they submitted the form.
If I go back to app.py, I am, in the case of submitting the form,
going to store, in a special global variable which I imported up here
on line one, a key called name.
And I'm going to set the value of that key equal to whatever
the human's name actually is.
Now, as an aside, I'm not bothering with error checking
now, so it's possible to just click the button and not type in a name.
But imagine from froshims we could borrow some of that
if not logic to make sure that the human gave us a valid name.
But the point here is that this special global variable that I've now
imported and enabled by way of these lines of code
here is essentially giving me a global variable that's,
in essence, a global dictionary in which I can store any key value pairs.
The first key I'm storing is name.
The first value I'm storing is the human's actual name.
And what I can now do more interestingly is this.
When it comes to displaying the default page, which, recall, is index.html,
recall that I was checking, is there a name being passed in?
Well, there can be.
Instead of just rendering the template index.html,
let's pass in the user's actual name by using session.get quote, unquote name.
And here too, I'm using a feature of this session global variable
whereby it too, like request.args and request.form,
comes with a get method built in that allows me
to get the value of that specific key.
And as an aside, if there is no such value,
it will at least return None capital n in Python, which is similar in spirit
to null but unrelated to memory.
But it's a special value that indicates, uh-uh, there was no such name.
But so long as I'm using this logic in index.html, checking if there is a name,
that's either going to be a valid name or blank or missing.
In either case, I will display the user's name, I think.
So if I've done everything correct here--
which I haven't, but I caught myself this time.
I did one last thing on line 20.
If the user has submitted the form via post and, per line 19,
I've remembered in my session that they're logged in,
that's sort of equivalent to stamping their hand,
storing their name in the session, effectively remembering who they are.
The last thing I'm going to do is redirect the user back to slash.
Why?
Well, think about most any website you log into.
If you try to visit a page and you're not logged in, you log in,
hit Enter, and you're usually redirected back
to the home page or the default page.
How can you do that?
Well, slash represents the default home page,
so I just need to import one more feature of Flask, the redirect function.
So I'm going to add that to my comma separated list on line one.
And that gives me the ability to send, if you
recall from last week, one of those 301 status codes
or 300 something that tells the browser that the website has
moved to this other location.
For instance, from this to this other one.
All right.
Let me go back now to the browser here.
Let me click back to the main page such that I'm told you are not logged in.
Let me click on Log In.
Let me type in my name.
Crossing my fingers.
Enter.
And now, ugh, darn it.
I'm still getting method not allowed.
But this is something we've seen before.
That's just because I'm trying to use the login route for both get and post.
So I think I need to add methods, equals, quote, unquote, get and quote,
unquote, post.
Just as with froshims.
And now if I go back and I try to resubmit this form and click Continue,
now you are logged in as David, period.
There's still a bug, or really a missing feature.
If I click Log Out, I go to /logout, which is not found at all.
But that's just because that route doesn't exist.
That's fine.
Let me go back to VS Code here.
Let me create one final route app.route quote, unquote /logout.
And then in this route, let's define a function called
logout to keep it simple.
And in here, I just need to clear the session.
I need to clear off the hand stamp from the user
so as to tell them, stop sending me this cookie.
And so we can actually do a function called
session.clear, which clears the contents of the session.
And then I can go ahead and return redirect, quote, unquote slash
so that once you log out, you're just sent back to the home page again.
So if I try this again over here, 404.
Let me go back to where I was.
Let me click Log Out now.
And notice I'm still at slash, but I'm no longer logged in.
I can do it again all day long.
Type in David.
Log in.
Click Log Out.
I can log in now as Yulia.
Log in.
Now she is logged in.
And now she's logged out.
And even though I keep saying slash, recall that browsers are typically just
in the habit of hiding values that don't really need to be there all the time.
So if you see nothing after the TLD in the URL,
it's implied that you're visiting slash, the default page.
All right.
So with that said, what we've just introduced then
is this idea of a session whereby, because of how HTTP works
and because of how cookies can be sent back and forth from browsers
and servers, and because Flask is used by so many people,
they've implemented all of the functionality
for us to keep track of those cookies and reading them
and figuring out who is who.
What's nice about the session global variable is
that you can implement one web application,
and if you want to store something in memory for a specific user,
you can store it in the session dictionary
instead of in a global variable, instead of in a database.
So if you want to keep track of who is logged in on a per browser basis,
you use session.
If by contrast, you were to use a global variable like registrants
like we did a little bit ago, every user of your website
would have access to that memory, which you don't want.
So session is sort of like a per user variable,
and you don't have to know or care how it's implemented.
But being in CS50, you know now that that session abstraction, that
per user global variable is really implemented under the hood
because Flask is opening that virtual envelope,
looking for the set cookie and the cookie headers back and forth
and taking care of all of that to ensure that you can just use session
as we intended on a per user basis.
All right.
So let's go ahead and implement another application that also implements
a very common feature using sessions, but this time
to implement full fledged shopping carts.
For instance, if you want to implement a bookstore online via which people
can add books to their shopping cart.
Well, let's see where to begin.
In advance, I've created this folder called store, and inside of it,
I've got a few files.
App.py, requirements.txt, store.db, which is new, and templates.
And inside of templates is the usual index.html and layout.html.
Let me go ahead and use SQLite to open store.db.
Let me go ahead and maximize my terminal window
and simply do a dot schema to see what's inside here.
It seems that there's a single table in store.db called books that has three
columns--
that has two columns.
One is an ID, which will be a unique identifier a.k.a. primary key,
the other of which is title.
If I want to select star from books, I can see all of them.
And in this database, there's only five.
Five of my favorite books, if you will.
All right.
So now that we know that we have that database,
can we go about implementing our own version of Amazon, if you will?
Our own shopping cart to buy these books.
Let's go ahead and open up requirements.txt,
and as before, let's also include, as a dependency, Flask-Session,
even though it's already installed on the server.
But if you use this application anywhere else,
you'll need to install that too via pip.
Now let's go ahead and open up app.py, close my terminal,
and let's add some of those same features up here.
Let's import as well redirect, as well as request, as well as session.
Let's, above that, go ahead and import from CS50
the SQL feature, as we've used earlier.
And let's also import from flask_session the feature called Session capital S.
Then down here, let's proactively connect
to the database with the SQL function, specifying SQLite, colon, slash, slash,
slash, store.db.
Let's then configure sessions as before with app.config quote,
unquote SESSION_PERMANENT equals False.
Then let's specify app.config quote, unquote SESSION_TYPE equals quote,
unquote filesystem, all lowercase.
And then lastly to enable sessions, session passing in app,
essentially wrapping the web application with the session functionality.
Now let's do something simple, a very simple template
that just spits out all of the books.
So let's define a route for slash.
The function therein shall be called index as before.
Inside of that function, let's do this.
Create a variable called books, set it equal to db.execute,
quote, unquote select star from books, to keep it simple.
And then let's return render_template, passing
in the template books.html, HTML, I'll create momentarily,
and passing in those books, as we've done many times now,
with a key and a value as a named parameter.
OK.
Let me open my terminal.
Let me open up a file in templates called books.html
so that I can create now this template.
And this one will be relatively short but dynamic in
that we're going to do the following.
Let's extends layout.html, as we keep doing.
Let us then define a block called body as always.
End the block down here.
And inside of this block, let's do this.
How about a nice big h1 that says, books, to list what's in the catalog.
Then let's do this.
For each book in the books parameter that
was passed into this template-- and proactively I'll do endfor down here.
Let's go ahead and output, how about each of the books titles?
So how might I do this?
Well, let's go ahead and maybe start like we did earlier with a ul tag
down over here.
And inside it, let's do a bunch of li's, where inside of the li
I'm going to go ahead and do the books.title to spit out its title.
All right.
Now I'm going to go back to my terminal window,
and as before, I'm going to do flask run,
having previously stopped the other instance of Flask in my other tab.
Enter.
And now I'm going to go ahead and open up the application as always,
and when I hit reload, we should see no longer our login application but store.
And sure enough, there is a very simple, if unuseful, bookstore that
just lists all of the titles therein.
All right.
Well, let's make this more interesting now.
Let's actually enable the user to add things to their cart.
We can do the user interface in a bunch of different ways,
but let me propose that we do this.
Instead of a ul tag, let's do an actual form.
So let's actually do-- how about this?
For each book in books, let's go ahead and output an actual usable form
for every book.
Even though this is not necessarily the only way to do it,
it's perhaps the simplest to start with.
For this book, let's go ahead and output an h2 tag with its title.
So book.title.
And then down here, let's do a form for this book.
Form action equals quote, unquote cart, which I'll claim
is a route we'll implement in a moment.
The method I want to use for privacy's sake is going to be post for this form.
Now I'm going to go ahead and include a button whose type is submit,
and the value of that button is going to be Add to Cart.
And now I need to actually specify what I want to send to the server
so that it knows what book to add to the cart.
So I can do this.
For instance, input name equals title of the book, the value of which is quote,
unquote the book's title, as before.
And the type of this box could be text.
Now let me go over to the store tab again.
Let me hit reload.
And if I haven't messed up, I think I should, if ugly, have for each book
an input that shows its title and a button that will allow
me to submit that title to the server.
Now this is silly because I already have the book's title here,
and it certainly shouldn't be the case that I
can change the title of a book to add it to my cart,
so I don't think I want an input of type text.
So there's another way I can do this.
I can actually make those inputs hidden by changing the inputs type from text
to hidden.
Now if I go back to that tab and click reload, I still have the buttons,
and underneath the hood I still have the book's titles
such that when I click Add to Cart, the book's title will be sent to the server.
But this too is a little sloppy because recall
that the database that we're using, if I cd in my other tab into the bookstore
and do SQLite of store.db and do select star from books,
recall that I have for each book not only
a title but also a unique identifier.
And this is good because even though this database is small,
what if two books have the same title?
That's definitely the case in the real world,
but they might have different authors, and they definitely have different IDs.
So much better practice than sending a string of text
is to use what we learned in our week on SQL, use the primary key
to uniquely identify these books.
And so by this I mean let's change our template here
to pass in not a hidden title, but a hidden ID
so that what's actually going to be submitted
is the number one or two or three on up.
So if now I go back to that other tab and reload,
visually nothing has changed, but notice if I right click or Control-click,
View Page Source, I indeed have a bunch of forms on this page.
But notice this form will submit value 1 to the server.
This form will submit value 2.
This form will submit value 3.
This is exactly how websites like Amazon and the like work,
such that when you click Add to Cart, your browser is
sending a unique identifier for that book or whatever it is to the server.
And the server is then saving that ID in its database
or its session or somewhere else to remember
what book or item is in your cart.
So we too can do that.
Let me go back to VS Code and let me go into app.py,
and let's add a bit more logic that's going to allow
me to add those numbers to my cart.
Well, what is the cart going to be?
Well, we have to implement a route for this.
So let's define app.route quote, unquote /cart.
And then down here, let's define a function called cart.
And then in here, let's do a couple of things.
Let's first say if request.method equals equals post, the implication of which
is the user clicked a button to submit a form.
Then let's go ahead and get the ID from that form.
I'm going to get request.form.get quote, unquote ID.
Now just to keep myself sane, I'm going to call it book_id,
just so I know it's a book's ID and not some other identifier here in Python.
As always, I'm going to do some error checking.
If the book ID exists, then I'm going to add that book_id to the shopping
cart in my session by appending it to that cart.
Now, what's going on here?
I'm assuming at the moment that there's already a shopping cart in my session.
What is the type of that cart?
Well, because I'm using a pen, which we have used in the past,
it's a method that allows you to append a value to a list of items.
Turns out, I'm assuming at the moment that my shopping
cart underneath the hood is implemented as a simple Python list.
But to do that, I need to make sure it exists.
I don't want this to be some global variable.
I just need in my route to check that the cart exists for this person.
So what I'm going to do is this.
If the cart key does not exist in this user's session, then let's go ahead
and create a shopping cart for this user in their session
that equals an empty list.
And again, you can think of a session as a global variable
for this specific user.
And it's Flask that handles all the cookie stuff
to make sure that abstraction works.
But the very first time someone accesses your shopping cart
and tries to put something in it, it literally
won't exist because the session itself is completely empty.
But I can put a key in there, the value of which is an empty list,
and then subsequently I can add anything I want to that list,
just as I'm doing with this append function down here.
Once now something has been added to the shopping cart,
let's return the user by redirecting them to their shopping cart.
Otherwise, if the request method is not post and it's get,
which is to say the user just visited the cart,
let's show them the contents of their cart.
Let's create a variable called books, set it equal to db.execute quote,
unquote select star from books where--
and here's where we can use more SQL skills.
The ID of the book is in this list of IDs,
using a placeholder and parentheses to make clear in SQL
that I want to check if it's in a list of values,
much like we talked about nested queries in week seven.
But what list of values do I want to pass in?
Well, that's easy.
Session quote, unquote cart.
Pass in the list that I've called cart to which
I've been appending all of these IDs.
And once I have those books--
and recall that db.execute returns a list of dictionaries.
I can return render_template of quote, unquote cart.html,
passing in those books as the value of that named parameter.
And so if I now want to actually see what is in that cart,
we need just one more template.
So let me open my terminal window.
Let me exit out of SQLite.
Let me go into my templates folder and create a cart.html template.
Hide my terminal window.
Extends layout.html.
Close quote and percent sign.
Then block body as always.
Then down here, endblock, as always.
And then in here, let's do something super simple.
H1 for cart, to make clear this is your shopping cart and not
the catalog of books.
Let's do an ordered list just so we can see the order in which things
were inserted.
And now we'll do for book in books.
And inside of this Jinja for loop, endfor,
let's go ahead and specify a list item of that book's title.
And again, you can use different syntax in Jinja.
You can do book.title or you can do book quote, unquote title,
indexing into it in that way.
But I'll use slightly simpler syntax, as we've been doing for a while.
All right.
If I've now made no mistakes, which is low probability, let's
reload the application itself.
The cart, we now see the same catalog of books.
Let me proactively go to /cart in my URL up top and hit Enter,
and you'll see that my cart is empty at the moment.
But because of all of the logic I've added to my cart route,
watch what happens if we add these to the cart.
Let's try adding the very first book, The Hitchhiker's Guide to the Galaxy.
Click.
All right.
I screwed up here.
I did get redirected to cart.
But, but, but, that method is not allowed.
We know I'm using post because that is what was in my form,
but I think this is an easy fix.
If I'm using method equals post here, I need to support that route here,
so I need to specify the methods I want to support are indeed not just get
but also post for my cart route.
All right.
Let's go back again, back to the catalog, and click Add to Cart.
Aha.
Not only has it been added to the session, I've been redirected to /cart,
and because it's in my session, there is the first book.
Let me hit back now.
Let's add the last book to the book--
to the cart.
Mostly harmless.
Click.
And now I have those two books in my cart.
Now, to be clear, these are only stored in the session.
They're not yet stored in a database.
So this isn't like the user has placed an order.
It's more like they have added something indeed to their shopping cart
temporarily.
And in fact, you can kind of see what's been going on all this time as follows.
If I cd back to my store directory--
let me clear the terminal-- and type ls, notice this other folder magically
appeared called Flask session.
And in fact, if I look inside a Flask session,
you'll see it turns out a couple of files now.
Because I've been using this for some time,
I've created two sessions over time and I essentially
have two cookie values stored in this folder that's
keeping track of what the user has been doing on my website.
In short, these files that are stored temporarily in that folder
are the result of having configured the session as follows.
To use a file system based session so that Flask
is creating these files for you and storing
in those files as much information as it needs to remember what is in whose cart.
And it uses cookies ultimately to main that kind of state.
All right.
I think we have time for one final set of examples whereby we'll
connect all of the dots to you from week six
and week seven together in a final implementation of an application.
Let's do this.
Let me close all these tabs here.
Let me open my terminal window.
Let me hit Control-C on flask and go into now our final example called shows.
And in my shows directory, which I created in advance,
I have similar files but not the same.
App.py and requirements.txt, shows.db, which
is our old friend from SQL wherein we have thousands of TV shows from IMDb
as well as my templates folder, which, as before, has
index.html and layout.html as well.
What I'm going to do now, though, is go ahead and introduce that much bigger
database and make an application that's going
to let us search IMDb, albeit with a simpler UI than at imdb.com.
So how might I do this?
Well, let's go ahead and implement app.py first.
Let me open up app.py and hide my terminal.
And from this list, from this starting point, let's do this.
Add to it from CS50, import SQL.
And down here, let's go ahead and create a connection to that there database.
Db equals SQL quote, unquote sqlite, colon, slash, slash, slash shows.db.
Now I'm going to go ahead and create a route.
App.route, quote, unquote slash my default. Define an index function.
And this function's purpose in life, quite simply,
is to return render_template of quote, unquote index.html.
Now, what's that route actually going to do?
Well, that index.html is going to be very simply a search form.
So let's implement that.
Let me open my terminal and go into templates
and then open up index.html, which has the starting point of our body
as before.
And in here, let's do this.
Form action equals quote, unquote slash search,
which will be the next route that I implement.
The method I'll use now is get, just to make
clear what's going back and forth between the browser and server.
Let's create, as we have in the past, an input with autocomplete equaling off,
autofocus on for this field.
The name of this field will be q, just like our Google example from last time,
the placeholder for which will be query for q, and the type of this,
just to make it slightly better, is search,
which is almost the same as text, but it usually
gives you a little x you can click to clear the search box.
Then I'm going to have a button, the type of which is submit,
and the label on that button will be search.
And that's it for that form.
Now, this isn't fully functional yet, but let's test it out.
Let's go back to my terminal window, back to my shows folder.
Run flask, run in this one after making sure
that it's not running in my other tab.
And in my other tab too, I'm going to go into my shows folder,
but only in one of these am I going to run flask run.
All right.
I'm going to go back now to my other tab, which still shows my shopping cart.
I'm going to shorten the URL to just slash and hit Enter,
and now we see my shows application.
Of course, if I search for something like The Office, enter,
nothing actually happens.
Why?
Because even though the browser brought me to /search?q=office,
there's no search route yet.
So let's go back to VS Code.
And in VS Code, let's go back to app.py and implement that route.
Now in this route I'm going to go ahead and--
in app.py, I'm going to create app.route quote, unquote /search.
So creating the route is super easy.
Define a function called search or whatever.
And then now let's go ahead and search for titles
that match what the user typed in.
So shows equals db.execute quote, unquote select star
from shows where the title equals question mark as my placeholder.
Let's now pass in request.args.get quote, unquote q,
which is the query that the human typed in to the form.
I could create a variable, but it's a short enough line of code.
It fits on the screen.
I'm going to leave it as that.
Then I'm going to return render_template quote, unquote search.html, comma,
and let's pass these shows into this template, shows equals shows.
Now, I don't have a search.html template yet, so let's go and create that.
In search.html I just want to print out those titles.
So let me go into my terminal window, specifically the one not running Flask.
Let me cd into templates.
And then let me go ahead and run code of search.html.
Hide my terminal, and really quickly do an extends quote, unquote layout.html.
Then let me do a block body.
Then let me do an endblock, as always.
And in here, let's just do a simple unordered list
of these titles of shows for show in shows
where shows is the variable I passed in as my named parameter.
And let's end that for loop.
Then inside of here, a list item passing in
show.title as my value to interpolate.
All right.
Let's see what happens now.
Let me go back to my other tab, back to the form itself.
Let's search for office.
Search.
Huh.
Nothing.
So no actual results on the page.
In fact, if I View Page Source by right clicking or Control-clicking,
notice that I've got a ul but no list items.
All right, well, technically, the show is not called office, but The Office.
So let me do that.
The Office.
Search.
Oh.
We actually have a bunch of versions of The Office
which we saw, not only the American one, but the British one and others as well.
So it seems that my equal sign in MySQL query
is behaving exactly as we learned in week seven,
whereby I'm literally searching for a specific title
that I'm plugging in for that placeholder.
So I think we can improve this slightly.
Recall that you can make things a little more flexible by not using
equals, but we could actually use like.
Unfortunately we need to, when using like,
use those wildcard characters like a percent sign
to the left and/or right of the thing that we want to match on.
So the easiest way to do this might actually be this.
Let me create a new variable here called query
and set it equal to, sure, request.args.get quote, unquote q.
However, let me actually prepend to that a percent sign to be my wild card,
and I'm going to use plus, which recall is the concatenation operator in Python.
Alternatively, we could use an f string or some other technique.
But to be pedantic, I'm going to literally add to this string
another percent sign at the end as well as the beginning there.
So if I type in office, this will just construct a Python string or str
that's percent, O-F-F-I-C-E percent.
These percents have nothing to do with Jinja templates.
They have everything to do with SQL per week seven, which
are wildcard characters.
Then over here, I can plug in not the raw value that the human typed in,
but I can pass in that query so that it is placed where the question mark is
and it is properly escaped to avoid any SQL injection attacks.
So now let's go back to my other tab and hit back.
And instead of searching for The Office, let's search for office.
Click.
Now I get back not only all of those offices,
but also every TV show that has ever had the word O-F-F-I-C-E in it,
or a substring thereof.
So maybe overkill, maybe not what I want, but it did, in fact,
make the search a little more versatile.
But it turns out we can improve upon even this user interface.
But notice up until now, what we've really been doing now
is combining Python and SQL and HTML and--
well, no CSS, and everything's quite ugly for it.
But we've combined almost everything.
What if we introduce to the mix a little bit of JavaScript code as well?
Whereby I could move away from this model
where every time I want the browser to talk to the server,
I don't necessarily need to send data from browser to server
and then reload the whole page, perhaps at a new URL.
Much like our autocomplete example at the end of week eight,
recall that we could populate the body of the web page, the DOM or document
object model, using JavaScript as well.
So in fact, even though we haven't done this yet,
I bet I could write a little bit of JavaScript code that talks to the server
and says, give me more results, give me more results,
and just displays them instantly in the existing web page
without having to generate everything server side.
In other words, you can actually use JavaScript to generate some code client
side as well.
So let's see how this might look.
I'm going to go ahead now and implement in this next example, the following.
So let me propose to tweak our implementation of index.html such
that it still has a form, but it additionally
has some JavaScript code that goes and fetches from the server
any book titles that match what the human has typed in.
Rather than have any submit button at all
that sends the whole form to the server and lets the server generate
all of the HTML together, let's instead do a little more client side.
So I'm going to go into index.html here.
And inside of this template.
I'm going to change the way this form here is implemented.
And I'm going to simplify it as follows.
I'm going to get rid of all of this, this traditional form,
and I'm just going to give myself inside of the block body
an input type for which autocomplete as before is off,
which is autofocused as before, whose placeholder is still
quote, unquote, query, whose type is actually search.
What I'm not going to bother doing, though, is giving this thing a name,
because I don't intend to submit this form to the server, per se.
I just need a form field that I can use JavaScript to grab the value from.
What I'm next going to do is create, weirdly, an empty unordered list
with nothing in it.
But I'm going to fill it dynamically with JavaScript, ultimately.
In fact, here comes a script tag, as we saw at the end of last week,
whereby inside of this script tag I can write some actual JavaScript code.
And this is going to look a little cryptic at first,
but I'll walk us through it as follows.
First, let me create a variable called input in JavaScript
and set it equal to document.queryselector quote, unquote
input.
This code will grab from the web page's DOM or document object model--
that is the tree that's been built up in the computer's memory--
the tag of type input.
So this will give me JavaScript access to this here HTML tag.
Now I'm going to listen to that input for any keystrokes.
And I'm going to say input.addEventListener.
And I'm going to listen for the input event, which
just means I've inputted a keystroke.
So I'm not caring about key down or key up.
I'm just saying when something's been inputted,
go ahead and call this function.
So I'm going to use a slightly new feature today
that's called async, which means what's about to happen
is going to be asynchronous for reasons we'll soon see.
Inside of this function, I'm going to now do the following.
I'm going to create another variable called response
and set it equal to the result of waiting for a function in JavaScript
called fetch that will know how to request via HTTP a specific route.
Specifically /search?q= and then some value that I'm going to append.
And what I'm going to append is the value of that input box.
In other words, this line of code is going to make an HTTP request from
JavaScript to the server requesting /search?q=office or whatever I've typed
in.
But I'm therefore using code to simulate and induce
an actual HTTP request without the human actually clicking Submit.
After that, I'm going to say let shows equals await response.txt, which just
means wait for a moment until I get back the text of this HTTP response
in JavaScript.
And then I'm going to do document.queryselector
quote, unquote ul.
I'm going to fix my capitalization.
And I'm going to change the inner HTML of that ul element,
as we did once last week, to be equal to whatever the text in that variable is.
In other words, these lines of code do the following.
This line of code listens for human input in that text box.
This line 13 makes an HTTP request from JavaScript to the server asking
for /search?q=something, where the something is whatever the human typed
in.
Line 14 waits for the response from the server.
Line 15 uses the response and plugs it into the inner HTML of the ul element,
effectively putting a whole bunch of li tags therein.
Unfortunately, search as a route does not quite do what we need just yet.
So I'm actually going to go back into app.py here
and I'm going to modify the behavior of app.py
such that it behaves as what we generally call an API, an application
programming interface, which is a way of standardizing how you provide input
to a service and get output there from.
The API here is going to be super simple.
All I'm going to do now is this.
I'm going to go ahead and search for, as before, some shows in the database
as I've done here.
And what I'm then going to do is actually
render the same template, search.html.
But now that I've confirmed that that part itself doesn't need to change,
I am going to change the template.
In search.html, instead of sending a proper ul tag, which I don't need,
I'm just going to send a whole bunch of li elements instead.
A snippet of HTML, if you will.
Now I'm definitely going to cross my fingers this time.
I'm going to go back to shows here and click back.
I'm going to reload the form, and that still works.
But notice I indeed got rid of the button.
I didn't bother using a Submit button.
Why?
Because when I type in O-F-F-I-C-E, what I want to have happen underneath
the hood is autocomplete.
I want to get back every result that says office.
Now, what just happened?
Well, let me actually go into the developer tools of Chrome.
Let me go into the Network tab, and let me actually start over.
Let me click the reload button here.
Let me clear my log here.
And notice last time I specifically clicked on doc because I only want
to get the top level document requests.
Today I'm going to click all so I can see even these JavaScript based
HTTP calls.
And very simply, I'm going to type in O. It indeed takes a moment,
but notice in the logs here of my Network tab,
I can see the request that was sent from JavaScript to the server.
If I click on that, you can see in this query here--
and it's a big one, so we're seeing a little spin.
Under the Response tab, I don't have a fully formed web page.
I have a whole bunch of li tags and the titles of those shows in there,
hundreds of them, if not thousands of them, which is why it was a bit slow,
whereby the server generated not a full fledged web page, but just
a snippet of HTML instead.
And so this is an example of indeed what's really an API, albeit a naive
one, that's just returning a minimal amount of HTML
that you need to populate your own unordered list.
But generally speaking, this isn't really the best way to do this.
Really, when it comes to APIs, you should
be not sending back snippets of HTML, but really the raw data.
And so in fact, very common in the world of APIs is to use something
called JSON, JavaScript Object Notation.
A bit of a mouthful, but what it means is that instead of sending back
all of that HTML, what you should probably send back
is really the equivalent of a Python dictionary.
JavaScript doesn't have dictionaries, per se.
JavaScript has what the world calls objects.
But for our purposes here, they are the same.
And in fact, what you see on the slide here
is a snippet of JavaScript Object Notation
that wonderfully happens to be the same format
that we use in Python for dictionaries.
Kind of a coincidence, but probably deliberate.
But finally, things are looking the same.
And in fact, if I select all of the columns
from my shows table in that database, I'll
get back not just the titles, but the IDs of the shows,
the year in which they started, as well as the number of episodes.
So in VS Code, I'm going to first go up to the very top
and import one last feature from flask, namely a function called jsonify,
which as the name kind of suggests, it's going to turn into JSON anything
you pass into it.
So for instance, if I pass to it a list, I'm
going to get back a JSON version of that list.
If I pass in a list of dictionaries, I'm going
to get back a JSON version of a list of dictionaries.
In short, it converts whatever is in Python's memory
to the corresponding JavaScript Object Notation.
So let me scroll down now to my search route
and let's make a change as follows.
Let's go into the last line, and instead of rendering a whole template of HTML,
let's actually return the return value of jsonify passing
in all of those shows.
Though, for good measure, let's actually fix a couple of other things as well.
If, for instance, the user did not actually type something in,
we probably don't want to search blindly for some value we know is empty.
So let's actually tweak even this part as follows.
I'm going to go into my search route further.
I'm going to define query.
Whoops.
Query equals request.args.get quote, unquote q.
But then I'm going to ask a question.
If there is in fact a value for that query, then let's go ahead
and query the database for that query but prepend to it a percent sign first,
plus the query itself, plus a percent sign after close parentheses.
Else if there is no query, that is they didn't type in anything at all,
then let's go ahead and specify that the show's list is really empty.
There's no results.
So that at least when it comes time to jsonify that variable,
we're jsonifying either an actual set of results or nothing at all,
but consciously so.
And just to speed things up too, instead of selecting thousands
of shows that might contain the letter O, let's limit this to the top 50,
just to speed things up, even though in the real world,
you'd probably want all of them.
All right.
With that said, let's now go back into our index.html,
which previously was expecting back a snippet of HTML,
namely all of those li tags.
But let's change it now to actually expect a proper JSON response.
In fact, to do so, what I'm going to do is a couple of things.
One, I'm going to tell my JavaScript code-- on line 14
is tell JavaScript to treat that response indeed as JSON and not text,
because what I don't want is a big string.
What I really want in the browser's memory is a proper array of objects.
That is to say, a proper list of dictionaries in the browser's memory.
But after that I don't want to just blindly plug that code
into the inner HTML of the ul.
Rather, I want to build up my HTML myself.
So I'm going to do this as follows.
I'm going to create with let another JavaScript variable called HTML
and set it equal to quote, unquote.
I could use double quotes, but I'm using single quotes for parity
with JavaScript conventions.
But it's just an empty string at this point.
Then I'm going to say in a for loop in JavaScript, for let show of shows--
and this is going to be my way of iterating now over all of those shows.
The of preposition's a little weird in JavaScript,
but this allows me to iterate over each of the objects in that array.
So let's go ahead and do this.
Let me go ahead and append to that HTML string with plus equals
or concatenate a li tag of my own making, followed by that show's title,
followed by a close li tag of my own making.
And then outside of that for loop, let's do document.queryselector quote,
unquote ul to get access to that same empty ul element
that we do still have and change its inner HTML not
to be what came back from the server but my own dynamically
generated HTML instead.
Now, as an aside, I should note that it's possible
that this code might be a little buggy because if the show's title contains
any special characters, like the less than sign
or certain other characters that have special meaning in HTML,
things might very well break, and I should probably
replace any such characters with their corresponding HTML entities.
For now, I'm going to wave my hand at that just
to keep the code relatively simple, but know
that we might need to do that kind of escaping
of the strings we're pasting in.
Let me now go back to my browser here.
Let me reload the page so I get the latest version of the code.
And let me go ahead and type something like O for office.
And there we have it, an unordered list generated not by the server but by me
client side, such that now I can search for O or office or anything else
and all of that is happening now by generating the list items
for that ul within the browser itself.
And in fact, if I reload here and open up my developer tools again via Inspect
and go to the Network tab and search for O, I can click on that row,
and under the Response tab, I can see that I'm not
getting back any HTML, per se.
I'm getting back JSON, albeit pretty printed here.
And in fact, that then reveals to me that, indeed, I'm getting back JSON
and I'm plugging it in to the browser accordingly.
So all that said, it seems that now we have the ability, using HTML and CSS
and JavaScript, with a bit of Python, with a bit of SQL,
can we build full fledged web applications
that increasingly are being used not just on our desktops and laptops,
but also on our phones as well.
In fact, using all of these languages, can you
build a back end and a front end that communicate
with each other to build things like your own freshman intramural website,
your own problem set nine, or, we hope, your own final project.
That's it for CS50.
We will see you back in Sanders Theater one more time.

[MUSIC PLAYING]
