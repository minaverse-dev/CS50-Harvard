[MUSIC PLAYING]

DAVID MALAN: All right.
This is CS50, Harvard University's Introduction
to the Intellectual Enterprises of Computer Science
and the Art of Programming.
My name is David Malan, and I actually took this class myself some years ago,
but I almost didn't.
It was my first year in college and my roommates
and I were living in Matthews Hall, for those familiar.
[CHEERING]
Nice, Matthews.
Our claim to fame, actually, at the time was that our room was literally
Matt Damon's just three years' prior.
So onward from that.
But my first year, I didn't really have the nerves
to set foot in this classroom, let alone computer science.
In fact, for me, computer science, and CS50 in particular,
was very much this class to beware.
Like, I was kind of comfortable with computers,
but I certainly wasn't among those more comfortable with computers.
And so I shied away my first year.
Instead, I actually took a whole lot of classes in government.
In fact, in high school, I was really enjoying history.
I loved this constitutional law class that I
took my senior year of high school.
And so I figured, OK, if that's what I liked in high school
and if that's where my comfort zone was, that's
probably what I should be doing in college.
And so I essentially declared as my concentration or major government
for the first year, year and a half of school.
But my sophomore year when I was living actually in Mather House instead.
OK, no one from Mather.
In Mather House instead, it was--
I sort of followed some friends, I think the first week
of class in September of that year to a class called CS50.
And honestly, once I stepped foot in that classroom,
the professor at the time was a famous computer scientist
by the name of Brian Kernighan, now at Princeton.
Like, I was hooked.
And literally would I go back thereafter on Friday evenings when, at the time,
problem sets were released and sit down at 7:00,
8:00 PM on Friday nights and dive into homework.
Which isn't necessarily something we recommend, per se.
But for me, it was like this sign that, wow, I've sort of found my calling.
I found my classmates here on campus.
And that's not going to be the case for everyone.
Certainly, we have no expectations that after taking one computer science class
that you will or might want to take others.
But what's so empowering about computer science and CS50
in particular is it's so applicable to the broader world,
whether you're in the arts, humanities, social sciences, natural sciences,
or beyond, it's just so applicable the concepts and the practical programming
skills with which you will exit a class like this.
Now it's going to be challenging along the way, and indeed, I put in my time
back in the day, and even I did find it challenging.
And here, for instance, is a photograph of a very famous MIT hack,
so to speak, from down the road, whereby it communicates
that getting an education from MIT is like trying to drink from a fire hose.
Which is to say there's going to be so much information, like so much new stuff
that certainly on any given day of the week,
you're not going to be able to absorb all of it that first time around.
But at the end of the day, it's through that challenge, putting the time in,
that the returns are therefore just so much higher at the end of the course.
And indeed, will you walk out of the course with a much better understanding,
not only of computer science and programming,
but ultimately how to teach yourself new technologies and beyond.
For the next three plus months, will we have teaching fellows,
teaching assistants, course assistants, and myself by your side
guiding you through the course's material.
But the goal by term's end is to take those and leave those training wheels
off so that you're well-equipped to go teach yourself
new ideas beyond the class itself.
Take comfort, though, in knowing that most CS50 students have never
taken a CS course before, and indeed, as per the syllabus,
what ultimately matters in this course is not so much where
you end up relative to your classmates but where you end
up relative to yourself when you began.
And when you began is thus today.
And so consider just how comfortable or uncomfortable
you are with computing, let alone computer science and programming,
particularly if you've never explored either in a classroom before,
and consider the delta just a few months from now that will really
describe how far you have come.
And that is all that matters, not how much
the student to the left or the right, in front or behind you right now, knows.
With that said, let me add some additional inspiration, if I may.
Here's a photograph of my own very first homework assignment in CS50 from 1996,
and I will draw your attention to the fact
that even though this is a so-called hello world program that we'll
play with ourselves next week, it is pretty much literally the shortest,
easiest program you can write in a programming language called C.
I still somehow got minus 2 on my very first homework
assignment, which is to say, we're all going to make mistakes along the way.
But the goal will be to learn and enjoy that process here on out.
At the end of the day, too, like me, you'll
exit with your own proudly held high took
CS50 t-shirt as is our tradition too.
With that said, there are so many other traditions within CS50,
both on campus and off.
And in particular, do we try in CS50 to provide not only the academic support
structure that you might want going through the class,
but also a collective shared community experience.

Which is to say in just a few days we'll start off the term formally
with CS50 Puzzle Day, which is not only an opportunity
to get together with friends, with pizza and prizes
and also logic puzzles of sorts, but really to send the message that computer
science itself is not about programming, it's not about C,
it's not about Python, it's not about programming languages per se,
but about problem solving, ever more so collaboratively with other smart people
by your side in this class or beyond.
며칠 후면 CS50 퍼즐 데이로 학기를 공식적으로 시작하게 됩니다. 
이 행사는 친구들과 함께 피자와 상품을 나눠 먹고 논리 퍼즐을 푸는 기회일 뿐만 아니라, 
컴퓨터 과학 자체가 프로그래밍이나 C, 파이썬, 프로그래밍 언어 그 자체에 관한 것이 아니라, 
이 수업이나 그 이후에 여러분 곁에 있는 똑똑한 사람들과 협력하여 문제를 해결하는 것이라는 메시지를 전달하는 자리입니다.

And indeed, are there, toward the end of the semester, reinforcements
of the same by way of a little something that we call the CS50 Hackathon, which
will be an opportunity overnight to dive into your own final projects,
the capstone of this course, thereafter followed by the CS50 fair,
which will be a campus wide exhibition for students, faculty,
and staff across campus of your very own final projects, be it your very own web
app or mobile app or anything else you decide to create by term's end.
그리고 실제로 학기 말에는 CS50 해커톤이라는 작은 행사를 통해 동일한 내용을 강화할 수 있습니다. 
이 해커톤은 이 과정의 핵심인 최종 프로젝트를 하룻밤 동안 심도 있게 살펴볼 수 있는 기회입니다. 
그 후에는 CS50 박람회가 열립니다. 
박람회는 캠퍼스 전역의 학생, 교수진, 직원들을 대상으로 학기 말에 직접 만든 최종 프로젝트를 전시하는 행사입니다. 
학기 말에 직접 만든 웹앱이든 모바일 앱이든, 아니면 다른 어떤 것이든 상관없습니다.

And indeed, the objective at the end of the day,
truly with that final project in particular,
is going to be to create for yourselves, for your classmates,
for attendees, something that we didn't even teach you how to do.
And indeed, that will signal ultimately that you're indeed on your way
and ready.
그리고 실제로, 이 마지막 프로젝트의 최종 목표는
특히 마지막 프로젝트에서
여러분 자신과 반 친구들, 그리고 참석자들을 위해, 우리가 가르쳐 주지도 않은 무언가를 만들어내는 것입니다.
그리고 그것은 궁극적으로 여러분이 진정으로 출발선에 섰고
준비되었다는 신호가 될 것입니다.

Toward that end, thought we would give you a sense of CS50's past
by way of this short video, if we could dim
the lights, that paints a picture of all that awaits here and beyond.
그러한 목적을 위해, 이 짧은 영상을 통해 CS50의 과거를 여러분께 보여드리고자 합니다.
조명을 어둡게 하면
여기와 그 너머에서 우리를 기다리는 모든 것을 그려낼 수 있을 것입니다.
[VIDEO PLAYBACK]
[MUSIC PLAYING]

[END PLAYBACK]
DAVID MALAN: 
All right, so welcome aboard to CS50 and computer science
itself.
So what is computer science?
Well, put simply, it's the study of information.
Like, how do you represent it and how do you process it.
But more fundamentally, what we'll teach you in this class
is computational thinking.
That is to say, the application of ideas from computer science
to problems of interest to us within the class and problems of interest to you
after the class.
좋습니다. CS50과 컴퓨터 과학에 오신 것을 환영합니다.
그 자체로요.
그럼 컴퓨터 과학이란 무엇일까요?
간단히 말해서, 정보를 연구하는 학문입니다.
예를 들어, 정보를 어떻게 표현하고 처리하는지 말입니다.
하지만 더 근본적으로, 이 수업에서 여러분께 가르쳐 드릴 것은
컴퓨팅 사고력입니다.
즉, 컴퓨터 과학의 아이디어를
수업 중 저희가 관심 있는 문제와 수업 후 여러분이 관심 있는 문제에 적용하는 것입니다.

And so at the end of the day, what computer science really
is is about problem solving, ergo that sort of global applicability.
And by problem solving, we mean something quite simple.
In fact, we can distill it as follows with this mental image.
This is problem solving.
You've got some problem to solve, thus known as the input
that you want to solve.
결국 컴퓨터 과학의 본질은
문제 해결, 즉 전 세계적인 적용 가능성에 관한 것입니다.
문제 해결이란 아주 단순한 것을 의미합니다.
사실, 이 심상(心象)을 통해 다음과 같이 요약할 수 있습니다.
이것이 바로 문제 해결입니다.
해결해야 할 문제, 즉 해결하려는 입력이 있습니다.
이것을 입력이라고 합니다.

And the goal, of course, to problem solving
is to actually produce a solution.
So the output in this model would be the solution.
The interesting part ultimately is going to be in how you process that input
and turn it into that output, ergo solving problems.
But before we can do that, we all kind of have to agree how to represent
sent these inputs and outputs, especially
if we want to do it in a standardized global way using literally computers,
be them laptops, desktops, phones, or most any other kind
of electronic device nowadays.
물론 문제 해결의 목표는
실제로 해결책을 도출하는 것입니다.
따라서 이 모델의 출력은 해결책이 됩니다.
궁극적으로 흥미로운 부분은 입력을 어떻게 처리하고
출력으로 전환하여 문제를 해결하는지에 있습니다.
하지만 그러기 전에, 특히 노트북, 데스크톱, 휴대폰, 또는 
요즘 대부분의 전자 기기 등 컴퓨터를 사용하여 표준화된 글로벌 방식으로 
입력과 출력을 표현하는 방법에 대해 모두 합의해야 합니다.

So how can we do that?
Well, there's different ways to represent information in the world.
For instance, if I were to take attendance old school style, maybe
in a smaller room, I might do 1, 2, 3, 4, 5, 6, 7,
and so forth and just count people on my human hands.
That's actually known as unary notation, otherwise mathematically known
as base one, because you're using your fingers literally
in this model as digits.
그럼 어떻게 할 수 있을까요?
세상에는 정보를 표현하는 다양한 방법이 있습니다.
예를 들어, 옛날 방식대로 출석을 한다면,
작은 방에서 1, 2, 3, 4, 5, 6, 7
등등으로 계산하고 손으로 사람 수를 세는 겁니다.
이를 실제로 단항 표기법이라고 하며, 수학적으로는
1진법이라고도 합니다. 이 모델에서는 손가락을 문자 그대로 숫자로 사용하기 때문입니다.

But a little quick question.
How high can you count with one human hand?
Five is incorrect if you use a different base system than one.
So it's obviously correct if you're just using unary and just counting 1, 2, 3,
4, 5.
잠깐 질문 하나 드릴게요.
사람은 한 손으로 몇 까지 셀 수 있나요?
5는 1이 아닌 다른 기수법을 사용하면 틀립니다.
따라서 단항식을 사용해서 1, 2, 3,
4, 5만 세면 당연히 맞습니다.

But I dare say I can come up with more patterns in my human hand
alone that would enable me, without a second hand or a couple of feet,
to count higher than five.
In fact, maybe for those more comfortable,
how high could you actually count on a single human hand, perhaps?
So 31, believe it or not, is, in fact, the correct answer.
하지만 감히 말씀드리자면, 제 손만으로도 더 많은 패턴을 만들어낼 수 있을 겁니다.
초침이나 발이 없어도
다섯보다 더 많이 셀 수 있을 겁니다.
사실, 더 편하게 생각하시는 분들을 위해 말씀드리자면,
사람 손 하나로 실제로 얼마나 높이 셀 수 있을까요?
그러니 믿거나 말거나, 31이 정답입니다.

But why?
Well, here I initially started pretty naively.
1, 2, 3, 4, 5.
And I just combined all of my fingers and counted the collective total.
But what if I'm a little more clever and take into
account the pattern of fingers that go up.
So maybe this is still zero.
This is one.
하지만 왜 그럴까요?
음, 처음에는 꽤 순진하게 시작했어요.
1, 2, 3, 4, 5.
그리고 그냥 모든 손가락을 합해서 총합을 세었죠.
하지만 제가 좀 더 영리하게
손가락이 올라가는 패턴을 고려한다면 어떨까요?
그럼 이건 아직 0일지도 몰라요.
이건 1이에요.

But now maybe we just agree universally that this is two.
Even though it's just my single pointer finger.
Maybe we all just agree that this is three with two fingers up.
Maybe we agree that this is often offensive with just one
middle finger up, but this would then be four.
This could then be five.
This could then be six.
This could be seven.
And if I keep permuting my fingers in this way-- allow me to spoil it--
this would be, in fact, 31.
하지만 이제 우리는 아마도 이것이 두 개라는 데에 만장일치로 동의할지도 모릅니다.
비록 제 검지 손가락이 하나뿐이지만요.
어쩌면 우리 모두 이것이 두 손가락을 올린 세 개라는 데에 동의할지도 모릅니다.
어쩌면 우리는 이것이 가운데 손가락 하나만 올린 것이 종종 불쾌하게 여겨진다는 데에 동의할지도 모릅니다.
하지만 그렇다면 이것은 네 개가 될 것입니다.
그렇다면 이것은 다섯 개가 될 수도 있습니다.
그렇다면 이것은 여섯 개가 될 수도 있습니다.
이것은 일곱 개가 될 수도 있습니다.
그리고 제가 이렇게 손가락을 계속 바꾼다면—스포일러를 드리겠습니다——사실 이것은 31개가 될 것입니다.

But again, why?
But the difference here is that we're no longer using unary or base
one as a mathematician would say, but rather base two.
Because if we take into account not just the total number
of fingers that I'm using, but whether each finger is down or up being
therefore in two potential states.
하지만 다시 한번, 왜 그럴까요?
하지만 여기서 차이점은 우리가 더 이상 단항식이나 일진법을 사용하지 않는다는 것입니다.
수학자들이 말하듯이 일진법은 아닙니다. 오히려 이진법을 사용합니다.
사용하는 손가락의 총 개수뿐만 아니라
각 손가락이 아래로 향하는지 위로 향하는지까지 고려하면
따라서 두 가지 잠재적인 상태에 있게 됩니다.

Down, up, A, B, black, white, however you
want to distinguish those two states of the world,
you're now operating what's called base two, and perhaps more familiarly,
even if you're not a computer person per se, this is the so-called binary system.
And odds are, even if you're not a computer science person at all,
you probably generally know that computers only understand or speak
what alphabet, so to speak?
아래, 위, A, B, 검정, 흰색, 어떻게든
세상의 두 상태를 구분하고 싶으시다면,
이제 2진법을 사용하고 계시고, 어쩌면 더 익숙하게도
컴퓨터 전문가가 아니더라도, 이것은 소위 이진법입니다.
그리고 컴퓨터 과학 전문가가 아니더라도
컴퓨터가 이해하거나 말할 수 있는 것은
이를테면 어떤 알파벳뿐이라는 것을 일반적으로 알고 계실 겁니다.

So ones and zeros, zeros and ones, otherwise known as the binary system.
And in fact, there's a term of art here that's worth noting.
When you're using zeros and ones, which, of course, are a total of two digits,
you have binary digits, so to speak-- bi implying two,
which means there's two possibilities, zero or one.
If we actually get rid of some of these letters and then join these two phrases,
here you have a technical term that is a bit.
A bit is just a binary digit, which is to say it's a zero or one.
And this is in contrast, of course, with the system
you and I know as the decimal system.
Dec implying 10, because in the real world
you and I daily use zero through nine, which is 10 possibilities.
Computers only use zero and one, that is to say two bits,
to represent information instead.
1과 0, 0과 1은 이진법이라고도 합니다.
사실, 여기서 주목할 만한 전문 용어가 있습니다.
0과 1을 사용할 때, 물론 두 자리 숫자가 있는데,
이진수라고 할 수 있습니다. bi는 두 개를 의미하는데,
즉, 0과 1, 두 가지 가능성이 있다는 뜻입니다.
이 두 글자를 일부 제거하고 두 문구를 합치면
비트라는 기술 용어가 나옵니다.
비트는 단지 이진수, 즉 0 또는 1입니다.
물론 이것은 우리가 알고 있는 십진법과는 대조적입니다.
Dec는 10을 의미합니다. 현실 세계에서 우리는 매일 0부터 9까지 사용하는데, 이는 10가지 가능성이 있기 때문입니다.
컴퓨터는 정보를 표현하기 위해 0과 1, 즉 두 비트만 사용합니다.

So how do we represent this information, especially when at the end
of the day what we're using are indeed computers and electronic devices?
Well, if I want to represent zero, I can actually think of this as analogous
to the physical world.
그렇다면 이 정보를 어떻게 표현할 수 있을까요? 특히
결국 우리가 사용하는 것이 컴퓨터와 전자 기기라면 더욱 그렇습니다.
음, 0을 표현하고 싶다면, 이를 물리적 세계와 비유적으로 생각해 볼 수 있습니다.

Maybe I have a light bulb that's off or on controlled
by a switch that turns it off or on.
So you can think of a binary digit that is a zero as really
just being a light bulb that is off.
By contrast, if you think of a one in the digital world as, of course,
being the second of two possibilities, you
can think of that in the human or analog world, the physical world,
as being a light bulb that is on.
And in fact, what's inside of your Mac, your PC, your Android phone,
your iPhone are millions of tiny little light switches
known as transistors that just can be turned on or off, on or off.
어쩌면 스위치로 켜고 끌 수 있는 전구가 있을지도 몰라요.
스위치로 켜고 끌 수 있죠.
그러니까 0인 이진수는
사실 그냥 꺼진 전구라고 생각하면 됩니다.
반대로 디지털 세계에서 1을 두 가지 가능성 중 두 번째라고 생각하면,
물론 인간이나 아날로그 세계, 즉 물리적 세계에서는
전구가 켜져 있는 것처럼 생각할 수 있습니다.
사실 여러분의 맥, PC, 안드로이드 폰,
아이폰 안에는 수백만 개의 작은 스위치가 있습니다.
트랜지스터라고 불리는 이 스위치는 켜고 끌 수 있습니다.

And essentially, you can use those transistors to store information
because if you want to store a zero, you turn one of those switches off.
If you want to store a one, you turn one of those switches on.
Of course, that sort of invites the question, well,
how do we count higher than zero or one?
Well, we would seem to need to use more than just
maybe a single bit, a single light bulb.
So if we wanted to count higher than, for instance, zero or one,
why don't we go ahead and maybe do this?
So just so I have some place to put these,
let me borrow some of our actual physical light bulbs
here from the stage.
그리고 본질적으로, 이 트랜지스터를 사용하여 정보를 저장할 수 있습니다.
왜냐하면 0을 저장하려면 스위치 중 하나를 끄면 되고,
1을 저장하려면 스위치 중 하나를 켜면 됩니다.
물론, 이렇게 하면 이런 질문이 생깁니다.
0이나 1보다 더 큰 값을 어떻게 셀 수 있을까요?
음, 우리는 더 많은 것을 사용해야 할 것 같습니다.
아마도 하나의 비트, 하나의 전구 정도일 겁니다.
예를 들어 0이나 1보다 더 큰 값을 셀 수 있다면
이렇게 하면 어떨까요?
그래서 이것들을 저장할 공간을 마련하기 위해
무대에서 실제 전구를 빌려오겠습니다.

And let me propose that now, with three bits on the stage, three light switches,
three transistors, whatever metaphor you're most comfortable with, this
is how a computer would represent a zero, because all of them are off.
So it's off, off, off.
But if a computer wanted to count to one, we could do naively this.
We could turn this on.
If the computer wanted to turn represent two, we could do this.
And if a computer wanted to represent three, we could do this.
But I'm kind of painting myself into a corner
and not using these light bulbs as cleverly as I could,
because at the moment I've only counted as high as three.
So if I want to count to four, to five, to six,
I'm going to need more and more light bulbs.
Can we be a little more clever?
Well, again, someone else who's among those more comfortable, what's
the spoiler here?
How high using binary zeros and ones could I
count with three light bulbs total?
In back?
Yeah.
So seven here is the answer.
자, 이제 무대 위에 세 개의 비트, 세 개의 전등 스위치, 세 개의 트랜지스터, 어떤 비유든 여러분이 가장 편하게 받아들이는 것을 생각해 보세요.
컴퓨터가 0을 표현하는 방식은 바로 이것입니다. 왜냐하면 모든 비트가 꺼져 있기 때문입니다.
그러니까 꺼짐, 꺼짐, 꺼짐이죠.
하지만 컴퓨터가 1까지 세고 싶다면, 우리는 순진하게 이렇게 할 수 있습니다.
이것을 켜면 됩니다.
컴퓨터가 2를 표현하고 싶다면, 이렇게 하면 됩니다.
그리고 컴퓨터가 3을 표현하고 싶다면, 이렇게 하면 됩니다.
하지만 저는 스스로를 구석에 몰아넣고 있습니다.
그리고 이 전구들을 최대한 영리하게 사용하지 못하고 있습니다.
지금까지 3까지만 세었으니까요.
그러니까 4, 5, 6까지 세고 싶다면,
전구가 점점 더 많이 필요할 겁니다.
좀 더 영리하게 생각해 볼까요?
음, 다시 한번, 좀 더 편하게 생각하는 사람 중에 한 명, 여기서 스포일러가 뭐죠?
이진수 0과 1을 사용하면 전구 세 개로
얼마나 높이 셀 수 있을까요?
뒤에?
네.
그래서 답은 여기 7이에요.

And if that, too, you're sort of wondering,
how are people figuring out 31 and 7?
That's the goal at hand here.
So let me do this.
Let me turn all of these off again so that my three light bulbs or switches
again represent zero.
And the first one's easy.
This is how a computer would represent the number one.
It would be on, off, off.
How, though, is a computer going to represent two?
Well, just like my proposed finger example.
Let's do this.
Let's turn this one off and this one on.
That is how a computer would represent two.
By saying off, on, off.
In other words, 010 would be the way to pronounce it digitally.
What if I instead want to represent three?
That's how on my finger I did this, with two fingers.
Well, I'm going to turn this one on.
This is three.
그리고 그것도 궁금하시다면,
사람들은 어떻게 31과 7을 알아낼까요?
그게 바로 지금의 목표입니다.
자, 이렇게 해 봅시다.
이 모든 것을 다시 꺼서 제 전구나 스위치 세 개가
다시 0을 나타내도록 해 봅시다.
첫 번째는 쉽습니다.
컴퓨터가 숫자 1을 표현하는 방식입니다.
켜짐, 꺼짐, 꺼짐입니다.
하지만 컴퓨터가 2를 어떻게 표현할까요?
제가 제안한 손가락 예시처럼요.
이렇게 해 봅시다.
이것을 끄고 이것을 켜 봅시다.
컴퓨터가 2를 표현하는 방식입니다.
꺼짐, 켜짐, 꺼짐이라고 말하는 거죠.
즉, 010은 디지털 방식으로 발음하는 방식입니다.
만약 제가 3을 표현하고 싶다면 어떻게 해야 할까요?
제 손가락에서는 두 손가락으로 이렇게 했습니다.
음, 이것을 켜 보겠습니다.
이것이 3입니다.

Now, this will, for those less comfortable, be non-obvious.
This now is how I would represent the number four.
This is how I would represent five.
This is how I would represent six.
And this, as per the spoiler, is how I would represent seven.
So perhaps very non-obvious what it was I just did
or why I chose those patterns.
But I dare say if you rewind in your mind's eye or literally later on video,
you'll find that I actually did show you eight distinct patterns of light bulbs.
The first one was off, off, off.
The last one was, on, on, on.
And there were another six total in between then.
Well, wait, why seven?
Well, if you start counting at zero and I claim there's eight possibilities,
you can only count from zero to seven, as we will soon see.
So how are these patterns coming about and what is it
that our computers are actually doing?
Well, it's actually doing something a little like this, quite like in decimal.
So in the human world, you and I are very
much in the habit of using base 10, zero through nine, a.k.a.
Decimal.
Well, how do we use it instinctively as humans?
Well, what's this number obviously on the screen?
123.
But why is it 123?
Like, for years you haven't really thought
about why this pattern of symbols or digits on the screen,
one, two, three, represents mathematically this number
that you know obviously as 123.
자, 불편하신 분들을 위해 설명드리자면, 명확하지 않을 수 있습니다.
제가 숫자 4를 표현하는 방식은 다음과 같습니다.
5를 표현하는 방식은 다음과 같습니다.
6을 표현하는 방식은 다음과 같습니다.
그리고 스포일러에 따르면, 7을 표현하는 방식입니다.
그래서 제가 방금 한 일이 무엇인지, 왜 그런 패턴을 선택했는지는 아마도 매우 명확하지 않을 것입니다.
하지만 마음속으로 또는 나중에 영상을 되감기면
제가 실제로 여덟 가지 전구 패턴을 보여드렸다는 것을 알게 되실 겁니다.
첫 번째 패턴은 꺼짐, 꺼짐, 꺼짐이었습니다.
마지막 패턴은 켜짐, 켜짐, 켜짐이었습니다.
그리고 그 사이에 총 여섯 가지 패턴이 더 있었습니다.
잠깐만요, 왜 일곱일까요?
음, 0부터 세기 시작하고 제가 여덟 가지 가능성이 있다고 한다면
곧 알게 되겠지만, 0부터 일곱까지만 셀 수 있습니다.
그럼 이러한 패턴은 어떻게 생겨나고, 우리 컴퓨터는 실제로 무엇을 하고 있을까요?
음, 사실 십진법과 비슷한 원리를 가지고 있습니다.
인간 세계에서 우리는 0부터 9까지 10진법을 사용하는 습관이 아주 많습니다.
십진법이죠.
인간으로서 본능적으로 어떻게 사용할 수 있을까요?
화면에 보이는 이 숫자는 무엇일까요?
123입니다.
그런데 왜 123일까요?
아마도 몇 년 동안 여러분은 화면에 보이는 이 기호나 숫자 패턴,
1, 2, 3이 왜 수학적으로 123이라는 숫자를 나타내는지 생각해 보지 못했을 겁니다.
당연히 123이라고 알고 있는 숫자죠.

But if you rewind to grade school, odds are,
like me, you were taught that the rightmost digit is in the ones column,
this second digit is in the tens column, this digit is in the hundreds column,
and so forth.
So even though none of us have to do this math explicitly,
what you're instantly doing is 100 times 1 plus 10 times
2 plus 1 times 3, which gives you 100 plus 20 plus 3.
Oh, that's why it is 123, because these digits in this order
have that significance.
The digits to the left have more weight, so to speak,
than the digits to the right.
So what can we take away from this?
Well, let's generalize it first as just any three digit number.
So number, number, number.
The ones column, the tens column, the hundreds column.
But there's some math going on there, and it's not particularly sophisticated.
Those are actually powers of 10.
So 10 to the 0, 10 to the 1, 10 to the 2, and there's your decimal system.
Because the base in this value is a 10, that's
because there's 10 possibilities for each of those placeholders,
zero through nine.
하지만 초등학교 시절로 돌아가 보면,
저처럼 여러분도 가장 오른쪽 숫자는 일의 자리,
두 번째 숫자는 십의 자리,
이 숫자는 백의 자리,
이런 식으로 배웠을 겁니다.
그래서 우리 중 누구도 이 계산을 명확하게 할 필요는 없지만,
즉시 100 곱하기 1 더하기 10 곱하기
2 더하기 1 곱하기 3, 즉 100 더하기 20 더하기 3이 되는 거죠.
아, 그래서 123인 거군요. 이 순서대로 나열된 숫자들이
그 의미를 갖기 때문입니다.
왼쪽 숫자가 오른쪽 숫자보다 더 큰 의미를 지닙니다.
그렇다면 여기서 무엇을 얻을 수 있을까요?
우선 세 자리 숫자로 일반화해 봅시다.
그러니까 숫자, 숫자, 숫자.
일의 자리, 십의 자리, 백의 자리.
하지만 여기에는 약간의 수학적 계산이 들어가 있고, 특별히 정교하지는 않습니다.
사실 이것들은 10의 거듭제곱입니다.
즉, 10의 0승, 10의 1승, 10의 2승, 이것이 십진법입니다.
이 값의 밑이 10이므로
각 자리 표시자에는 0부터 9까지 10가지 경우가 있습니다.
But in the binary world, in the world of computers where all they
have are zeros and ones, why?
Because all they have physically is transistors.
Tiny, tiny, tiny light bulbs that can be off or on.
If you only have two digits to play with,
the 10 base should, of course, become a two base.
And now if we do some math here, 2 to the 0, 2 to the 1, and 2 to the 2,
you get the ones column, the twos column, the fours column.
And if we keep going 8, 16, 32, 64, 128 and so forth,
its powers of 2 instead of powers of 10.
But this is to say computers represent information
in exactly the same way you and I have since childhood,
but they have fewer digits at their disposal,
so these columns need to be weighted differently.
So we can still count from zero all the way up toward infinity.
So what does this mean?
Well, here we have three bits on the screen, 000.
If we were to convert this now mentally or on paper pencil to decimal,
how do we do it?
Well, 4 times 0 plus 2 times 0 plus 1 times 0.
That gives us the mathematical number you and I know as zero.
That was three light bulbs.
Off, off, off.
하지만 이진법 세계에서, 컴퓨터의 세계에서는
0과 1만 있는데, 왜 그럴까요?
물론 컴퓨터의 물리적인 것은 트랜지스터뿐이기 때문입니다.
켜고 끌 수 있는 아주 아주 아주 작은 전구 말입니다.
만약 두 자릿수만 사용할 수 있다면
10진법은 당연히 2진법이 되어야 합니다.
그리고 이제 2의 0승, 2의 1승, 2의 2승을 계산해 보면
1의 열, 2의 열, 4의 열이 나옵니다.
그리고 8, 16, 32, 64, 128 등으로 계속 계산하면
10의 거듭제곱이 아니라 2의 거듭제곱이 됩니다.
하지만 이는 컴퓨터가 정보를 표현하는 방식이
우리가 어린 시절부터 해왔던 것과 똑같다는 것을 의미합니다.
하지만 컴퓨터는 사용할 수 있는 자릿수가 더 적기 때문에
이 열들의 가중치를 다르게 적용해야 합니다.
그래서 우리는 여전히 0부터 무한대까지 셀 수 있습니다.
그럼 이게 무슨 뜻일까요?
화면에 세 비트, 000이 있습니다.
이제 이걸 머릿속으로, 또는 종이나 연필로 십진수로 변환하려면 어떻게 해야 할까요?
음, 4 곱하기 0 더하기 2 곱하기 0 더하기 1 곱하기 0입니다.
이렇게 하면 우리가 아는 수학적인 숫자인 0이 나옵니다.
전구 세 개가 켜진 것과 같습니다.
꺼짐, 꺼짐, 꺼짐.

Well, what if we turn on one light bulb all the way on the right?
What decimal number does this binary number, 001 represent?
Just one, because it's 4 times 0, 2 times 0, 1 times 1.
Here's where things got more interesting,
even if non-obvious in light bulb form or even physical hand form.
010 in binary is what in decimal?
Two, because it's 2 times 1 and that's it.
011 in binary is, of course now three.
This is now four.
This is now five.
This is now six and seven.
On, on, on or 111 is the highest we can count with these three bits.
All right.
음, 전구 하나를 가장 오른쪽에 켠다면 어떨까요?
이 이진수 001은 몇 십진수를 나타낼까요?
4 곱하기 0, 2 곱하기 0, 1 곱하기 1이기 때문에 1입니다.
여기서 더 흥미로운 점이 있습니다.
전구 형태나 심지어 손 모양으로는 명확하지 않더라도 말입니다.
이진수 010은 십진수로는 무엇일까요?
2입니다. 2 곱하기 1이면 끝입니다.
이진수 011은 물론 이제 3입니다.
이것은 이제 4입니다.
이것은 이제 5입니다.
이것은 이제 6과 7입니다.
켜짐, 켜짐, 켜짐 또는 111이 이 세 비트로 셀 수 있는 가장 높은 값입니다.
좋습니다.

So how might a computer intuitively count as high as eight?
What do you need to do, presumably?
You're going to need to add a bit.
So you need another light bulb, another switch.
You need more memory, so to speak, to use nomenclature
with which you're probably familiar.
So in fact, if we change all of those to zero
but we give ourself one more bit for a total of four,
that's got to be the eighth place because there's just
another power of two.
So 1000 is the decimal number eight.
You don't say 1,000 in binary.
You literally say 1000.
But that is the number you and I know as eight.
And you can keep going up and up and up.
And how then computers with Excel or any kind of number crunching software
count really high and keep track of really big numbers?
The computer just throws more and more transistors at it, more and more
bits to count higher and higher and higher than this.
It turns out, though, one bit, three bits, even four bits
aren't that useful in practice because literally you can count
as high as seven or maybe 15 or 31.
So more commonly, as is commonly known, is to use a byte of bits instead.
How many bits is in a byte, for those familiar?
So it's just eight.
Why eight?
It's just more useful than one or two or three or some other number.
And as an aside, it happens to be a power of two, which
is just useful electronically as well.
So a byte then is just 8 bits.
그렇다면 컴퓨터는 어떻게 직관적으로 8까지 셀 수 있을까요?
아마도 어떻게 해야 할까요?
조금 더 추가해야 할 겁니다.
그러면 전구가 하나 더 필요하고, 스위치도 하나 더 필요합니다.
이를테면, 아마 익숙한 용어를 사용하려면 더 많은 메모리가 필요할 겁니다.

그래서 사실, 이 모든 것을 0으로 바꾸고
한 비트를 더해서 4가 되면
8번째 자리가 됩니다. 왜냐하면
2의 거듭제곱이 하나 더 생기니까요.

그래서 1000은 십진수 8입니다.
1,000을 이진수로 표현하지 않습니다.
말 그대로 1000이라고 표현합니다.
하지만 1000은 우리가 아는 8입니다.
그리고 계속해서 더할 수 있습니다.
그렇다면 엑셀이나 다른 숫자 처리 소프트웨어가 있는 컴퓨터는 어떻게
정말 높은 숫자를 세고 아주 큰 숫자를 추적할까요?
컴퓨터는 점점 더 많은 트랜지스터를 집어넣고, 점점 더 많은 비트를 더 높은 비트로 세어 나갑니다.
하지만 1비트, 3비트, 심지어 4비트조차도 실제로는 그다지 유용하지 않습니다.
말 그대로 7개, 어쩌면 15개, 31개까지 셀 수 있기 때문입니다.
따라서 흔히 알려진 대로, 더 일반적으로는 1바이트의 비트를 사용하는 것입니다.
익숙하신 분들을 위해 설명드리자면, 1바이트는 몇 비트일까요?
그럼 8입니다.
왜 8일까요?
1, 2, 3 또는 다른 숫자보다 더 유용할 뿐입니다.
그리고 덧붙이자면, 1바이트는 2의 거듭제곱인데,
전자적으로도 유용합니다.
그러니까 1바이트는 8비트입니다.

And here are those columns I rattled off off the top of my head.
Here is how a computer would represent zero in decimal,
but using eight binary digits or bits.
Little trivia.
And again, this is not what computer science is about,
but it helps to know the lower bounds and the upper bounds
of these kinds of values.
How high can you count with 8 bits or 1 byte if this is zero?
Yeah.
So it's actually 255.
So if I were to change all of these zeros to ones
and then do some quick mental or calculator math, 128 plus 64
plus 32, 16, 8, 4, 2, and 1 would actually give me 255 total.
Plus 0, which gives me 256 total possibilities.
So this is only to say-- this is not, again, the kind of math
will frequently do, but you'll commonly see
in the computer world and programming world powers of two,
numbers like 255, 256.
Why?
Because these are the common units of measures that systems tend to use.
So let me pause here and see, with respect to binary, zeros,
and ones, transistors and the like, any questions or confusion we can clear up?
Oh, really good question.
자, 여기 제가 머리 속에서 툭툭 뱉어낸 열들이 있습니다.
컴퓨터가 십진법으로 0을 표현하는 방법은 다음과 같습니다.
하지만 8개의 이진수(비트)를 사용합니다.
작은 잡학 지식입니다.
다시 말하지만, 이건 컴퓨터 과학의 본질은 아니지만
이런 종류의 값의 하한과 상한을 아는 것이 도움이 됩니다.
이 값이 0이라면 8비트 또는 1바이트로 얼마나 세어 볼 수 있을까요?
네.
그래서 실제로는 255입니다.
그러니 이 모든 0을 1로 바꾸고
암산이나 계산기로 간단히 계산해 보면, 128 더하기 64
더하기 32, 16, 8, 4, 2, 1은 총 255가 됩니다.
더하기 0이면 총 256가지 가능성이 있습니다.
그러니까 이 말은, 다시 말하지만, 이건 흔히 쓰이는 종류의 수학은 아니지만
컴퓨터 세계와 프로그래밍 세계에서 흔히 볼 수 있는 2의 거듭제곱, 255, 256 같은 숫자 말입니다.
왜 그럴까요?
이것들은 시스템에서 흔히 사용하는 측정 단위이기 때문입니다.
자, 여기서 잠깐 멈추고 이진수, 0과 1, 트랜지스터 등과 관련하여
혹시 궁금한 점이나 혼동되는 부분이 있으면 말씀해 주시겠어요?
아, 정말 좋은 질문입니다.왜 전압을 가지고 놀아서 비트가 0%, 50%, 100%가 아니라 그냥 켜지거나 꺼지는 걸까요?
그럼 전압 추론이 사실 맞는 건가요?
컴퓨터가 일반적으로 하는 일이 바로 그것입니다.
아마도 0볼트 정도로 0을 표현하고, 5볼트 정도로 1을 표현하는 걸까요?
컴퓨터에서 극단적인 표현을 하는 건 정말 쉽습니다.
전압 레벨 범위를 나누기 시작하면
전기를 조금이라도 기억하는 사람들에게는
정확하게 표현하기가 점점 더 어려워집니다.
그리고 너무 모호하게 생각하면
0을 1, 2, 3으로 착각할 수도 있습니다.
그래서 이진법을 사용하는 게 더 간단하다는 겁니다.
하지만 3진법 컴퓨터라는 컴퓨터가 있는데,
이진법과 10진법 사이 어딘가에 있는 0, 1, 2라는 세 가지 값을 사용합니다.
물론 다른 것도 할 수 있습니다.
그냥 켜고 끄는 게 간단해요.
혹시나 해서 말씀드리는데, 과장해서 컴퓨터를 끄고 싶진 않지만
전원 플러그를 뽑으면 문자 그대로 전원이 꺼질 수 있어요. 다시 말해,
0이 되죠.
다시 꽂으면 1이 되죠.
정말 깔끔하고 간단하죠.
다른 질문이나 혼란스러운 점이 있으면 해결해 주시면 감사하겠습니다.
아니요?
네.

Why are bits just on or off instead of maybe sort of 0%, 50%, 100%
by playing with voltages?
So the voltage inference of yours is actually correct.
That's what computers typically do.
Maybe they use 0-ish volts to represent 0, maybe 5-ish volts to represent 1.
It turns out it's just really easy to do extremes in computers.
If you start to split that range of voltage levels,
for those who remember any of their electricity,
it just gets harder and harder to be exact.
And if you get things a little too murky,
you might mistake a zero for a one or a two or a three.
So it turns out it's just simpler to use the binary system.
But there do exist computers known as ternary computers that actually
use three values, zero, one, and two, which is somewhere, of course,
between binary and decimal.
But you can do different things.
It's just simple on and off.
In case in point, I don't want to really be dramatic and turn off my computer,
but if I pulled out the power plug, that could be off, literally, a.k.a.
zero.
Plug it back in, that's a one.
There's just a cleanliness and simplicity to that.
Other questions or confusion that we can clear up?
No?
OK.
왜 전압을 가지고 놀아서 비트가 0%, 50%, 100%가 아니라 그냥 켜지거나 꺼지는 걸까요?
그럼 전압 추론이 사실 맞는 건가요?
컴퓨터가 일반적으로 하는 일이 바로 그것입니다.
아마도 0볼트 정도로 0을 표현하고, 5볼트 정도로 1을 표현하는 걸까요?
컴퓨터에서 극단적인 표현을 하는 건 정말 쉽습니다.
전압 레벨 범위를 나누기 시작하면
전기를 조금이라도 기억하는 사람들에게는
정확하게 표현하기가 점점 더 어려워집니다.
그리고 너무 모호하게 생각하면
0을 1, 2, 3으로 착각할 수도 있습니다.
그래서 이진법을 사용하는 게 더 간단하다는 겁니다.
하지만 3진법 컴퓨터라는 컴퓨터가 있는데,
이진법과 10진법 사이 어딘가에 있는 0, 1, 2라는 세 가지 값을 사용합니다.
물론 다른 것도 할 수 있습니다.
그냥 켜고 끄는 게 간단해요.
혹시나 해서 말씀드리는데, 과장해서 컴퓨터를 끄고 싶진 않지만
전원 플러그를 뽑으면 문자 그대로 전원이 꺼질 수 있어요. 다시 말해,
0이 되죠.
다시 꽂으면 1이 되죠.
정말 깔끔하고 간단하죠.
다른 질문이나 혼란스러운 점이 있으면 해결해 주시면 감사하겠습니다.
아니요?
네.

So if you're in agreement for the moment that, OK, using just zeros and ones,
we can represent any number we want from zero on up, let
me propose that we do more useful things with our computers and our pockets
and desktops and laps like represent letters,
for the sake of Google Docs, Microsoft Word, or any kind of text
that we might want to write.
So knowing now that computers only contain or only use zeros and ones,
and therefore only contain hardware like transistors,
how could you represent something like a capital letter
A in English inside of a computer?
Which, of course, is not a number anymore.
Like, what could we do?
Yeah?
0과 1만 사용해서 0부터 원하는 숫자를 표현할 수 있다는 데 동의하신다면,
저는 컴퓨터와 주머니, 데스크톱, 노트북을 이용해서 글자를 표현하는 등 더 유용한 것들을 제안하고 싶습니다.
Google Docs, Microsoft Word, 또는 우리가 쓰고 싶은 어떤 종류의 텍스트든 말이죠.
그럼 이제 컴퓨터는 0과 1만 포함하거나 사용한다는 것을 알고,
따라서 트랜지스터 같은 하드웨어만 포함하고 있다는 것을 알면,
컴퓨터 안에서 대문자 A 같은 것을 어떻게 표현할 수 있을까요?
물론 A는 더 이상 숫자가 아니죠.
어떻게 할 수 있을까요?
네?

AUDIENCE: We could use the alphabet and then use numbers.
DAVID MALAN: OK, yeah.
So we could take the alphabet A through Z in English
and we could just assign each letter A number.
And honestly, that is not only the correct answer,
it's really the only answer.
Because at the end of the day, if all you
have are zeros and ones available to you,
that is the entirety of the potential solution to this problem.
So it turns out that, yes, capital letter A, some years ago,
was decided by a bunch of people in a room shall be represented
with this pattern of zeros and ones.
01000001.
And now, trained as you are to do a bit of quick binary
math, what decimal number is used to represent apparently capital A?
So 65, because that's 64 plus 1 plus 1 times 1 is 65.
What is B?
Turns out it's 66.
What is C?
67.
청중: 알파벳을 사용하고 숫자를 사용할 수도 있습니다.
데이비드 말란: 네, 네.
영어 알파벳 A부터 Z까지를 예로 들어 보겠습니다.
그리고 각 문자에 A라는 숫자를 할당할 수도 있습니다.
솔직히 말해서, 이것이 정답일 뿐만 아니라
유일한 답이기도 합니다.
결국 0과 1만 사용할 수 있다면
이것이 이 문제에 대한 잠재적 해결책의 전부입니다.
그래서 몇 년 전, 대문자 A는
방에 모인 여러 ​​사람들에 의해 0과 1의 패턴으로 표현하기로 결정되었습니다.
01000001.
자, 이제 간단한 이진수 계산을 배우셨으니,
대문자 A를 나타내는 데 사용되는 십진수는 무엇일까요?
그럼 65는 64 더하기 1 더하기 1 곱하기 1 = 65입니다.
B는 무엇일까요?
66이군요.
C는 뭐죠?
67.

So they kept things simple there on out.
Might have been nice if A were zero or maybe a were one.
But nope, we're stuck with 65 instead.
But everything after that is very much predictable.
And in fact, for lowercase letters, there's
a whole other set of numbers such as lowercase A happens to be 97,
lowercase B happens to be 98, and so forth.
But again, this is like CS trivia.
But what's important here is that there are indeed contiguous from 65
to 66 to 67 on up.
That's something we're going to be able to leverage beyond the letter A alone.
그래서 그들은 처음부터 끝까지 모든 것을 단순하게 유지했습니다.
A가 0이거나 a가 1이었다면 좋았을 텐데요.
하지만 안 됩니다. 65라는 숫자에 갇히게 되었습니다.
하지만 그 이후의 모든 것은 매우 예측 가능합니다.
사실, 소문자의 경우
소문자 A가 97이고,
소문자 B가 98인 등 완전히 다른 숫자 집합이 있습니다.
하지만 다시 말하지만, 이건 컴퓨터 과학 상식과 같습니다.
하지만 여기서 중요한 것은 65부터
66, 67까지 연속된 숫자가 있다는 것입니다.
이것은 A라는 글자를 넘어 다른 곳에서도 활용할 수 있는 것입니다.

What is this system?
What is this mapping that you yourself propose?
It's ASCII, the American Standard Code for Information Interchange.
And indeed, it was a bunch of Americans years ago who came up with this system.
Unfortunately, at the time, they only allocated 7 and eventually 8 bits total
for representing letters, both uppercase and lowercase, numbers
on the keyboard as well, punctuation symbols as well.
이 시스템은 무엇인가요?
당신이 직접 제안하는 이 매핑은 무엇인가요?
ASCII, 미국 정보 교환 표준 코드입니다.
사실, 이 시스템을 고안한 건 몇 년 전의 미국인들이었습니다.
안타깝게도 당시에는 대문자와 소문자, 키보드의 숫자, 구두점 기호를 표현하는 데 총 7비트, 결국 8비트만 할당했습니다.

And so per our conversation a moment ago, if the Americans in this room,
so to speak, only used 8 bits total, how many different characters can we
represent with a computer in this story?
So only 255, technically 256 if we, again, start counting from zero.
So that's not nearly enough to represent all human languages,
but it is enough to represent at least English, among some others.
So here, for instance, is a chart of the ASCII mapping.
And sure enough, if we zoom in on this column here, 65 is capital A,
66 is capital B, dot, dot, dot 72 is H, 73 is I, and so forth.
방금 전 대화에서 말했듯이, 이 방에 있는 미국인들이
말하자면 총 8비트만 사용한다면, 이 이야기에서 컴퓨터로 얼마나 많은 문자를 표현할 수 있을까요?
그럼 255개, 다시 0부터 세어 보면 엄밀히 말하면 256개밖에 안 됩니다.
즉, 모든 인간 언어를 표현하기에는 턱없이 부족하지만
적어도 영어를 비롯한 몇몇 언어를 표현하기에는 충분합니다.
예를 들어, 여기 ASCII 매핑 차트가 있습니다.
그리고 물론, 여기 이 열을 확대해 보면, 65는 대문자 A,
66은 대문자 B, 점, 점, 점, 점, 72는 H, 73은 I입니다.

So there is a standardized mapping for at least all of these English letters.
Well, suppose you were to receive an email or a text message
or like a Google Doc containing this pattern of zeros and ones.
So 01001000 and so forth and so forth.
So 3 bytes worth.
Three sets of 8 bits.
That is to say 3 bytes, each of which represents a single letter in ASCII.
What message have you received?
Well, I'll do the math this time so we don't have to.
Suppose what you really received was decimal 72, 73, 33.
What message did you just receive?
If you recall the previous chart.
Hi was in fact correct.
따라서 적어도 모든 영어 문자에 대한 표준화된 매핑이 있습니다.
이메일이나 문자 메시지를 받았다고 가정해 보겠습니다.
또는 Google 문서처럼 0과 1 패턴이 포함된 문서를요.
01001000 등등.
3바이트입니다.
8비트가 세 세트입니다.
즉, 3바이트이며, 각각은 ASCII 문자 하나를 나타냅니다.
어떤 메시지를 받으셨습니까?
음, 이번에는 계산을 해 보겠습니다.
실제로 받은 것이 십진수 72, 73, 33이라고 가정해 보겠습니다.
방금 받은 메시지는 무엇입니까?
이전 차트를 기억하시나요?
사실 Hi가 맞았습니다.

Why?
Because H is 72, I is 73.
And wait a minute, 33.
So here's H. Here's I. 33, if we highlight it instead,
happens to be an exclamation point.
So that is literally what is going on underneath the hood, so to speak,
when you get a text message today that literally says in all caps
and an exclamation point, HI!
Your phone has received at least three bytes, each of which
represents a letter of the alphabet.
Your computer is quickly doing the mental math
to figure out exactly what numbers those are and then
looking up in the so-called ASCII chart in its memories, in some sense,
what letter should you actually see on the screen there.
And so if you were to then display that message,
you would see it indeed in English as opposed to those numeric equivalents.
왜 그럴까요?
H는 72이고, I는 73입니다.
잠깐만요, 33이죠.
자, 여기 H가 있습니다. 여기 I가 있습니다. 33을 강조 표시하면
느낌표가 됩니다.
말 그대로, 이것이 바로 내부에서 일어나는 일입니다.
오늘 문자 메시지를 받을 때, 문자 그대로 대문자로 된
느낌표가 붙어 있는 "안녕!"이라는 메시지를 받을 때 말입니다.
휴대폰은 최소 3바이트를 수신했는데, 각 바이트는
알파벳 문자를 나타냅니다.
컴퓨터는 빠르게 암산을 하여
정확한 숫자가 무엇인지 파악한 다음
기억 속의 소위 ASCII 차트에서 어떤 의미에서는
화면에 실제로 어떤 문자가 표시되어야 하는지 찾습니다.
그러면 그 메시지를 표시하면
숫자로 된 문자가 아니라 실제로 영어로 표시됩니다.

How else might we use this then?
Well, here again is that chart.
And maybe just to vary things, maybe take a little pressure off of me
here, why don't we try spelling something else?
This time a different three letter word, but maybe eight volunteers.
Could we get a bytes' worth of volunteers?
And I can sweeten the deal with some stress balls in exchange.
You just have to be comfortable coming up on stage and being on the internet.
So yes.
One, two.
How about three, four.
How about five, six, seven.
And how about eight.
Come on up.
A round of applause for our volunteers.
Yep.
[APPLAUSE]
그럼 이걸 어떻게 다른 용도로 쓸 수 있을까요?
음, 여기 다시 그 차트가 있습니다.
그리고 좀 더 다양하게, 어쩌면 제 부담을 덜어드리기 위해
자, 다른 철자를 써 보는 건 어떨까요?
이번에는 다른 세 글자 단어, 하지만 자원봉사자 여덟 명 정도요.
자원봉사자 몇 바이트 정도를 구해 주시겠어요?
그리고 스트레스 공 몇 개로 좀 달래 드릴게요.
무대에 오르고 인터넷에 접속하는 게 편해야 합니다.
네, 맞아요.
하나, 둘.
셋, 넷은 어때요?
다섯, 여섯, 일곱은 어때요?
그리고 여덟은 어때요?
올라오세요.
자원봉사자분들께 박수를 보냅니다.
네.
[박수]

All right.
So what I'm going to have each of you do is
represent a bit in a particular order.
So if you want to just, in any order, line
yourselves up here facing the audience.
Come on over.
All right.
And we will have you represent-- well, we got to see who ends up where.
Scooch this way a little bit.
This way, this way.
All right.
So you shall be the ones place and just hold that in front of you.
Twos place.
Threes.
Fours place.
Eights place.
16, 32, 64, and 128.
And just compress yourselves a little bit if you could.
So each of these folks represents a bit in a particular place.
And let's say this.
좋습니다.
그럼 여러분 각자가 하라고 할 건
특정 순서대로 비트를 표현하는 거예요.
원하시면, 아무 순서로든
관객을 향해 여기 줄을 서세요.
이리 와요.
좋습니다.
그리고 여러분은 표현을 하게 될 거예요. 음, 누가 어디에 있는지 봐야죠.
이쪽으로 조금 움직여 보세요.
이쪽으로, 이쪽으로.
좋습니다.
자, 여러분은 1의 자리에 서서 그것을 앞에 들고 있으면 됩니다.
2의 자리.
3의 자리.
4의 자리.
8의 자리.
16, 32, 64, 그리고 128.
가능하면 조금 압축해 보세요.
이 사람들은 각자 특정 위치에서 비트를 표현합니다.
자, 이렇게 말해 봅시다.

If you're just standing there uncomfortably without any hand raise,
we'll assume that you're representing a zero, quite simply.
If your hand goes up, though, the audience
should assume that you're representing a one.
And therefore, what we'll do is spell out a three letter word,
and on each round of this, you'll either stay, stay like this,
or you'll raise your hand.
But first, let's actually meet some of our volunteers
here, starting with position number one, if you'd like to say your name,
perhaps where you're from and/or studying.
손을 들지 않고 불편하게 서만 있다면
아주 간단하게 0을 나타낸다고 가정하겠습니다.
하지만 손을 들면 청중은
1을 나타낸다고 생각해야 합니다.
그래서 세 글자 단어를 쓰겠습니다.
매 라운드마다 이렇게 서 있거나,
이대로 서 있거나,
손을 드세요.
하지만 먼저, 저희 자원봉사자들을 만나 뵙겠습니다.
1번 자리부터 시작해서, 이름을 말씀해 주시면 됩니다.
어디 출신인지, 또는 어느 학교 출신인지 말씀해 주시면 좋겠습니다.

AUDIENCE: Hi.
My name is Brooke.
I'm from Indiana, and I'm studying biology and computer science.
DAVID MALAN: Nice.
Welcome.
AUDIENCE: Hi, I'm Becca.
I'm from, like, Maryland, DC area, and I'm studying electrical engineering.
DAVID MALAN: Welcome.
AUDIENCE: Hi, I'm Addison.
I'm from Maryland.
I'm studying engineering.
AUDIENCE: Hi.
I'm Sharon.
I'm from Rwanda and I'm studying CS and math.
DAVID MALAN: Welcome.
AUDIENCE: Hi, I'm Grace.
I'm from Alabama and I'm studying electrical engineering.
DAVID MALAN: Welcome.
AUDIENCE: Hi, I'm Angelina.
I'm from Maryland.
And also, I stay in Matthews.
DAVID MALAN: Nice.
Matthews.
Nice.
[APPLAUSE]
AUDIENCE: And I'm studying applied math and econ, as well as
environmental science and public policy.
DAVID MALAN: Welcome.
AUDIENCE: I'm Owen Bells and I'm from rural Virginia and I'm studying CS.
DAVID MALAN: Nice, welcome.
And?
AUDIENCE: My name is Max.
I'm from London.
I'm also staying in Matthews and I'm studying computer science
and neuroscience.
Thank you.
청중: 안녕하세요.
제 이름은 브룩입니다.
인디애나 출신이고 생물학과 컴퓨터 과학을 공부하고 있습니다.
데이비드 말란: 안녕하세요.
환영합니다.
청중: 안녕하세요, 저는 베카입니다.
메릴랜드, 워싱턴 D.C. 지역 출신이고 전기 공학을 공부하고 있습니다.
데이비드 말란: 환영합니다.
청중: 안녕하세요, 저는 애디슨입니다.
메릴랜드 출신입니다.
공학을 공부하고 있습니다.
청중: 안녕하세요.
저는 샤론입니다.
르완다 출신이고 컴퓨터 과학과 수학을 공부하고 있습니다.
데이비드 말란: 환영합니다.
청중: 안녕하세요, 저는 그레이스입니다.
앨라배마 출신이고 전기 공학을 공부하고 있습니다.
데이비드 말란: 환영합니다.
청중: 안녕하세요, 저는 안젤리나입니다.
메릴랜드 출신입니다.
그리고, 저는 매튜스에 머물고 있습니다.
데이비드 말란: 좋습니다.
매튜스.
좋습니다.
[박수]
청중: 저는 응용 수학과 경제학을 공부하고 있고,
환경 과학과 공공 정책도 공부하고 있습니다.
데이비드 말란: 환영합니다.
청중: 저는 오웬 벨스이고, 버지니아 시골 출신이며 컴퓨터 과학을 공부하고 있습니다.
데이비드 말란: 좋습니다, 환영합니다.
그리고요?
청중: 제 이름은 맥스입니다.
런던 출신입니다.
저도 매튜스에 머물고 있으며 컴퓨터 과학과
신경 과학을 공부하고 있습니다.
감사합니다.

DAVID MALAN: Welcome aboard as well.
If you're wondering, too, why I was wearing
these glasses at the start-- so very common on the internet nowadays
as these POV videos.
So it turns out these Ray-Bans actually record video footage,
and we have a couple of them, and we'd thought we would offer them
to a couple of volunteers.
If anyone wants to record their point of view for everyone here.
And Vlad here is going to help make sure they're recording.
Second volunteer.
Yes, number two.
All right.
So as Vlad gets those set, on the backs of your pieces of paper
you have instructions for the following three rounds.
Each round represents a letter.
The audience participation part of this is
to actually do the mental math to figure out what number these volunteers are
representing.
So go ahead and execute round one, either keeping your hand down or raising
it appropriately.
OK.
데이비드 말란: 환영합니다.
혹시 제가 처음에 왜 이 안경을 썼는지 궁금하시다면,
요즘 인터넷에서 흔히 볼 수 있는 이 POV 영상 말이죠.

이 레이밴 안경이 실제로 영상 녹화 기능을 한다는 걸 알게 됐고,
저희도 몇 개 가지고 있는데,
몇몇 자원봉사자분들께 제공해 드리려고 합니다.
혹시 여기 계신 모든 분들을 위해 자신의 관점을 녹화하고 싶으신 분이 있다면요.
그리고 여기 블라드가 녹화를 도와드릴 겁니다.
두 번째 자원봉사자입니다.
네, 두 번째입니다.
좋습니다.
블라드가 준비하면, 여러분의 종이 뒷면에
다음 세 라운드에 대한 지침이 있습니다.
각 라운드는 하나의 글자를 나타냅니다.
관객 참여 부분은
실제로 이 자원봉사자들이 나타내는 숫자를 암산하는 것입니다.

그럼 첫 번째 라운드를 진행해 보세요. 손을 내리거나
적절하게 들어 올리세요.
좋습니다.

What number are our volunteers here representing?
AUDIENCE: 66.
DAVID MALAN: 66, because we have a 64 plus a 2.
That then maps to what ASCII letter?
AUDIENCE: B.
DAVID MALAN: B was the first letter.
OK, hands down.
Round two, go.
A little harder.
What's now being represented?
AUDIENCE: 79.
DAVID MALAN: I'm starting to hear it.
79 is in fact correct.
79, because we have a 64 and an 8 and 4 and 2 and a 1.
So if it's a 79, we have the ASCII letter O.
So we've got BO, and then lastly, third round.
Go.
여기 있는 자원봉사자들은 몇 개를 나타내고 있나요?
청중: 66.
데이비드 말란: 66입니다. 64에 2를 더한 숫자니까요.
그럼 이 숫자는 어떤 ASCII 문자에 대응하나요?
청중: B.
데이비드 말란: B가 첫 번째 문자였습니다.
좋습니다, 당연하죠.
2라운드, 시작하세요.
조금 더 어려워요.
지금은 무엇을 나타내고 있나요?
청중: 79.
데이비드 말란: 이제 들리기 시작했습니다.
사실 79가 맞습니다.
79입니다. 64, 8, 4, 2, 1이 있으니까요.
그러니까 79라면 ASCII 문자 O입니다.
그러니까 BO가 있고, 마지막으로 3라운드입니다.
시작.


We have 01010111.
What number is this?
AUDIENCE: 87.
DAVID MALAN: 87.
Which spells the letter?
AUDIENCE: W.
DAVID MALAN: W. Which spells the word?
AUDIENCE: Bow.
DAVID MALAN: Not bow.
Take a bow if you could.
All right.
A round of applause for our volunteers here.
[APPLAUSE]
01010111입니다.
이 숫자는 몇 번일까요?
청중: 87
데이비드 말란: 87
이 글자는 어떻게 쓰였을까요?
청중: W.
데이비드 말란: W. 이 단어는 어떻게 쓰였을까요?
청중: 인사하세요.
데이비드 말란: 인사가 아닙니다.
가능하면 인사해 주세요.
좋습니다.
자원봉사자 여러분께 박수를 보냅니다.
[박수]

And come on off this way and help yourself to a CS50 stress ball.
Thank you to our volunteers.
So this is only to say we've now agreed on how we can represent numbers
from zero on up.
We've agreed on how we can represent letters.
But at least letters using ASCII, and in fact, these
are more than just decoration.
이쪽으로 와서 CS50 스트레스 볼을 마음껏 드세요.
자원봉사자분들께 감사드립니다.
그러니까 이제 숫자를 0부터 어떻게 표현할지 합의했다는 말씀입니다.

문자를 어떻게 표현할지 합의했습니다.
하지만 적어도 ASCII 문자를 사용하는 문자는, 사실 이것들은
단순한 장식 이상의 의미를 지닙니다.

In fact, it's a little bit of trivia by lecture's end.
If you to come up for your very own CS50 stress ball,
turns out there are 64 light bulbs at the foot of the stage here.
If you break them down into 8 byte or single--
8 bit or single byte chunks, there's an eight letter word
that happens to be spelled out today using this here ASCII chart.
So today's mystery is what exactly is that there word.
But of course, if you have only 8 bits, you can only represent, like,
256 characters, which sounds like plenty for English, and indeed, it is.
Zero through nine, A through B, capital and lowercase,
uppercase and lowercase, as well as punctuation.
But there's so many other human languages
in the world that have other characters.
사실, 강의가 끝날 무렵에는 약간의 잡학 지식이 될 겁니다.
자신만의 CS50 스트레스 볼을 찾으러 오세요.
여기 무대 아래에 전구 64개가 있다는 걸 알게 됐죠.
이 전구들을 8바이트 또는 1바이트 단위로 나누면,
오늘은 이 ASCII 차트를 사용하여 8글자 단어가 나옵니다.
그래서 오늘의 미스터리는 바로 그 단어가 뭐냐는 겁니다.
하지만 8비트만 있다면
256자 정도만 표현할 수 있는데, 영어에는 충분해 보이고, 실제로도 그렇습니다.
0부터 9까지, A부터 B까지, 대문자와 소문자,
대문자와 소문자, 그리고 구두점까지.
하지만 세상에는 다른 문자를 사용하는 언어가 너무나 많습니다.

For instance, we have not just the English alphabet
we might see here on a US English keyboard.
We have accented characters, we have various Asian languages
have even many more glyphs.
We need more than 256 possible characters.
And so nowadays computers do not just use 7 or even 8 bits.
They might use 8 bits for some letters, like all of the English letters.
They might use 16 bits for certain other languages.
Maybe even 24 or 32 bits.
And fun fact, if you have 32 bits--
and we have more than that on the stage.
If you've got 32 bits, you can actually represent
as many as 4 billion possible characters, which is quite a bit.
No pun intended.
예를 들어, 미국 영어 키보드에서 볼 수 있는 영어 알파벳뿐만 아니라
강조 표시가 있는 문자도 있고, 다양한 아시아 언어에는
훨씬 더 많은 글리프도 있습니다.
256개 이상의 문자가 필요합니다.
그래서 오늘날 컴퓨터는 7비트나 8비트만 사용하지 않습니다.
모든 영어 문자처럼 일부 문자에는 8비트를 사용할 수도 있습니다.
특정 언어에는 16비트를 사용할 수도 있습니다.
24비트나 32비트를 사용할 수도 있습니다.
재밌는 사실은 32비트가 있다면…
무대에는 그보다 더 많은 문자가 있습니다.
32비트가 있다면
최대 40억 개의 문자를 표현할 수 있는데, 이는 상당히 많은 양입니다.
말장난은 의도한 것이 아닙니다.

So what else can we represent?
Well, the goal of this system, not just ASCII,
but something known as Unicode, which is a newer standard,
is to be backwards compatible with ASCII.
So humans left all of those other numbers alone, 65, 66, 67 and so forth,
but they added to it a super set of representations
that maybe are 16, 24, or 32 bits.
The goal being to be able digitally to represent all human languages, past,
present, and future, and even through pictograms, things
like smiley faces and the like, even people, places, things and emotions that
transcend human language.
그렇다면 우리는 무엇을 더 표현할 수 있을까요?
음, 이 시스템의 목표는 단순히 ASCII가 아니라
새로운 표준인 유니코드라는 것인데,
ASCII와 하위 호환되는 것입니다.
그래서 인간은 65, 66, 67 등의 다른 숫자는 그대로 두고
16비트, 24비트, 32비트 등의 더 큰 표현 방식을 추가했습니다.
목표는 과거, 현재, 미래의 모든 인간 언어를 디지털 방식으로 표현할 수 있도록 하는 것이었습니다.
심지어 그림 문자, 스마일리 같은 것, 심지어 인간 언어를 초월하는 사람, 장소, 사물, 감정까지도 표현할 수 있도록 하는 것이었습니다.

And in fact, odds are within the past few minutes or hours, most of you
have used one or more of these here emoji, these pictograms, which it turns
out are just characters on a keyboard.
You might have to hit a special button to pull up that form of the keyboard,
but these are just here characters.
And so these emoji have exploded in popularity
for a number of reasons, one of which is, my God, what are we
going to do with 4 billion possible patterns of zeros and ones?
We can start to have some fun with it and represent things
beyond English and human languages alone.
사실, 지난 몇 분 또는 몇 시간 동안 여러분 중 대부분은
이 이모티콘이나 그림 문자를 하나 이상 사용해 보셨을 겁니다.
이 이모티콘들은
키보드에 있는 문자일 뿐입니다.
키보드에서 해당 형태를 불러오려면 특수 버튼을 눌러야 할 수도 있지만,
이것들은 그냥 문자일 뿐입니다.
이 이모티콘은 여러 가지 이유로 폭발적으로 인기를 얻었습니다.
그 중 하나는, 세상에, 40억 개의 0과 1 패턴으로 뭘 할 수 있을까 하는 것입니다.
이 이모티콘을 가지고 재미있게 놀면서
영어와 인간 언어 그 이상의 것을 표현할 수 있습니다.

Now, as an aside, when it comes to Unicode,
it turns out Unicode, years ago, standardized this pattern of 32 zeros
and ones to represent just one of those emoji.
So emoji tend to use even more bits here.
Anyone know what decimal number this is?
This is not a fun mathematical exercise.
The spoiler is 4,036,991,106 is the decimal number that actually represents,
as of present, the most popular emoji in the world.
자, 잠깐, 유니코드에 대해 말씀드리자면,
몇 년 전 유니코드는 이 이모지 중 하나만을 표현하기 위해 32개의 0과 1로 이루어진 패턴을 표준화했습니다.
그래서 이모지는 더 많은 비트를 사용하는 경향이 있습니다.
이게 몇 십진수인지 아시는 분 계신가요?
재밌는 수학 연습은 아닙니다.
스포일러는 4,036,991,106이 실제로 현재 세계에서 가장 인기 있는 이모지를 나타내는 십진수라는 것입니다.
현재로서는 말입니다.

Does anyone want to hazard a guess what emoji this here number represents?
AUDIENCE: Heart.
DAVID MALAN: Heart?
Hearts?
No, but it's actually this so-called face with tears of joy.
So perhaps think about the frequency with which you send that one.
And even though it's obviously a picture on the screen, sure,
it actually is more like a font, because underneath the hood,
it's indeed just a pattern of zeros and ones or a decimal number
that the computer is storing.
But the computer, be it Mac OS or Windows or iOS or Android,
know to display that pattern as this here picture.
But the pictures might look different depending on the hardware.
Why?
Because there's companies like Google and Microsoft and Meta and others
that have their own artists on staff as employees,
and those artists interpret the descriptions
like face with tears of joy differently.
여기 이 숫자가 무슨 이모티콘인지 맞춰보실 분 계신가요?
청중: 하트.
데이비드 말란: 하트요?
하트요?
아니요, 하지만 사실 기쁨의 눈물을 흘리는 얼굴이라고 합니다.
그러니 그 이모티콘을 얼마나 자주 보내는지 생각해 보세요.
화면에는 그림이 분명히 있지만,
사실은 글꼴에 가깝습니다. 왜냐하면 그 안에는
컴퓨터가 저장하는 0과 1의 패턴이나 소수점 숫자일 뿐이니까요.
하지만 Mac OS, Windows, iOS, Android 등 컴퓨터는
이 패턴을 여기 이 그림처럼 표시합니다.
하지만 그림은 하드웨어에 따라 다르게 보일 수 있습니다.
왜 그럴까요?
Google, Microsoft, Meta 등
자체 아티스트를 직원으로 두고 있는 회사들이 있는데,
그 아티스트들은 기쁨의 눈물을 흘리는 얼굴과 같은 표현을 다르게 해석하기 때문입니다.

So those of you with an Android phone actually see face with tears of joy
looking a little something like this.
And if you have Telegram, for instance, installed on your phone,
it's even more animated than that.
It's this here emoji using the same pattern of zeros and ones.
So different artists render these here emoji in different ways,
but all they are here are patterns.
Now, for all of the other answers, save one that was shouted out a moment ago,
this is a sort of cloud diagram of the most popular emoji as
of a couple of years ago per Unicode, whereby the size of the emoji
indicates its relative popularity.
So heart, I did here over here, is indeed
one of the most popular ones as well.
안드로이드 폰을 사용하시는 분들은 기쁨의 눈물을 흘리는 얼굴이
이렇게 생긴 걸 보실 수 있을 겁니다.
예를 들어, 텔레그램을 폰에 설치하셨다면
훨씬 더 생동감 넘치게 보이실 겁니다.
이 이모지는 0과 1의 동일한 패턴을 사용합니다.
즉, 이 이모지는 여러 아티스트가 각자 다른 방식으로 표현하지만
여기 있는 이모지는 모두 패턴일 뿐입니다.
자, 방금 전에 말씀드린 것을 제외하고 나머지 답변은 다음과 같습니다.
이것은 유니코드 기준으로 몇 년 전 가장 인기 있었던 이모지의 클라우드 다이어그램입니다.
이모지의 크기는
상대적인 인기를 나타냅니다.
제가 여기에 표시한 하트 모양도
가장 인기 있는 이모지 중 하나입니다.

Question?
AUDIENCE: Why do certain emojis show up [INAUDIBLE]?
DAVID MALAN: Oh, really good question.
Why do certain emoji not show up on one device or another?
It depends on how recent the software is.
Pretty much every year the humans behind the Unicode consortium
release new emoji.
Which is to say they decide that this other pattern will
represent this new emoji, this other pattern will represent this new emoji.
And unless you update your phone, your laptop,
your desktop to the very latest software and the manufacturer of that device
or software also updates by hiring an artist
to draw those pictures in their own fonts, in their own style,
you're going to see usually just an empty black square or maybe just
a black and white heart instead of something more colorful.
Really just placeholders, because, it's as though you
don't have the right font installed or really,
you have an older version of that same font installed.
But it's become sort of an annual tradition that new and more emoji
are released every year, which is among the reasons why these updates contain
more and more.
Yeah?
질문?
청중: 특정 이모티콘이 [들리지 않음]으로 표시되는 이유는 무엇인가요?
데이비드 말란: 아, 정말 좋은 질문이네요.
특정 이모티콘이 특정 기기에 표시되지 않는 이유는 무엇인가요?
소프트웨어가 얼마나 최신 버전인지에 따라 다릅니다.
유니코드 컨소시엄은 거의 매년 새로운 이모티콘을 출시합니다.
즉, 이 다른 패턴이 이 새로운 이모티콘을 나타낼 것이라고 결정합니다.
이 다른 패턴이 이 새로운 이모티콘을 나타낼 것입니다.
휴대폰, 노트북, 데스크톱을 최신 소프트웨어로 업데이트하고
해당 기기 제조업체에서 아티스트를 고용하여 자체 글꼴과 스타일로 그림을 그리도록 하지 않는 한,
대개 더 화려한 색상 대신 빈 검은색 사각형이나 흑백 하트만 표시됩니다.
사실은 임시 표시일 뿐입니다.
마치 적절한 글꼴이 설치되어 있지 않거나,
동일한 글꼴의 이전 버전이 설치되어 있는 것과 같기 때문입니다.
하지만 매년 새롭고 더 많은 이모지가 출시되는 것이 일종의 연례 행사가 되었고
이것이 이러한 업데이트에 점점 더 많은 이모지가 포함되는 이유 중 하나입니다.
그렇죠?

AUDIENCE: How do you represent color in bytes?
DAVID MALAN: That is an amazing segue.
How do you represent color in bytes?
Well, you use RGB, which happens to be, by coincidence, the next slide.
So let's again, recap.
We know how to represent letters.
We know how to represent numbers.
We can even represent emoji.
But those emoji technically on the screen
are, of course, composed of colors, like a whole bunch of yellow
for that there smiley face?
How do computers, then, using only zeros and ones, represent colors?
Well, by convention, they typically use a system that, by an acronym,
is called RGB.
Red, green, blue.
청중: 색상을 바이트 단위로 어떻게 표현하시나요?
데이비드 말란: 정말 놀라운 전환이네요.
색상을 바이트 단위로 어떻게 표현하시나요?
음, RGB를 사용하는데, 우연히 다음 슬라이드에 RGB가 있습니다.
자, 다시 한번 요약해 볼까요?
우리는 문자를 표현하는 방법을 알고 있습니다.
숫자를 표현하는 방법도 알고 있습니다.
이모티콘도 표현할 수 있습니다.
하지만 기술적으로 화면에 보이는 이모지는
물론 노란색으로 이루어져 있죠.
저 스마일리 얼굴처럼요.
그렇다면 컴퓨터는 0과 1만을 사용하여 색상을 어떻게 표현할까요?
관례적으로 컴퓨터는 RGB라고 불리는 시스템을 사용합니다.
빨강(Red), 초록(Green), 파랑(Blue)입니다.

And this is to say that a computer, to represent a single dot on the screen--
maybe this one, this one, this one-- will allocate some number of bits
or some number of bytes to represent the color of just that, their dot, otherwise
known as a pixel.
You can actually see pixels on your phone or even on your TV or monitor.
If you go really close, especially if it's an older monitor,
you can see the tiny little squares.
Each of those has some number of bits telling the device what color to use.
In particular, these devices typically use three numbers in total, three bytes.
So that is to say 24 bits per pixel.
And they do this.
즉, 컴퓨터는 화면에 있는 하나의 점, 예를 들어 이 점, 저 점, 저 점을 표현하기 위해 
일정 수의 비트 또는 일정 수의 바이트를 할당합니다.
이는 바로 그 점, 즉 픽셀의 색상을 표현하기 위한 것입니다.
실제로 휴대폰이나 TV, 모니터에서 픽셀을 볼 수 있습니다.
특히 오래된 모니터라면 아주 가까이 다가가면
작은 사각형들을 볼 수 있습니다.
각 사각형에는 장치에 사용할 색상을 알려주는 일정 수의 비트가 있습니다.
특히 이러한 장치는 일반적으로 총 세 개의 숫자, 즉 3바이트를 사용합니다.
즉, 픽셀당 24비트가 사용됩니다.
그리고 이렇게 합니다.

If you were to represent a single dot on the screen using these three
numbers, just by intent here, this is 72, 73,
33, which in the context of a text message, an email,
a Google Doc represents, of course, hi, textually.
What if a computer uses that same pattern
of zeros and ones, that is the same pattern of decimal digits,
to represent the color on a screen?
Which is germane if you're opening an image using Photoshop.
So using a different piece of software that
knows about colors and images and not just text.
Well, this would imply that you want that dot on the screen
to have a medium amount of red, a medium amount of green,
and a little bit of blue.
화면에 점 하나를 이 세 개의 숫자를 사용하여 표현한다면, 의도적으로 72, 73, 33이 되는데, 
문자 메시지, 이메일, Google 문서에서 이 숫자는 물론 텍스트로 표현됩니다.
컴퓨터가 같은 0과 1의 패턴, 즉 같은 소수점 패턴을 사용하여
화면의 색상을 표현한다면 어떨까요?
포토샵을 사용하여 이미지를 열 때와 유사합니다.
즉, 텍스트뿐만 아니라 색상과 이미지까지 인식하는 다른 소프트웨어를 사용하는 것입니다.
즉, 화면의 점에 중간 정도의 빨간색, 중간 정도의 녹색, 그리고 약간의 파란색이 나타나도록 해야 합니다.

Why do I say medium and little?
Well, again, if each of these numbers is using 8 bits or 1 byte,
the highest we can count, as we discovered, was 255.
So I'm kind of averaging here.
So 72 at a 255 feels to me like a medium amount of red.
33 feels relatively little blue.
But if now the computer combines those wavelengths of light, so to speak,
a medium amount of red, medium amount of green,
a little bit of blue, what you get is the color code for a single dot.
And does anyone want to guess what color roughly this represents,
these three bytes?
AUDIENCE: White.
AUDIENCE: Purple.
DAVID MALAN: Not white, not purple.
AUDIENCE: Brown.
DAVID MALAN: Not brown.
AUDIENCE: Yellow.
DAVID MALAN: Yellow, in fact, is the answer.
왜 중간과 약간이라고 했을까요?
음, 다시 한번 말씀드리지만, 이 숫자들이 각각 8비트나 1바이트를 사용한다면,
알고 있듯이 우리가 셀 수 있는 가장 높은 숫자는 255였습니다.
그래서 저는 여기서 평균을 내고 있는 겁니다.
그래서 255에서 72는 제게 중간 정도의 빨간색처럼 느껴집니다.
33은 상대적으로 약간 파란색처럼 느껴집니다.
하지만 이제 컴퓨터가 이 파장들을 결합한다면, 말하자면
중간 정도의 빨간색, 중간 정도의 녹색, 그리고 약간의 파란색을 결합한다면, 하나의 점에 대한 색상 코드를 얻게 됩니다.
그리고 이 세 바이트가 대략 어떤 색을 나타내는지 맞춰보실 분 계신가요?
청중: 흰색.
청중: 보라색.
데이비드 말란: 흰색도, 보라색도 아닙니다.
청중: 갈색.
데이비드 말란: 갈색도 아닙니다.
청중: 노란색.
데이비드 말란: 사실 노란색이 정답입니다.

So it represents in a single pixel roughly this shade here of yellow.
Which is to say, if we look back at any of those emoji, which, again,
are represented by patterns of zeros and ones,
but you and I as humans perceive them as images on the screen--
let me actually go ahead and zoom and zoom in further
to one such sample emoji.
And when you zoom in far enough or you put the phone close enough to your face,
you can actually see all of those little dots known
as pixels, all of the little squares.
And given that so many of these pixels are yellow,
that is to say that that pattern of three bytes,
72, 73, 33, is used to represent this pixel.
Another 3 identical bytes are used to represent this pixel, this one,
this one, and so forth.
So now if you've taken digital photos on your phone or a camera,
you're probably generally familiar from the internet and hardware
today that a photograph is, what, 1 megabyte, 10 megabytes depending
on the resolution of it?
Well, megabyte means millions of bytes.
그래서 하나의 픽셀에 대략 이 노란색 음영을 나타냅니다.
다시 말해, 이모지들을 다시 살펴보면, 다시 한번 말씀드리지만
0과 1의 패턴으로 표현되지만
저와 같은 인간은 화면의 이미지로 인식합니다.
실제로 확대해서 한 가지 샘플 이모지를 살펴보겠습니다.
그리고 충분히 확대하거나 휴대폰을 얼굴에 충분히 가까이 대면
픽셀이라고 하는 작은 점들, 즉 작은 사각형들을 모두 볼 수 있습니다.
그리고 이 픽셀들 중 많은 수가 노란색이므로
72, 73, 33의 세 바이트 패턴이 이 픽셀을 나타내는 데 사용됩니다.
또 다른 세 개의 동일한 바이트는 이 픽셀, 이 픽셀,
이 픽셀, 이런 식으로 표현됩니다.
휴대폰이나 카메라로 디지털 사진을 찍어보셨다면
오늘날 인터넷과 하드웨어를 통해
사진의 용량이 1메가바이트, 10메가바이트, 해상도에 따라 다르다는 것을 잘 알고 계실 겁니다.
메가바이트는 수백만 바이트를 뜻합니다.

Where are all of these bytes inside of these photographs
or these images you're taking or downloading?
They correspond to every one of the single pixels on the screen.
There's at least three bytes being used to represent every one of those dots.
As an aside, bit of a white lie because nowadays there's
fancy compression software that can use fewer than that many bytes.
But in general, that's where all of those bytes, those millions of bytes
are coming from.
So how is that for an answer to how do we represent colors?
Thank you.
So if we agreed now that there's this way and perhaps
others to represent colors, well, how do we
represent not just images, but videos?
Well, videos once upon a time, or movies, were called motion pictures.
So motion pictures with motion.
이 사진들, 혹은 여러분이 찍거나 다운로드하는 이미지들 안에 있는 이 모든 바이트들은 어디에 있을까요?
화면에 있는 모든 픽셀 하나하나에 대응합니다.
이 모든 점들을 표현하는 데 최소 3바이트가 사용됩니다.
덧붙이자면, 요즘은 그보다 적은 바이트를 사용할 수 있는 고급 압축 소프트웨어가 있으니까요.
하지만 일반적으로 수백만 바이트는 바로 그 곳에서 나옵니다.
그렇다면 색상을 어떻게 표현하는지에 대한 답은 무엇일까요?
감사합니다.
그렇다면 이제 색상을 표현하는 방법이 있고, 어쩌면 다른 방법도 있다는 것에 동의한다면, 이미지뿐만 아니라 비디오도 어떻게 표현할 수 있을까요?
옛날에는 비디오나 영화를 모션 픽처라고 불렀습니다.
즉, 움직임이 있는 모션 픽처 말입니다.

Why is that?
Well, it's analogous to growing up.
If you ever played with one of these picture books-- and in fact,
there's memes nowadays that have made these popular again,
whereby why you have a whole bunch of images on individual sheets of paper.
And if you flip through them fast enough,
your human mind and eyes perceive it as actual motion,
even though you're just seeing image, image, image, image, image, image.
But it's so fast, it looks like motion.
That's all a video is on your screen.
That's all a film is on your TV.
It is not in fact, continuous motion.
It's maybe 30 frames or images per second, maybe 24 frames
or images per second.
Which is to say, we know how to represent numbers,
we know how to represent letters, we know how
to represent colors and thus images.
왜 그럴까요?
음, 어렸을 때와 비슷하죠.
이런 그림책을 가지고 놀아본 적이 있다면, 사실
요즘 이런 그림책을 다시 유행시킨 밈(meme)이 있는데,
종이 한 장에 여러 장의 이미지가 있는 이유죠.
그리고 충분히 빨리 넘기면
인간의 마음과 눈은 그것을 실제 움직임으로 인식합니다.
이미지, 이미지, 이미지, 이미지, 이미지, 이미지, 이미지만 보고 있어도 말이죠.
하지만 너무 빨라서 움직임처럼 보입니다.
화면에 보이는 건 비디오뿐이고, TV에 나오는 영화도 마찬가지입니다.
사실, 연속적인 움직임이 아닙니다.
초당 30프레임이나 이미지일 수도 있고,
초당 24프레임이나 이미지일 수도 있습니다.
즉, 우리는 숫자를 표현하는 방법을 알고,
문자를 표현하는 방법을 알고,
색깔을 표현하는 방법을 알고, 따라서 이미지를 표현하는 방법을 알고 있습니다.

Now we kind of get videos for free because it's just more of the same.
Use more and more of those patterns.
Why are videos so darn large?
Why are they gigabytes to download, billions of bytes?
Because there's so many darn images.
30 some odd images per second in those kinds of videos.
And maybe lastly, just to top off our multimedia,
how could you represent sound?
Maybe musicians in the room.
How, using only zeros and ones, could you represent something
as sonorous as music?
Something analog as digital.
Yeah?
이제 우리는 비디오를 거의 무료로 받는 것 같아요. 똑같은 게 더 많으니까요.
그런 패턴을 점점 더 많이 사용하게 되죠.
비디오는 왜 이렇게 용량이 클까요?
왜 다운로드하는 데 기가바이트, 수십억 바이트가 필요할까요?
이미지가 너무 많거든요.
그런 종류의 비디오에는 초당 30개 정도의 이미지가 들어가죠.
마지막으로, 멀티미디어를 마무리하자면,
소리를 어떻게 표현할 수 있을까요?
방 안의 음악가들을 표현하는 것 같은데요.
0과 1만 사용해서 어떻게 음악처럼 울려 퍼지는 것을 표현할 수 있을까요?
아날로그를 디지털처럼 표현할 수 있을까요?
네?

AUDIENCE: So each number corresponds to a frequency.
DAVID MALAN: Yeah.
So each number that we store in the computer
could correspond to a certain frequency, which
has a direct relationship to the sound or the pitch of a note.
For instance, in the world of piano and many other instruments,
you've got like your A, your B, your C, maybe you have sharps and flats as well.
We could just agree, like the ASCII people
did years ago, to represent the musical note A, let's use
this pattern, musical note A-sharp, let's use this pattern and so forth.
But maybe pitch alone or frequency alone is not enough.
Maybe we need that number, but maybe a second number
for the volume, the sort of digital equivalent of how hard
are you hitting the key on the piano.
청중: 각 숫자는 주파수에 해당합니다.
데이비드 말란: 네.
컴퓨터에 저장하는 각 숫자는 특정 주파수에 해당할 수 있으며, 이는 음의 소리나 높이와 직접적인 관련이 있습니다.
예를 들어, 피아노를 비롯한 여러 악기에는 A, B, C가 있고, 샵과 플랫도 있을 수 있습니다.
아스키 코드 개발자들이 몇 년 전 했던 것처럼, A음을 표현하기 위해 이 패턴을 사용하고, 
A샵음을 표현하기 위해 이 패턴을 사용하는 식으로 합의할 수도 있습니다.
하지만 피치나 주파수만으로는 충분하지 않을 수도 있습니다.
이 숫자는 필요하지만, 음량을 나타내는 두 번째 숫자가 필요할 수도 있습니다. 
피아노 건반을 얼마나 세게 두드리는지에 대한 디지털 버전과 같은 것이죠.

Maybe a third number for how long are you holding the key down.
So maybe the pitch and the volume and the duration, kind of like RGB,
we could use three bytes to represent every musical note in some piece.
And if we wanted to keep track of what instrument should
be played by the computer to sound that music,
well, maybe that's just a fourth byte or something else as well.
Which is to say, at the end of the day, all
we have are these zeros and ones to throw at the problem.
So for now, that's it for representing information.
We've got our numbers, we've got our letters,
we've got our colors and images, our videos, and now sound.
Any questions on how computers, then, are representing, as promised,
those inputs and outputs using just zeros and ones?
Yeah, in the middle.
세 번째 숫자는 키를 얼마나 오래 누르고 있는지를 나타내는 것일 수도 있겠네요.
음높이, 볼륨, 지속 시간 같은 RGB 같은 것 말이죠.
어떤 곡의 모든 음표를 표현하는 데 세 바이트를 사용할 수 있을 겁니다.
그리고 컴퓨터가 어떤 악기를 연주해서 어떤 음악을 내야 하는지 추적하고 싶다면
네 번째 바이트나 다른 게 필요할지도 몰라요.
즉, 결국 우리가 가진 건
문제를 해결하는 데 쓸 수 있는 0과 1뿐이라는 거죠.
자, 지금은 정보를 표현하는 데 필요한 모든 것을 다 갖췄습니다.
숫자, 문자,
색상과 이미지, 비디오, 그리고 이제 소리까지요.
그렇다면 컴퓨터가 약속한 대로 0과 1만을 사용해서 입력과 출력을 어떻게 표현하는지에 대한 질문이 있으신가요?
네, 중간쯤에서요.

AUDIENCE: The computer is taking it as input.
DAVID MALAN: Correct.
So the computer is taking as input at the end of the day, zeros and ones
and is outputting zeros and ones.
However, as we'll learn in this class, by writing software,
by writing code that understands those zeros and ones we will enjoy
not just literally seeing zeros and ones,
we will see A, B, C, we will see colors, we will see video,
we will hear sounds so long as we write the code to interpret those zeros
and ones.
청중: 컴퓨터는 이를 입력으로 받습니다.
데이비드 말란: 맞습니다.
즉, 컴퓨터는 결국 0과 1을 입력으로 받고
0과 1을 출력합니다.
하지만 이 수업에서 배우겠지만, 소프트웨어를 작성하고
이러한 0과 1을 이해하는 코드를 작성하면
단순히 0과 1을 보는 것뿐만 아니라
A, B, C를 보고, 색상을 보고, 영상을 보고,
소리를 들을 수 있습니다.
이러한 0과 1을 해석하는 코드를 작성한다면 말이죠.

And indeed, it's worth noting now that same pattern
I keep using for an example, 72, 73, 33, how does a computer know?
Is that the message hi?
Is that the color yellow?
Is it a dot in a video alone?
Just depends on the context.
Simply put, if you're opening that pattern of zeros and ones
with Excel or a calculator program, odds are
the software will interpret those three bytes as numbers, of course.
If, though, you open that same pattern in a text messaging program,
Google Docs, Microsoft Word, that same pattern
will be interpreted as a sequence of letters.
Instead, if you open Photoshop, that same pattern,
you'll probably see a single dot that happens to be yellow.
Conversely, once you yourself are a programmer or even better programmer,
you will be able to write in code how you want the computer to treat
these patterns of zeros and ones.
You can essentially tell the computer, use this to store a number or a letter
or a color or something else.
That's the power the programmer themselves have at the end of the day.
Other questions on representing things with bits?
No?
All right.
그리고 실제로, 지금 주목할 만한 점은 제가 계속해서 예로 드는 72, 73, 33과 같은 패턴을 컴퓨터가 어떻게 알 수 있을까요?
이게 '안녕'이라는 메시지인가요?
이게 노란색인가요?
이게 비디오에 있는 점인가요?
그냥 상황에 따라 다릅니다.
간단히 말해서, Excel이나 계산기 프로그램으로 0과 1의 패턴을 열면
소프트웨어는 당연히 그 세 바이트를 숫자로 해석할 것입니다.
하지만 문자 메시지 프로그램,
Google Docs, Microsoft Word에서 같은 패턴을 열면
같은 패턴이 일련의 문자로 해석될 것입니다.
반면, Photoshop에서 같은 패턴을 열면
아마도 노란색 점 하나가 보일 것입니다.
반대로, 프로그래머가 되거나 더 나은 프로그래머가 되면
컴퓨터가 이런 0과 1의 패턴을 어떻게 처리하기를 원하는지 코드를 작성할 수 있을 것입니다.

기본적으로 컴퓨터에 이것을 사용해서 숫자나 문자,
색상이나 다른 무언가를 저장하라고 명령할 수 있습니다.
결국 프로그래머가 가진 힘은 바로 그것입니다.
비트로 사물을 표현하는 것에 대한 다른 질문이 있나요?
없나요?
알겠습니다.

So lastly, then, in this middle of this black box, so to speak,
is the sort of secret sauce that solves problems,
that converts those inputs to outputs, those problems to solutions.
So what is an algorithm?
It's really just step by step instructions for solving some problem.
And indeed, I think back to my own first time in CS50
where we learned the same from Professor Brian Kernighan.
And as luck would have it, just had my 25th reunion where we pulled some video
footage from 1996.
And so we're actually fortunate to have the very first few minutes of CS50
over 25 years ago when I myself took it.
마지막으로, 이 블랙박스 한가운데에는, 말하자면
문제를 해결하는 비밀 소스가 있습니다.
입력을 출력으로, 문제를 해결책으로 변환하는 것이죠.
그럼 알고리즘이란 무엇일까요?
사실 어떤 문제를 해결하기 위한 단계별 지침일 뿐입니다.
그리고 사실, 저는 CS50에 처음 참가했을 때를 떠올립니다.
그때 브라이언 커니핸 교수님에게서 같은 내용을 배웠습니다.
그리고 운 좋게도, 제 25주년 동창회에서 1996년의 영상을 가져왔습니다.
그래서 25년도 더 전에 제가 직접 CS50에 참가했을 때의 첫 몇 분을
보실 수 있다는 것은 정말 행운입니다.

But the lessons back then, as today, are fundamentally the same.
And what's important, indeed, is to not only express yourself correctly,
but precisely, as we'll explore today.
This then is Professor Brian Kernighan, who,
years ago, very memorably introduced us and my classmates to algorithms
by actually, in class, shaving his beard.
If we could dim the lights here for Brian.
하지만 그 당시의 교훈은 오늘날과 근본적으로 같습니다.
그리고 중요한 것은 자신을 올바르게 표현하는 것뿐만 아니라
정확하게 표현하는 것입니다. 오늘 살펴보겠습니다.
브라이언 커니건 교수님은
몇 년 전, 수업 시간에 수염을 깎으시면서 저희와 제 반 친구들에게 알고리즘을 소개하신 매우 기억에 남는 분이십니다.

브라이언 교수님을 위해 조명을 어둡게 해 드리겠습니다.

[VIDEO PLAYBACK]
- The other thing that we're going to talk about in this class
is the notion of an algorithm.
An algorithm is a very precise description of how to do something.
And the operative word there is precise.
It has to be very, very, very, very precise.
And the task that I'm going to do is that I'm
going to trim my beard, which has gotten out of whack.
[비디오 재생]
- 이 수업에서 다룰 또 다른 주제는
알고리즘이라는 개념입니다.
알고리즘은 어떤 일을 하는 방법을 매우 정확하게 설명하는 것입니다.
그리고 여기서 핵심은 '정확함'입니다.
정말, 정말, 정말, 정말 정확해야 합니다.
제가 할 일은
엉성해진 제 수염을 다듬는 것입니다.

[APPLAUSE]

And I brought a variety of things which one might use to trim beards with.
[LAUGHTER]

[APPLAUSE]

[END PLAYBACK]

DAVID MALAN: So suffice it to say, I don't have much of a beard.
But I do have this here other technology known once upon a time as a phone book.
And these phone books, of course, have lots of information in them.
Happen to be storing numbers and letters in particular.
For those unfamiliar, they are storing human's names from A to Z
here in English and associated with everyone's name is a number.
So even if you've never had occasion to physically use this kind of device,
turns out it's pretty much equivalent to the contacts or the address book app
on your iOS phone or your Android phone as well.
데이비드 말란: 그러니까, 수염이 많지는 않다고만 말씀드리겠습니다.
하지만 예전에 전화번호부라고 불렸던 다른 기술도 있습니다.
물론 이 전화번호부에는 많은 정보가 담겨 있습니다.
특히 숫자와 문자를 저장하고 있죠.
잘 모르시는 분들을 위해 설명드리자면, 이 전화번호부에는 사람의 이름이 A부터 Z까지 저장되어 있습니다.
여기서는 영어로 되어 있고, 모든 사람의 이름과 관련된 숫자가 있습니다.
그래서 이런 종류의 기기를 실제로 사용해 본 적이 없더라도
iOS나 Android 휴대폰의 연락처나 주소록 앱과 거의 비슷하다는 것을 알 수 있습니다.
왜 그럴까요?

Why?
Because if you pull up your contacts, of course,
you see some familiar names here alphabetized by first name or last name.
And if you click on any of those names, you
reach the person you're presumably trying to call or text.
Pictured here then is John Harvard's, whose number here is plus
1-949-468-2750, which you're welcome to call or text at your leisure.
But here is John Harvard that's partway through the phone book digitally.
Well, it turns out that physically in the phone book,
we might use an algorithm, step by step instructions,
for finding John Harvard in pretty much the same way as iOS, Android,
Mac OS, Windows, or other operating systems themselves use.
So I could, when looking for John Harvard, first name, starting with J,
I could start at the beginning of the phone book
and start looking page by page by page for John Harvard.
And if he's there, I can call.
This is an algorithm.
It's indeed step by step, but that was a bug.
A few pages turned.
왜 그럴까요?
연락처를 검색하면
물론 익숙한 이름들이 성이나 이름 순으로 알파벳순으로 정렬되어 있습니다.
그리고 그 이름들을 클릭하면
전화나 문자를 보내려는 사람에게 연결됩니다.
사진은 John Harvard의 전화번호입니다.
1-949-468-2750이 더해져 있으며,
편하게 전화하거나 문자를 보내실 수 있습니다.
하지만 여기 John Harvard가 디지털 전화번호부에서 중간쯤에 있습니다.
음, 전화번호부에서 실제로는
iOS, Android, Mac OS, Windows 또는 다른 운영 체제에서 사용하는 것과 거의 같은 방식으로
 John Harvard를 찾는 알고리즘, 단계별 지침을 사용할 수 있습니다.

예를 들어, 이름이 J로 시작하는 John Harvard를 찾을 때
전화번호부 처음부터 시작하여
한 페이지씩 John Harvard를 찾을 수 있습니다.
그리고 John Harvard가 거기에 있다면 전화를 걸 수 있습니다.
이것이 바로 알고리즘입니다.
정말 단계별로 진행되는데, 그게 버그였어요.
몇 페이지 넘겼어요.

But is this algorithm correct?
Step by step, assuming I'm paying attention.
So yes, if John Harvard is in here, I will eventually
find him once I get to the J section.
Now, this is a little tedious.
It's going to take a while.
A few dozen, a few hundred pages.
So maybe I could do things a little smarter from grade school, like 2, 4, 6,
8, 10, 12, 14, 16, and so forth, going twice as fast.
Is that algorithm correct?
So no, but why?
하지만 이 알고리즘이 맞을까요?
제가 주의를 기울인다면 단계별로요.
그래서 네, 존 하버드가 여기 있다면,
J 섹션에 도착하면 결국 그를 찾을 수 있을 겁니다.
자, 좀 지루하네요.
시간이 좀 걸릴 겁니다.
수십, 수백 페이지가 걸릴 겁니다.
그래서 초등학교 때부터 좀 더 똑똑하게 할 수 있을지도 몰라요. 2, 4, 6,
8, 10, 12, 14, 16 등등, 두 배 빠르게요.
이 알고리즘이 맞을까요?
그럼 아니죠, 하지만 왜 그럴까요?

AUDIENCE: You could miss it.
DAVID MALAN: I could miss him, right?
I could just get unlucky, really, with 50/50 probability,
because John Harvard could be sandwiched between two pages.
Now, this isn't a complete loss, this algorithm.
Maybe what I could do is if I get past the J section to K,
I could double back at least one page just
to make sure I didn't miss John Harvard.
So I can still go twice as fast plus an extra step just
to make sure I didn't mess up.
So the first algorithm might take as many pages
as there are in the phone book.
So if this phone book has a thousand pages, in the worst case, if I'm not
looking for John Harvard, but someone whose name starts with Z,
might take me a thousand pages to actually get there.
Second algorithm, twice as fast.
청중: 놓칠 수도 있죠.
데이비드 말란: 놓칠 수도 있죠, 그렇죠?
사실 운이 나쁠 수도 있습니다. 50/50 확률로요.
존 하버드가 두 페이지 사이에 끼어 있을 수도 있으니까요.
이 알고리즘이 완전히 실패한 건 아닙니다.
제가 할 수 있는 건 J 섹션을 지나 K 섹션으로 이동했을 때
적어도 한 페이지는 뒤로 돌아가서
존 하버드를 놓치지 않았는지 확인하는 겁니다.
그러면 두 배 더 빨리 이동할 수 있고, 실수하지 않았는지 확인하기 위해 한 단계 더 진행할 수도 있습니다.
첫 번째 알고리즘은 전화번호부 페이지 수만큼 페이지를 사용할 수 있습니다.
즉, 이 전화번호부가 천 페이지라면, 최악의 경우, 제가 존 하버드를 찾는 게 아니라
Z로 시작하는 이름을 가진 사람을 찾는다면
실제로 그곳에 도달하는 데 천 페이지가 걸릴 수도 있습니다.
두 번째 알고리즘은 두 배 더 빠릅니다.

Literally, it might take me 500 plus one step
to get there because I'm going two at a time,
so as long as I indeed fix that bug.
But what we used to do back in the day and what
your phone is doing today, albeit digitally,
is going roughly to the middle of the phone book, looking down and realizing,
oh, I'm accidentally in the M section, so halfway through the phone book.
But what do I now know about John Harvard?
Is he to the left or to the right?
So he's obviously to the left, because J comes before M. So what
I can do literally and what your computer does
figuratively is tear the problem in half, throw half of the problem
away, leaving us now with the same fundamental problem,
but it's half as big.
So I've gone from a thousand pages suddenly to 500 pages.
And compare this to the other two, 1,000 pages, 999, 998, versus 1,000 pages,
998, 996, 994.
That's still slow.
말 그대로, 거기에 도달하려면 500걸음 이상 걸릴 수도 있습니다.
한 번에 두 걸음씩 가고 있으니까요.
그렇다면 제가 그 버그를 정말 고치기만 하면 되죠.
하지만 옛날에 하던 일, 그리고 요즘 휴대폰이 하는 일은, 비록 디지털이긴 하지만,
대략 전화번호부 중간쯤까지 가서 아래를 내려다보고는,
아, 실수로 M 섹션에 있었구나, 전화번호부 절반을 훑어보는 것과 같습니다.
하지만 지금 제가 존 하버드에 대해 뭘 알겠습니까?
그는 왼쪽에 있을까요, 오른쪽에 있을까요?
그는 분명히 왼쪽에 있습니다. J가 M보다 앞에 오니까요. 그래서
제가 말 그대로 할 수 있는 일, 그리고 컴퓨터가 하는 일은
비유적으로 문제를 반으로 쪼개서 문제의 절반을
버리는 것입니다. 그러면 근본적인 문제는 그대로 남게 되지만,
크기는 절반으로 줄어듭니다.
그래서 저는 갑자기 1,000페이지에서 500페이지로 늘어났습니다.
이걸 다른 두 개와 비교해 보세요. 1,000페이지짜리 999, 998페이지와 1,000페이지짜리 998, 996, 994페이지를 비교해 보세요.
여전히 느리죠.

I went from 1,000 to 500 in just one step of this algorithm.
What do I do next?
I go roughly to the middle here.
Oh, I went a little too far.
I'm in the E section now.
So is John Harvard to the left or right now?
So he's to the right.
So I can again tear the problem in half, throw the left half away,
knowing now that John Harvard must alphabetically be in here.
And I can divide and divide and divide and conquer this problem again and again
by using that heuristic of going left or going right.
And I dare say, if I do this correctly, I'll
eventually be left with one single page on which John Harvard's number actually
is.
이 알고리즘을 한 단계만 거치면 1,000에서 500까지 갈 수 있습니다.
다음에는 어떻게 해야 할까요?
여기서 대략 중간까지 갑니다.
아, 좀 지나쳤네요.
지금은 E 구역입니다.
그럼 존 하버드는 왼쪽에 있는 건가요, 오른쪽에 있는 건가요?
그러니까 오른쪽에 있는 거죠.
그러면 다시 문제를 반으로 쪼개서 왼쪽 절반을 버릴 수 있습니다.
이제 존 하버드는 알파벳 순서로 여기에 있어야 한다는 걸 알죠.
그리고 왼쪽으로 가느냐 오른쪽으로 가느냐 하는 휴리스틱을 사용해서 
이 문제를 계속해서 나누고, 나누고, 또 나누고, 정복할 수 있습니다.
그리고 감히 말씀드리자면, 제가 이걸 제대로 한다면
결국 존 하버드의 번호가 실제로 있는 페이지는 단 한 페이지만 남게 될 겁니다.

Or maybe he's not in the phone book at all.
So how many steps maximally might that third and final algorithm take?
It's not a thousand.
It's not even 500 or 501.
How many times can you divide a thousand pages in half again and again
and again, roughly?
AUDIENCE: I want to say nine.
DAVID MALAN: So 9, 10.
So typically 10 times, give or take.
There's a bit of rounding there because it's not a perfect power of two,
but roughly 10 times.
Like, that is fundamentally better than both of the two algorithms
because I go from a thousand pages to 500 to 250 to 125 and so
forth, literally halving the problem again and again.
So we can actually appreciate and see this even more so graphically.
And this is among the things we'll do later in the term
when we speak to not only writing correct code,
but is your code well designed?
Is it better than your previous code?
Is it better than someone else's code?
Is it better than some other product?
If you have given more thought to the algorithms and the quality thereof,
you can perhaps minimize the time required to solve problems
but no less correctly.
아니면 전화번호부에 아예 없는 걸지도 모르겠네요.
그럼 세 번째이자 마지막 알고리즘은 최대 몇 단계가 걸릴까요?
1,000페이지가 아닙니다.
500페이지도 아니고 501페이지도 아닙니다.
1,000페이지를 몇 번이나 반으로 나눌 수 있을까요?

대략적으로 몇 번이나 반복할 수 있을까요?
청중: 9번이라고 하고 싶습니다.
데이비드 말란: 9번, 10번입니다.
보통 10번 정도입니다.
완벽한 2의 거듭제곱이 아니기 때문에 약간 반올림했지만,
대략 10번 정도입니다.
두 알고리즘보다 근본적으로 더 나은 방법입니다.
1,000페이지에서 500페이지, 250페이지, 125페이지로 넘어가면서
말 그대로 문제를 계속해서 반으로 나누기 때문입니다.
그래서 우리는 이 과정을 그래픽으로 더 잘 이해하고 확인할 수 있습니다.
그리고 이는 이번 학기 후반에 우리가 다룰 내용 중 하나입니다.
단순히 올바른 코드를 작성하는 것뿐만 아니라
코드가 잘 설계되었는지도 살펴볼 것입니다.
이전 코드보다 나은가요?
다른 사람의 코드보다 나은가요?
다른 제품보다 나은가요?
알고리즘과 그 품질에 대해 더 많이 생각했다면
문제 해결에 필요한 시간을 최소화할 수 있겠지만, 그 정확성은 결코 떨어지지 않을 것입니다.

So if we have a simple xy plot here, on the y-axis or vertical
is the amount of time to solve in whatever unit
of measure, seconds, pages, however you want to count.
On the horizontal or x-axis is the size of the problem measured
in, for instance, numbers of pages.
So this would mean zero pages in the phone book.
This would mean a lot of pages in the phone book.
This would mean no time to solve.
This would mean a lot of time to solve.
What's the relationship then, among those three algorithms?
Well, the first one is essentially a straight line, a slope of one.
And if the phone book has n pages in it, we'll
describe the slope here as essentially 1 over 1 for the algorithm
with the first algorithm, turning page by page by page.
Which is to say, if we were to add one more page to the phone book next year,
first algorithm is going to take one more step.
But the second algorithm is definitely better.
따라서 여기에 간단한 xy 플롯이 있다고 가정해 보겠습니다. y축이나 세로축에는
초, 페이지 등 어떤 측정 단위로든
해결하는 데 걸리는 시간이 표시됩니다.
가로축이나 x축에는 문제의 크기가 표시됩니다.
예를 들어 페이지 수로 측정됩니다.
따라서 전화번호부 페이지가 0개라는 뜻입니다.
전화번호부 페이지가 많다는 뜻입니다.
해결할 시간이 없다는 뜻입니다.
해결할 시간이 많다는 뜻입니다.
그렇다면 이 세 가지 알고리즘 간의 관계는 무엇일까요?
첫 번째 알고리즘은 기본적으로 직선이며 기울기가 1입니다.
전화번호부에 n페이지가 있다면
여기서 기울기는 알고리즘의 기울기 1/1로 나타낼 수 있습니다.
첫 번째 알고리즘은 페이지마다 넘깁니다.
즉, 내년에 전화번호부에 한 페이지를 더 추가한다면
첫 번째 알고리즘은 한 단계 더 나아갈 것입니다.
하지만 두 번째 알고리즘이 확실히 더 좋습니다.

It's definitely faster, but it's still a straight line.
So it's going to take roughly n over 2 steps on average, because you only
have to go through half of the phone book
because you're going two pages at a time,
instead of the whole phone book in the worst case,
if someone's name is Z, to go through every page in total.
So if we actually compare these-- let me just draw some dashed lines.
Suppose that you have this many pages in the phone book.
If you just draw this vertical white line here,
it's going to take this much time in red using the first algorithm,
but it's going to literally take half as much time
in yellow for the second algorithm because you're literally
going two pages at once.
But the third and final algorithm is a fundamentally different shape.
It instead looks a little something like this.
It looks like it's flatter and flatter and flatter.
It's always increasing.
It never gets perfectly flat.
확실히 더 빠르지만, 여전히 직선입니다.
평균적으로 약 2단계에 걸쳐 n이 걸립니다.
전화번호부의 절반만 탐색하면 되기 때문입니다.
한 번에 두 페이지씩 탐색하기 때문입니다.
최악의 경우, 전화번호부 전체를 탐색하는 대신
누군가의 이름이 Z인 경우 모든 페이지를 탐색해야 합니다.
그래서 실제로 이것들을 비교해 보면… 점선을 몇 개 그려 보겠습니다.
전화번호부에 이만큼의 페이지가 있다고 가정해 보겠습니다.
여기에 흰색 수직선을 그리면
첫 번째 알고리즘을 사용하면 빨간색으로 이만큼의 시간이 걸리지만
두 번째 알고리즘을 사용하면 노란색으로 절반의 시간이 걸립니다.
말 그대로 한 번에 두 페이지를 탐색하기 때문입니다.
하지만 세 번째이자 마지막 알고리즘은 근본적으로 다른 모양입니다.
대신 다음과 같은 모습입니다.
점선은 점점 더 평평해지고 있습니다.
점선은 계속 증가하고 있습니다.
완벽하게 평평해지는 일은 없습니다.

But it grows so much more slowly as a function of phone book size.
And for those who recall their logarithms,
this would be described as log base 2 of n.
And in fact, that's where the math came from.
Log base 2 of 1,000 is roughly 10 in total,
even if you need a calculator to confirm as much.
But this shape is fundamentally different.
Why?
Well, suppose that Cambridge, where we are, and Allston,
the town across the street next year, combine their two phone books.
And they go from a thousand pages each to one phone book with 2,000 pages.
The first algorithm is going to literally take twice
as many steps or pages.
Second algorithm is going to take half as many or 50% more
because you're going two at a time.
But the third algorithm is going to barely miss a beat.
하지만 전화번호부 크기에 따라 훨씬 더 느리게 증가합니다.
로그를 기억하는 사람들을 위해 설명하자면,
이것은 n의 밑이 2인 로그라고 할 수 있습니다.
사실, 수학은 바로 거기서 유래했습니다.
1,000의 밑이 2인 로그는 총 약 10입니다.
계산기를 사용해야만 확인할 수 있다고 해도 말입니다.
하지만 이 모양은 근본적으로 다릅니다.
왜 그럴까요?
음, 우리가 있는 케임브리지와
내년 길 건너편 마을인 올스턴이 두 개의 전화번호부를 합친다고 가정해 보겠습니다.
그리고 각각 1,000페이지에서 2,000페이지짜리 전화번호부 하나로 줄어듭니다.
첫 번째 알고리즘은 말 그대로 두 배 더 많은 단계 또는 페이지가 필요합니다.
두 번째 알고리즘은 한 번에 두 개씩 처리하기 때문에 절반 또는 50% 더 많은 시간이 필요합니다.
하지만 세 번째 알고리즘은 거의 빈틈이 없을 것입니다.

Why?
Because if this is a thousand pages here and 2,000 pages is over there,
just inferring from the shape of the green line,
it's not going to be much higher on the vertical axis than the other two were.
So more specifically, if you have a 2,000 page phone book next year,
how many more steps will it take you using that third and final algorithm?
Just one, because you'll divide and conquer a 2,000 page phone book
into a 1,000 page phone book, and then you're back at the original story.
And that's the sort of power of learning algorithms.
That's the power of learning computer science and learning how to program
is to be able to navigate big data, so to speak.
Things the size of google, things the size of artificial intelligence training
data sets using better and better, more clever
algorithms that perform faster, and therefore
not only make the software more competitive,
but also make it more usable and more favorable for people like you and me
when using that software.
왜 그럴까요?
여기가 1,000페이지이고 저기가 2,000페이지라면,
녹색 선의 모양만 봐도 알 수 있듯이,
세로축에서 다른 두 페이지보다 훨씬 더 높지는 않을 겁니다.
더 구체적으로, 내년에 2,000페이지짜리 전화번호부를 만든다면
세 번째이자 마지막 알고리즘을 사용하면 몇 단계나 더 필요할까요?
한 단계만 더 거치면 됩니다. 2,000페이지짜리 전화번호부를
1,000페이지짜리 전화번호부로 나누고, 그렇게 되면 원래 이야기로 돌아가게 되니까요.
이것이 바로 알고리즘 학습의 힘입니다.
컴퓨터 과학을 배우고 프로그래밍을 배우는 힘은
말하자면 빅데이터를 탐색할 수 있는 능력입니다.
구글만큼 크고, 인공지능만큼 크고, 더 나은, 더 똑똑한 알고리즘을 사용하여 데이터 세트를 훈련시키는 것은
더 빠른 성능을 보이는 소프트웨어의 경쟁력을 높일 뿐만 아니라
저와 같은 사람들이 소프트웨어를 사용할 때 더 사용하기 편리하고 유리하게 만듭니다.

So when it comes to implementing algorithms as programmers,
as computer scientists, what you're really doing is taking these algorithms,
which might be expressed in English conceptually as we just did,
but really just translating them to code,
be it C or C++ or Python or R or Ruby or any number of other languages that exist
in the world.
But for now, let's consider how we might implement
that algorithm using something that's literally still English, but pseudocode.
Something that is still correct, but precise and finite,
as per Professor Kernighan's advice, which
is to say use your own vernacular of English and just
say what you mean but very succinctly.
프로그래머로서, 컴퓨터 과학자로서 알고리즘을 구현할 때, 실제로 하는 일은 이러한 알고리즘을 구현하는 것입니다.
이 알고리즘은 개념적으로는 방금처럼 영어로 표현될 수 있지만,
실제로는 C, C++, Python, R, Ruby 또는 세상에 존재하는 다른 수많은 언어로 코드화하는 것입니다.
하지만 지금은, 문자 그대로 영어이면서도 의사코드인 것을 사용하여 알고리즘을 어떻게 구현할 수 있을지 생각해 보겠습니다.
여전히 정확하지만 정확하고 유한한,
커니건 교수의 조언처럼,
즉, 자신만의 영어를 사용하고
의미를 매우 간결하게 표현하라는 것입니다.

There's no one way to write pseudocode.
It's not some formal language.
I'm just going to convert the steps I did intuitively to step
by step instructions as follows.
Step one, what I did was pretty much pick up the phone book.
Step two, what I did was pretty much open to middle of phone book
for the third algorithm.
Step three, look at page.
Step four, if person is on page, then, step five, call person.
If that does not prove to be the case, step six,
else if the person is earlier in the book, then
open to the middle of the left half of the book and then go back to line three.
Then, else if the person is later in the book,
open to the middle of the right half of the book and, again, go to line three.
Else, there's a fourth and final case.
If the person like John Harvard is not on the page, is not earlier,
is not later, what's the fourth scenario we'd best consider?
He's just not there.
Else we should do something specific like quit.
의사코드를 작성하는 방법은 단 하나가 아닙니다.
정식 언어가 아닙니다.
직감적으로 수행했던 단계들을 다음과 같이 단계별 지침으로 변환해 보겠습니다.
1단계, 제가 한 일은 전화번호부를 집어 드는 것이었습니다.
2단계, 제가 한 일은 세 번째 알고리즘을 위해 전화번호부 중간 부분을 여는 것이었습니다.
3단계, 해당 페이지를 확인합니다.
4단계, 해당 사람이 해당 페이지에 있으면, 5단계, 해당 사람에게 전화를 겁니다.
그렇지 않으면, 6단계,
그 사람이 책의 앞부분에 있으면,
책의 왼쪽 절반 중간 부분을 열고 세 번째 줄로 돌아갑니다.
그리고, 그 사람이 책의 뒷부분에 있으면,
책의 오른쪽 절반 중간 부분을 열고 다시 세 번째 줄로 돌아갑니다.
그렇지 않으면, 네 번째이자 마지막 경우가 있습니다.
존 하버드 같은 사람이 페이지에 없고, 더 일찍도 아니고, 더 늦게도 아닌 경우,
우리가 가장 잘 고려할 네 번째 시나리오는 무엇일까요?
그는 그냥 거기에 없습니다.
그렇지 않다면 그만두는 것과 같은 구체적인 조치를 취해야 합니다.

Now, as an aside, everyone in this room has probably
had one of these stupid technical support issues
where your phone or your laptop or your desktop computer
just freeze all of a sudden, or maybe it spontaneously reboots for no reason.
Odds are that's because not you but some other human made a mistake.
They probably wrote code working at Microsoft or Apple
or Google or somewhere else, and they didn't actually
anticipate that, oh, there could be a fourth scenario that
could happen in the real world.
자, 잠깐, 이 방에 계신 모든 분들이
휴대폰이나 노트북, 데스크톱 컴퓨터가 갑자기 멈추거나, 
아무 이유 없이 갑자기 재부팅되는 등의 어처구니없는 기술 지원 문제를 겪어보셨을 겁니다.
그럴 가능성이 높은 건 당신이 아니라 다른 누군가의 실수일 겁니다.
그들은 아마 마이크로소프트나 애플, 구글, 혹은 다른 어딘가에서 코드를 작성했을 테고, 실제로는
네 번째 시나리오가 현실 세계에서 일어날 수 있다는 걸 예상하지 못했을 겁니다.

But if there's no code that tells the computer what
to do in that fourth and final scenario, who
knows what the computer is going to do?
It might, by default, reboot.
It might, by default, freeze.
That's just a hint of the bugs, the mistakes in software to come.
But even though this is just one way to write this code,
a.k.a. pseudocode, there are some salient characteristics
that we'll use throughout today.
One, there are these verbs, these actions.
And henceforth, as aspiring computer scientists or programmers,
we're going to start to call these by what a more and more technical audience
would.
These are functions.
A function is an action or a verb.
It's like a bite-sized task that a computer can do for you.
Those then are functions in this here pseudocode.
하지만 네 번째이자 마지막 시나리오에서 컴퓨터에게 무엇을 해야 할지 알려주는 코드가 없다면, 컴퓨터가 어떻게 할지 누가 알겠습니까?
기본적으로 재부팅될 수도 있고,
기본적으로 정지될 수도 있습니다.
이것은 앞으로 소프트웨어에 나타날 버그와 실수의 단서일 뿐입니다.
하지만 이것이 이 코드를 작성하는 한 가지 방법, 즉 의사코드라고 할지라도,
오늘 내내 사용할 몇 가지 중요한 특징이 있습니다.
첫째, 동사, 즉 동작이 있습니다.
앞으로 컴퓨터 과학자나 프로그래머를 지망하는 우리는
점점 더 기술적인 사람들이 부르는 대로 이들을 부르기 시작할 것입니다.
이것들을 함수라고 부릅니다.
함수는 동작 또는 동사입니다.
컴퓨터가 여러분을 위해 해 줄 수 있는 작은 작업과 같습니다.
그러면 바로 이 의사코드에 있는 함수들이죠.

But there's other types of code in here.
There are these things here.
If else if else if else.
Those are examples of what we're going to start calling conditionals.
These are sort of proverbial forks in the road where maybe you go this way,
maybe you go this way, but you decide which way to go based on a question.
The questions that you ask are what we'll technically
call Boolean expressions named after mathematician Boole.
A Boolean expression is a question with a yes or no answer,
a true or false answer, a black or white answer, a one or zero answer.
There's two possibilities, and there's a hint of the binary underneath.
A Boolean expression is going to tell you yes or no, you
should go down that fork in the road.
Notice what's important here is that indentation mattered as a result.
Notice that on line four when I first asked if the person is on page question
mark, so to speak, I should only do line five per its indentation
if the answer is yes or true, I should only
open to the middle of the left half of the book and go back to line three
if person is instead earlier in the book.
So indentation in pseudocode and in many programming languages
has logical significance.
It tells you whether to do things or not.
하지만 여기에는 다른 유형의 코드가 있습니다.
여기에는 다음과 같은 것들이 있습니다.
if else if else if else.
이것들은 우리가 조건문이라고 부르기 시작할 것들의 예입니다.
이것들은 일종의 속담처럼 갈림길과 같습니다. 이쪽으로 갈 수도 있고,
이쪽으로 갈 수도 있지만, 질문에 따라 어느 길로 갈지 결정합니다.
여러분이 묻는 질문은 기술적으로
수학자 부울의 이름을 딴 부울 표현식이라고 부릅니다.
부울 표현식은 예 또는 아니요,
참 또는 거짓, 흑백, 1 또는 0으로 대답하는 질문입니다.
두 가지 가능성이 있으며, 그 아래에는 이진법의 힌트가 있습니다.
부울 표현식은 예 또는 아니요를 알려주고,
그 갈림길로 가야 한다고 말합니다.
여기서 중요한 점은 들여쓰기가 결과적으로 중요했다는 것입니다.
네 번째 줄에서 그 사람이 물음표 페이지에 있는지 처음 물었을 때, 말하자면
5번째 줄의 들여쓰기만 해야 한다는 점에 유의하세요.
답이 '예' 또는 '참'일 경우에만
책의 왼쪽 절반 중간까지 열고, 그 사람이 책의 앞부분에 있는 경우에만 세 번째 줄로 돌아가야 합니다.
따라서 의사코드와 많은 프로그래밍 언어에서 들여쓰기는
논리적 의미를 지닙니다.
어떤 일을 해야 할지 말아야 할지를 알려줍니다.

But there's another construct in here.
Go back to.
Go back to, which literally makes me go back to line three, potentially
again and again and again, creating some kind of cycle
or what we'll typically call a loop instead.
So even in this relatively simple real world algorithm,
we have these four fundamental characteristics of most computer
programs that we will write in this class,
and you might write beyond this class, that we have some technical jargon now
to describe them.
하지만 여기에는 또 다른 구조가 있습니다.
돌아가기.
돌아가기. 말 그대로 세 번째 줄로 돌아가서 잠재적으로
계속해서 어떤 종류의 순환을 만들거나
일반적으로 루프라고 부르는 것을 만듭니다.
따라서 이처럼 비교적 간단한 현실 세계 알고리즘에서도
대부분의 컴퓨터 프로그램은 네 가지 기본 특성을 가지고 있으며
이 수업에서 작성할 것입니다.
그리고 이 수업 이후에도 기술 용어를 사용할 수 있습니다.
이제 이러한 특성을 설명하기 위한 몇 가지 기술 용어가 있습니다.

But what's important to note is that line 8 and line 11,
even though they're saying go back to line three, go back to line three,
you might think you're running the risk of what
we'll call an infinite loop where you literally get stuck in a loop
forever, which doesn't sound like a good thing if, at some point,
you want to turn your computer off, even though it's still working.
하지만 주의해야 할 점은 8번째 줄과 11번째 줄에서
3번째 줄로 돌아가라고 말하고 있지만,
무한 루프에 빠질 위험이 있다고 생각할 수 있습니다.
말 그대로 영원히 루프에 갇히게 되는 것이죠.
어느 순간 컴퓨터가 아직 작동하고 있는데도 불구하고
끄고 싶어진다면 이는 좋은 생각이 아닙니다.

But these will not induce infinite loops.
Why?
What is happening in this particular algorithm every time we go back to line
three that guarantees eventually we will stop going back to line three?
AUDIENCE: The person is on the page, you call it.
DAVID MALAN: Exactly.
If the person is on the page, we will call them or we will quit.
But more importantly, because we keep dividing and conquering the problem,
in this case, having the phone book, having the phone book,
eventually we're going to run out of phone book, in which case, indeed,
John Harvard is either on that page or not And we will call
or we will quit instead.
So we'll see in time.
And in fact, allow me to promise.
Odds are at some point you will write code
that seems to take control over the computer for you,
where it's doing something, doing something, doing something,
and it literally won't respond to you anymore.
That's just going to be because of a mistake, a so-called bug
that you yourself will invariably have added to your code accidentally.
하지만 이것들은 무한 루프를 유발하지 않습니다.
왜 그럴까요?
이 특정 알고리즘에서는 세 번째 줄로 돌아갈 때마다 무슨 일이 일어나는 걸까요?
결국 세 번째 줄로 돌아가지 않게 되는 걸까요?
청중: 그 사람이 페이지에 있다고 하셨죠?
데이비드 말란: 맞아요.
그 사람이 페이지에 있다면, 우리는 그 사람에게 전화를 걸거나 그만둘 겁니다.
하지만 더 중요한 건, 우리가 문제를 계속해서 나누고 해결하기 때문에
이 경우처럼 전화번호부를 가지고 있다면,
결국 전화번호부가 바닥날 것입니다. 그럴 경우, 실제로
존 하버드가 그 페이지에 있든 없든, 우리는 전화를 걸거나
그 대신 그만둘 겁니다.
시간이 지나면 알게 될 겁니다.
사실, 약속드릴게요.
언젠가는 컴퓨터를 제어하는 ​​것처럼 보이는 코드를 작성할 가능성이 높습니다.
컴퓨터가 무언가를 하고, 하고, 또 하고, 또 하고,
말 그대로 더 이상 응답하지 않을 겁니다.
그건 실수, 소위 버그 때문에 그럴 겁니다.
여러분이 실수로 코드에 추가한 버그 말입니다.

But we'll show you ways for terminating it or breaking out of those conditions.
And indeed, what we'll do in just a little bit
after a break for today's lecture is explore not just these concepts,
but some of the ways you can use them to solve real and very
visual and audio problems.
하지만 우리는 그것을 종료하거나 그러한 조건에서 벗어나는 방법을 보여드리겠습니다.
그리고 실제로, 오늘 강의의 휴식 시간 후에 우리는 이러한 개념들뿐만 아니라
실제적이고 매우 시각적이며 청각적인 문제들을 해결하는 데 그것들을 사용할 수 있는 몇 가지 방법들을 살펴볼 것입니다.

But for now, let's at least connect it to something
that's been all too germane in recent months, the past few years, namely
artificial intelligence, which is a topic we'll come back to
at the end of the course, too, to give you
a sense of what the connection is with what everyone's
been talking about in the world of AI and what
it is we're going to spend the next few weeks building up to by writing code.
If you were to try to implement something like a chat bot,
for instance, that just answers questions and has
a conversation with you, you could do that using pseudocode,
and as we'll soon see, you can use C, Python, any number of other languages
too.
That pseudocode might look like this when implementing a chat bot.
You could tell the chat bot, if the student says hello to you,
then say hello back.
And the indentation, as per earlier, implies this is conditional.
Else if the student says goodbye to you, say goodbye to the student.
Else if the student asks you how you are, say you are well.
So you can just enumerate question after question after question
and just handle all of these conditional possibilities.
하지만 지금은 적어도 최근 몇 달, 몇 년 동안 너무나 밀접하게 연관되었던 주제, 즉 인공 지능과 연결해 보겠습니다. 
이 주제는 수업 마지막에 다시 다룰 예정이며, AI 세계에서 모두가 이야기해 온 것과 어떤 관련이 있는지, 
그리고 앞으로 몇 주 동안 코드를 작성하여 무엇을 만들어갈지 알려드리기 위한 것입니다. 
예를 들어, 질문에 답하고 대화를 나누는 채팅 봇과 같은 것을 구현하려고 한다면, 의사 코드를 사용하여 구현할 수 있습니다. 
곧 살펴보겠지만 C, Python 등 다양한 언어를 사용할 수도 있습니다. 채팅 봇을 구현할 때 의사 코드는 다음과 같습니다. 
학생이 안녕하세요라고 인사하면 채팅 봇에게 다시 안녕하세요라고 인사하도록 할 수 있습니다. 
앞서 언급했듯이 들여쓰기는 조건부임을 의미합니다. 
그렇지 않으면 학생이 당신에게 작별 인사를 하면, 학생에게 작별 인사를 하세요.
그렇지 않으면 학생이 당신에게 잘 지내냐고 물으면, 잘 지내고 있다고 말하세요.
그러니까 질문을 하나하나 나열하고
이 모든 조건부 가능성을 처리하면 됩니다.

But things kind of escalate quickly, especially
with the tools of today like ChatGPT.
Are we really going to have the wherewithal as programmers
to write another conditional like else if the student asks why 111 in binary
is 7 in decimal-- like, this kind of hints at,
oh my God, there's an infinite number of things
this human could ask the chat bot.
Do we really have to write an infinite number of conditionals?
That's just not possible.
Like, there's not enough time in the day,
there's not enough lines of code available.
Artificial intelligence surely needs to be able to figure some of this
out instead.
하지만 상황은 빠르게 악화됩니다. 특히 ChatGPT 같은 오늘날의 도구를 사용하면 더욱 그렇습니다.
프로그래머로서 학생이 2진수로 111이 10진수로 7인 이유를 묻는다면 else와 같은 조건문을 작성할 수 있을까요?
이런 상황은 마치
세상에, 이 사람이 채팅봇에게 물어볼 수 있는 질문이 무한하다는 것을 암시하는 것 같습니다.
정말 무한한 수의 조건문을 작성해야 할까요?
그건 불가능합니다.
하루에 시간이 부족하고
사용 가능한 코드 줄도 부족합니다.
인공지능은 분명 이런 문제를 해결할 수 있어야 합니다.
대신 말이죠.

And so indeed, this is not how you implement AI,
but rather how you implement an AI like a chat bot
is you typically train it based on lots and lots of data.
You give it lots of inputs, lots of inputs, training data,
and let it figure out what it should say in response to certain questions.
And it boils down to a lot of probability,
a lot of statistics, otherwise known now as large language models,
which, if we really peek under the hood, are actually typically implemented
with what are called neural networks inspired by the world of biology,
whereby we humans have all of these neurons that
transmit electrical signals such that my brain tells my hand to move
this way, this way, and this other way.
따라서 실제로 AI를 구현하는 방식이 아니라
챗봇과 같은 AI를 구현하는 방식입니다.
일반적으로 엄청나게 많은 데이터를 기반으로 AI를 훈련시킵니다.
엄청난 양의 입력, 수많은 입력, 그리고 훈련 데이터를 주고
특정 질문에 대한 답을 스스로 찾아내도록 합니다.
결국 많은 확률,
많은 통계, 즉 지금은 대규모 언어 모델이라고 알려진 것이 핵심입니다.
이러한 모델들은, 자세히 들여다보면, 일반적으로 생물학에서 영감을 받은 신경망으로 구현됩니다.
인간은 이러한 모든 뉴런을 가지고 있으며,
전기 신호를 전달하여 뇌가 손을 이리저리, 이리저리, 저리저리 움직이라고 명령합니다.

And so what computer scientists have been doing over
the past many years is implementing in software using literally zeros
and ones, graphs or networks, neural networks, that
look a little something like this, where each of the circles represents a neuron,
each of the arrows represents a pathway between them,
and provides as input to these networks huge amounts
of data like all of the internet, all of Wikipedia, all of the books
that it might consume as input.
그래서 컴퓨터 과학자들은 지난 수년간 0과 1로 이루어진 그래프나 네트워크, 즉 신경망을 소프트웨어로 구현해 왔습니다. 
신경망은 다음과 같은 형태입니다. 각 원은 뉴런을 나타내고, 각 화살표는 뉴런 간의 경로를 나타내며, 
이 신경망은 인터넷, 위키피디아, 책 등 방대한 양의 데이터를 입력으로 제공합니다. 이 데이터는 입력으로 사용될 수 있습니다.

And then the goal of this neural network, as per this single final neuron
right here, is to produce an answer to a question.
Maybe it's simple like, yes, no, or maybe it's something like the answer
to the 111 question or how are you or goodbye or hello or the like.
And what these neural networks do is use statistics and probability
and try to output the most probabilistically likely answer
to this question that's been asked and really just hope that it is correct.
그리고 이 신경망의 목표는, 바로 여기 있는 이 단일 최종 뉴런에 따르면,
질문에 대한 답을 생성하는 것입니다.
예, 아니요처럼 간단한 답일 수도 있고,
111번 질문에 대한 답이나
잘 지내세요, 안녕히 계세요, 안녕하세요 같은 답일 수도 있습니다.
그리고 이 신경망이 하는 일은 통계와 확률을 사용하여
질문에 대한 확률적으로 가장 가능성이 높은 답을 출력하고
그 답이 맞기를 바라는 것입니다.

There is no programmer at OpenAI or Google
or Microsoft that's trying to anticipate every one of these questions
we might ask, not only in English but in other languages as well.
So you might be wondering why there's this 8 foot duck on the stage.
So the persona that CS50's own AI takes is in fact that of a rubber duck,
because it turns out in programming circles--
and this is true long before CS50--
it has often been recommended to students and aspiring programmers
that you keep literally a physical rubber duck on your desk.
The idea being, in the absence of a friend, family member, colleague,
TA who could answer technical questions for you, if you're alone
in your room in Mather at night, you can talk to the duck, maybe door closed,
and ask the duck your questions, or, more importantly,
talk the duck through what confusion you're having.

OpenAI나 Google, Microsoft에는 영어뿐만 아니라 다른 언어로도 우리가 던질 수 있는 모든 질문을 예상하고 있는 프로그래머가 없습니다.
그러니 무대 위에 8피트(약 2.4미터)짜리 오리가 있는 이유가 궁금하실 겁니다.
CS50에 등장하는 AI의 페르소나는 사실 고무 오리입니다.
프로그래밍 업계에서는, 그리고 CS50이 시작되기 훨씬 전부터, 
학생과 프로그래머 지망생들에게 책상 위에 실제 고무 오리를 놓아두는 것을 권장해 왔습니다.
이 아이디어는 친구, 가족, 동료, 기술 조교가 없을 때,
기술적인 질문에 답해 줄 수 있는 사람이 없을 때,
밤에 Mather에 있는 방에 혼자 있을 때, 문을 닫고 오리에게 말을 걸 수 있다는 것입니다.
그리고 오리에게 질문을 하거나, 더 중요한 것은
오리에게 당신이 겪고 있는 혼란을 이야기할 수 있다는 것입니다.

And the mere act of talking through the problem,
explaining logically what you're trying to do, what you're actually doing,
and what the error actually is, invariably,
that sort of proverbial light bulb goes off and you realize, oh, I'm an idiot.
I hear in my own words where I've gone awry.
And even though this duck will never say anything back to you, that alone,
rubber duck debugging or rubber ducking, tends to be a valuable programming
technique, believe it or not.
그리고 문제를 이야기하고,
무엇을 하려는지, 실제로 무엇을 하고 있는지, 그리고
실제로 오류가 무엇인지 논리적으로 설명하는 것만으로도
어김없이, 마치 속담처럼 전구가 켜지고 "아, 내가 바보였구나"라는 생각이 듭니다.
제 말에서 제가 잘못한 부분이 드러나는 것을 듣게 됩니다.
이 오리는 당신에게 아무 말도 하지 않겠지만,
러버덕 디버깅이나 러버덕킹만으로도 가치 있는 프로그래밍 기법이 될 수 있습니다.
믿든 말든 말이죠.

But thanks to these large language models,
we have not only physical but virtual ducks as well.
And so available to you will be in this class not tools like ChatGPT
and the like, which are, through policy, disallowed.
It is not reasonable to use ChatGPT and the like.
But you are allowed and encouraged to use CS50's own AI based
tools, which resemble those same tools but know something about CS50
and aspire to behave akin to a good teaching fellow guiding you
to solutions as opposed to handing you something outright.
So this is a tool that will be available at literally
this URL throughout the course.
CS50.ai.
하지만 이러한 대규모 언어 모델 덕분에
실제 오리뿐만 아니라 가상 오리도 사용할 수 있습니다.
따라서 이 수업에서는 ChatGPT와 같은 도구는 사용할 수 없습니다.
이러한 도구는 정책상 허용되지 않습니다.
ChatGPT 등을 사용하는 것은 합리적이지 않습니다.
하지만 CS50 자체 AI 기반 도구는 사용할 수 있으며, 이 도구는 CS50과 유사하지만 CS50에 대해 어느 정도 알고 있으며
훌륭한 강사가 무언가를 직접 제공하는 것이 아니라 해결책을 안내하는 것처럼 행동하는 것을 목표로 합니다.
따라서 이 도구는 수업 내내
이 URL에서 바로 사용할 수 있습니다.
CS50.ai.

It will also be embedded in the programming environment you'll soon
meet, which is called Visual Studio Code, a cloud based version thereof.
The duck will live in that environment as well, as well as on stage from time
to time, which is to say we'll not only talk about, but use
throughout the course this thing known as AI.
But this is ultimately code that we're going to start writing next week.
And unfortunately, this code here is written
in a language called C. This is essentially the program that I lost
two points on some 25 plus years ago.
It does look admittedly cryptic.
That's why today what we'll focus on is not what this code looks like,
nor the zeros and ones that that code gets converted to so your computer
can understand as input what you want it to do.
We're going to focus on a much more visual incarnation of this.
But I know thus far this has been a lot.
So let's go ahead and take a five minute break here,
and when we come back in five, we'll do some actual programming.
So see you in five.
All right.

곧 만나게 될 프로그래밍 환경인 Visual Studio Code(클라우드 기반 버전)에도 내장될 예정입니다.
오리도 그 환경에서 살아갈 것이고, 가끔 무대에도 등장할 것입니다.
즉, AI라는 것에 대해 이야기할 뿐만 아니라 강의 전체에서 직접 사용할 것입니다.
하지만 궁극적으로는 다음 주부터 이 코드를 작성하기 시작할 것입니다.
그리고 안타깝게도 이 코드는 C라는 언어로 작성되었습니다.
이 프로그램은 제가 25년 전에 두 점을 감점했던 바로 그 프로그램입니다.
사실 좀 난해해 보입니다.
그래서 오늘 우리가 집중할 부분은 이 코드가 어떻게 생겼는지,
컴퓨터가 입력으로 이해할 수 있도록 0과 1로 변환되는 방식에 대한 것이 아닙니다.
이 코드는 훨씬 더 시각적으로 구현될 것입니다.
하지만 지금까지는 많은 것을 해냈다는 것을 알고 있습니다.
그럼 여기서 5분 정도 휴식을 취하고,
5분 후에 다시 돌아와서 실제 프로그래밍을 해 보겠습니다.
그럼 5분 후에 뵙겠습니다.
좋습니다.
==============================================================
So it's now time to solve with actual code some actual problems,
albeit in a fun and visual and audio way.
But recall that where we left off was this.
Starting next week, you'll be writing code that ultimately looks like this,
but thankfully, you will not be writing zeros and ones,
and no normal person, myself included, can
understand what all of these zeros and ones are at a glance.
We could take out some paper, pencil, and probably
figure it out very tediously.

이제 실제 코드를 사용하여 몇 가지 실제 문제를 해결해 볼 차례입니다.
재미있고 시각적이며 청각적인 방식으로 말이죠.
하지만 여기서 멈췄다는 점을 기억하세요.
다음 주부터는 궁극적으로 이와 같은 코드를 작성하게 될 것입니다.
하지만 다행히 0과 1을 쓰지는 않을 것입니다.
그리고 저를 포함한 일반인은
이 모든 0과 1이 무엇인지 한눈에 이해할 수 없습니다.
종이와 연필을 꺼내서
아마도 아주 지루하게 생각해 낼 수 있을 것입니다.

But this is exactly the point.
Computers only understand this stuff, but what we as programmers
will start writing today and beyond is code at a higher level.
And indeed, this is going to be--
this is going to be frequent within computer science
where there's different levels of abstraction that we operate at.
And the lowest level, the nittiest gritty, is like the zeros and ones
that computer understand.
하지만 바로 이것이 핵심입니다.
컴퓨터는 이러한 것만 이해하지만, 우리 프로그래머는
오늘부터, 그리고 앞으로 더 높은 수준의 코드를 작성하게 될 것입니다.
그리고 실제로, 이러한 일은 컴퓨터 과학 분야에서 자주 발생할 것입니다.
컴퓨터 과학에는 다양한 수준의 추상화가 존재합니다.
그리고 가장 낮은 수준, 가장 핵심적인 것은 컴퓨터가 이해하는 0과 1과 같은 것입니다.

That's it in this class for zeros and ones.
Hopefully you at least have wrapped your mind
around why zeros and ones can be used in triples
and as bytes to represent higher and higher numbers.
But let's just now agree that computers can do that.
Let's abstract away from that detail and focus
on higher level languages than zeros and ones, namely a language like this.
So this is an example of the very first programming
language I learned back in the day as per that homework in a language called
C.
이 수업에서 0과 1에 대해 다룹니다.
적어도 0과 1이 트리플(triple)로, 그리고 더 높은 숫자를 나타내는 바이트로 사용될 수 있는 이유를 이해하셨기를 바랍니다.
하지만 지금은 컴퓨터가 그렇게 할 수 있다는 것에 동의해 봅시다.
그런 세부적인 내용은 잠시 접어두고
0과 1보다 더 높은 수준의 언어, 즉 이런 언어에 집중해 보겠습니다.
그래서 이건 제가 예전에 숙제로 배운 최초의 프로그래밍 언어의 한 예입니다.
C라는 언어입니다.

It's an older language, but it remains one of the most popular languages
in omnipresent languages nowadays because it's incredibly fast
and it's particularly good at making devices operate quickly.
For us pedagogically, the value of C is not
that you're probably in Silicon Valley and other such jobs
going to be using C yourself that much, but because it's
going to provide a conceptual foundation on top of which we introduce
other languages, like Python, which is newer and improved, so to speak,
that gives you more and more functionality for free out of the box
by abstracting away some of the stuff we'll focus on in the coming days first.
So at the end of the day, you should better
understand languages like Python and JavaScript
and SQL because of your underlying understanding of a language like C.
But this is too much for the first day.
Many of you will think that this is too much for the second week.
But in fact, C is really only sort of scary
looking because all of this darn punctuation and syntax, the semicolon,
the parentheses, the double quotes, the curly braces, and the like.
오래된 언어이긴 하지만, 놀라울 정도로 빠르고 특히 기기의 빠른 작동을 가능하게 하기 때문에 
오늘날 널리 쓰이는 언어 중 가장 인기 있는 언어 중 하나입니다.
저희에게 C의 교육적 가치는 실리콘 밸리나 그와 비슷한 직종에서 C를 많이 사용한다는 것이 아니라,
 C가 개념적 기반을 제공해 주기 때문입니다.
Python과 같은 다른 언어들을 소개할 수 있습니다. 
Python은 새롭고 개선된 언어라고 할 수 있습니다.
Python은 앞으로 며칠 동안 집중적으로 다룰 내용 중 일부를 추상화하여 더 많은 기능을 무료로 제공합니다.
따라서 결국에는 C와 같은 언어에 대한 기본적인 이해를 바탕으로 Python, JavaScript, SQL과 같은 언어를 더 잘 이해하게 될 것입니다.
하지만 첫날에는 너무 벅차고, 
둘째 주에는 너무 벅차다고 생각하실 수도 있습니다.
하지만 사실 C가 무섭게 보이는 건
이 모든 빌어먹을 구두점과 구문, 세미콜론,
괄호, 큰따옴표, 중괄호 등등 때문에 그럴 뿐이에요.

And I concur.
This is intellectually uninteresting, and a lot of the challenges early
on when learning programming is you just don't have the muscle memory
that I or some of the teaching fellows might for knowing
what symbol should be where.
But that's going to come with time and practice, I guarantee it.
What we'll do for today, though, is just throw away
all of that intellectually uninteresting detail and focus really on ideas.
And some of you might be in your comfort zone
here because if back in middle school you
were playing with a programming language called Scratch,
you were probably using at the time just to have fun in class or out of class,
making games, animations, interactive art.
What you probably didn't use it for, at least in middle school,
was to consider and explore programming languages themselves.
저도 동의합니다.
이건 지적으로 재미없는 일이고, 프로그래밍을 배우는 초기에 겪는 어려움 중 상당수는
저나 몇몇 강사들이 그러하듯이 어떤 기호가 어디에 있어야 하는지 아는 근육 ​​기억력이 없다는 것입니다.

하지만 시간과 연습을 통해 자연스럽게 익혀질 거라고 장담합니다.
하지만 오늘 우리가 할 일은
지적으로 재미없는 그런 세부 사항들을 다 버리고 아이디어에 집중하는 것입니다.
그리고 여러분 중 일부는 지금쯤은 익숙할지도 모릅니다.
중학교 시절에 스크래치라는 프로그래밍 언어를 사용했다면
아마도 수업 시간이나 수업 외 시간에 게임, 애니메이션, 인터랙티브 아트를 만들며 재미 삼아 사용했을 테니까요.
적어도 중학교 시절에는 스크래치를 활용하지 않았을 텐데,
프로그래밍 언어 자체를 생각하고 탐구하는 데는 사용하지 않았을 겁니다.

But what's wonderful about Scratch, which is this graphical programming
language from down the street at MIT, where it was invented some years ago,
is you can program not by using your keyboard per se,
but by dragging and dropping puzzle pieces, otherwise known as blocks,
that will snap together if it makes logical sense to do so.
And what you won't have to deal with is parentheses and double quotes
and semicolons and all of that, at least until next week.
하지만 스크래치의 멋진 점은 MIT에서 몇 년 전 발명된 그래픽 프로그래밍 언어입니다.
키보드를 직접 사용하는 것이 아니라
블록이라고도 하는 퍼즐 조각을 끌어다 놓아서 프로그래밍할 수 있다는 것입니다.
논리적으로 타당하다면 블록들이 딱 맞춰집니다.
그리고 다음 주까지는 괄호, 큰따옴표, 세미콜론 같은 것들을 다룰 필요가 없습니다.

But the nice thing about Scratch is that after this week
and after the so-called problem set zero,
the first assignment in which you'll use Scratch,
you'll have a mental model via which it will be easier to pick up
all of the subsequent syntax as well.
So let's see how we can start programming in Scratch
by making the simplest of programs first.
You can do this at scratch.mit.edu.
You needn't do this now in the moment.
Problem set zero will walk you through all of these steps.
하지만 스크래치의 좋은 점은 이번 주, 그리고 스크래치를 사용하는 첫 번째 과제인 소위 문제 세트 0을 마치면
모든 구문을 더 쉽게 익힐 수 있는 멘탈 모델이 생긴다는 것입니다.
그럼 스크래치 프로그래밍을 시작하는 방법을 알아보겠습니다.
가장 간단한 프로그램부터 만들어 보세요.
scratch.mit.edu에서 만들 수 있습니다.
지금 당장 만들 필요는 없습니다.
문제 세트 0은 이 모든 단계를 안내합니다.

But what I've done here is opened up at scratch.mit.edu, precisely
the default web page therein.
This is after having clicked the Create button
in Scratch, which is going to allow me to create my first program.
하지만 제가 여기서 한 일은 scratch.mit.edu에서 열렸습니다.
바로 그 안의 기본 웹 페이지입니다.
Scratch에서 '만들기' 버튼을 클릭한 후의 모습입니다.
이 버튼을 클릭하면 첫 번째 프로그램을 만들 수 있습니다.

But first, a tour of the user interface here,
and what is ultimately available to you.
Well, within the Scratch environment, we'll
see a few different regions of the screen.
One, we have this palette of puzzle pieces at left.
The blue ones relate to motion, the purple ones relate to looks,
the pink ones relate to sound, and so forth.
So the color of the blocks just roughly categorizes
what that block's purpose in life is.
We're going to be able to use those puzzle pieces by dragging and dropping
them from left to right.
In the right here, in the middle of the screen
is where I'm going to write my actual programs.
This is where I'll drag and drop these puzzle pieces,
lock them together, and actually write my code.
하지만 먼저, 사용자 인터페이스와
궁극적으로 여러분이 사용할 수 있는 기능에 대해 살펴보겠습니다.
스크래치 환경 내에서는
화면의 여러 영역을 살펴보겠습니다.
첫째, 왼쪽에 퍼즐 조각 팔레트가 있습니다.
파란색은 동작, 보라색은 모양,
분홍색은 소리 등을 나타냅니다.
블록의 색상은
해당 블록의 용도를 대략적으로 나타냅니다.
퍼즐 조각들을 왼쪽에서 오른쪽으로 드래그 앤 드롭하여 사용할 수 있습니다.
오른쪽, 화면 중앙에는
실제 프로그램을 작성할 공간이 있습니다.
여기서 퍼즐 조각들을 드래그 앤 드롭하고
맞춰서 코드를 작성합니다.

What am I going to be coding?
Well, I'm going to be controlling one or more sprites.
Much like in the world of games are familiar, a sprite is like a character
that you might see on the screen.
The default character in the world of Scratch
is, in fact, a cat that looks like this.
And if in this case, I have just one cat,
I can then make that cat do things in his own little world at top right
by making the cat move up, down, left, right,
spinning around, or doing other things as well.
But if you want to introduce a dog or a bird
or any number of other custom characters, you just add more sprites
and they get their own place in that same world.
무엇을 코딩할까요?
음, 하나 이상의 스프라이트를 제어할 겁니다.
우리가 흔히 아는 게임 세계처럼, 스프라이트는 화면에 보이는 캐릭터와 같습니다.
스크래치 세계의 기본 캐릭터는
사실 이렇게 생긴 고양이입니다.
그리고 이 경우 고양이가 한 마리뿐이라면
오른쪽 상단의 작은 세상에서 그 고양이가 위, 아래, 왼쪽, 오른쪽으로 움직이거나
회전하거나
다른 동작을 하도록 만들 수 있습니다.
하지만 개나 새 또는
다른 여러 커스텀 캐릭터를 추가하고 싶다면 스프라이트를 더 추가하기만 하면 됩니다.
그러면 같은 세상에서 각자의 자리를 차지하게 됩니다.

As for how to think about movement in this world,
it's actually pretty familiar, even though it
gets a little numeric for a moment.
If Scratch at the moment is in the middle of the screen, the cat is at 0, 0
if you think about x, y-coordinates or latitude longitude.
If you move the cat all the way up, this would still be x equals 0,
but it would be y 180.
What's the 180?
180 pixels vertically or dots on the screen.
This is negative 180 pixels on the screen at the bottom.
By contrast, if you go left and right, your x value might change.
Negative 240, but y is 0, or positive 240 and y is 0 as well.
But most of the time you won't need to know or care about what
the pixel coordinates of the cat are.
이 세계에서 움직임을 어떻게 생각하는지에 대해서는,
사실 꽤 익숙하지만,
잠시 숫자처럼 느껴지기도 합니다.
스크래치가 현재 화면 중앙에 있다면, 고양이는 0, 0에 있습니다.
x, y 좌표나 위도 경도를 생각해 보면 말이죠.
고양이를 맨 위로 옮기면 x는 0이지만
y는 180이 됩니다.
180은 무엇일까요?
화면에서 세로로 180픽셀 또는 점입니다.
화면 하단에서 -180픽셀입니다.
반대로 좌우로 움직이면 x 값이 바뀔 수 있습니다.
-240이지만 y는 0이거나, +240이고 y도 0입니다.
하지만 대부분의 경우 고양이의 픽셀 좌표가 무엇인지 알거나 신경 쓸 필요가 없습니다.

All you're generally going to care about is the programmer, most likely,
is do you want the cat to go relatively up, down, left, or right,
and let MIT figure out the mathematics of moving this thing around
in most cases.
All right.
So let's go ahead and introduce the first of these programs
by doing something quite simple, as we did in C there, but a little more simply
by writing code as follows.
I'm going to go back to scratch.mit.edu.
I've already clicked, per before, the Create button.
And if I click on the yellow category of blocks here at left--
and I'll zoom in-- we'll see a whole bunch of yellow puzzle pieces.
And probably the most common one you will
use to write code in Scratch for just this first week is literally
when green flag clicked.
프로그래머가 가장 중요하게 생각하는 것은 아마도
고양이를 상대적으로 위, 아래, 왼쪽, 오른쪽 중 어디로 움직일지 선택하는 것일 겁니다.
그리고 MIT가 이 물체를 어떻게 움직일지에 대한 수학적인 계산을 하게 둘 겁니다.
대부분의 경우 말이죠.
좋습니다.
그럼 첫 번째 프로그램을 소개해 볼까요?
C 코드에서 했던 것처럼 아주 간단하지만, 좀 더 간단하게
다음과 같이 코드를 작성해 보겠습니다.
scratch.mit.edu로 돌아가겠습니다.
이미 이전에 생성 버튼을 클릭했습니다.
왼쪽에 있는 노란색 블록 카테고리를 클릭하면…
확대해서 보면 노란색 퍼즐 조각들이 잔뜩 보일 겁니다.
그리고 아마도 이번 첫 주 동안 스크래치에서 코드를 작성할 때 가장 많이 사용할 방법은
녹색 깃발을 클릭했을 때일 겁니다.

Why?
Well, if we go back over to the cat's world at top right,
notice that above the cat's rectangular world,
there's not only a green flag for starting,
there's a red stop sign for stopping as well.
So let's do this.
Let me go ahead and click and drag.
When green flag clicked anywhere into the middle and let go.
And now I'm going to go to looks, and it looks
like there's a whole bunch of purple puzzle pieces here.
I'm going to choose something simple like say hello, drag it.
And notice if I get just close enough, it's
going to want to magnetically snap together.
So I'll just do that and it does its thing.
The fact that there's this white oval with text
means that is an input to this, say, puzzle piece.
I can literally then change what the input
is if I want to more conventionally say hello, world.
Which in fact, according to lore, was the very first program written in C,
and nowadays in most every language, including in Brian Kernighan's book.
So hello world is generally the first program
that most any programmer first writes.
So that's it as programs go.
왜 그럴까요?
음, 오른쪽 상단의 고양이 세상으로 돌아가 보면,
고양이의 직사각형 세상 위에는
시작을 알리는 녹색 깃발뿐만 아니라
멈추라는 빨간색 정지 표지판도 있습니다.
자, 이렇게 해 봅시다.
클릭해서 드래그해 볼까요?
녹색 깃발을 가운데 아무 곳이나 클릭하고 놓으세요.
이제 모양(looks)으로 가 볼게요.
여기 보라색 퍼즐 조각들이 잔뜩 있는 것 같네요.
"안녕하세요" 같은 간단한 것을 선택하고 드래그해 볼게요.
그리고 충분히 가까이 다가가면
자석처럼 붙어서 서로 붙는 것을 볼 수 있을 거예요.
그러니까 그냥 그렇게 하면 알아서 잘 붙습니다.
텍스트가 있는 흰색 타원이 있다는 건
이 퍼즐 조각에 대한 입력이라는 뜻입니다.
그러면 입력 내용을
좀 더 관례적으로 "안녕하세요, 세상"이라고 말하고 싶다면 입력 내용을 바꿀 수 있습니다.
사실, 전설에 따르면 C로 작성된 최초의 프로그램이었고,
브라이언 커니핸의 책을 포함하여 오늘날 대부분의 언어로도 사용되고 있습니다.
따라서 Hello World는 일반적으로 대부분의 프로그래머가
처음 작성하는 프로그램입니다.
프로그램은 여기까지입니다.

Let me go ahead and zoom out here.
Let me go over to the right and click the green flag, and somewhat excitingly,
maybe underwhelmingly, we've now written a program that quite simply says
hello world on the screen.
Now let's make this a little more technical for just a moment.
What is this here puzzle piece, as I keep calling it?
It's actually a similar--
it's an incarnation one of the ideas from our pseudocode before.
What did we call those actions and verbs last time in my pseudocode?
AUDIENCE: [INAUDIBLE].
DAVID MALAN: Functions.
That's right.
여기서 확대해서 보겠습니다.
오른쪽으로 가서 녹색 깃발을 클릭해 보겠습니다. 
그러면 다소 신나는, 어쩌면 실망스러울지도 모르지만, 화면에 "hello world"라고 아주 간단하게 표시하는 프로그램을 작성했습니다.
이제 잠시 더 기술적으로 설명해 보겠습니다.
제가 계속 부르는 이 퍼즐 조각은 무엇일까요?
사실 비슷합니다.
이전 의사코드에서 사용했던 아이디어 중 하나를 구체화한 것입니다.
지난번 의사코드에서 동작과 동사를 뭐라고 불렀었죠?
청중: [들리지 않음]
데이비드 말란: 함수입니다.
맞습니다.

So these purple puzzle pieces here are indeed functions,
and some functions, as we can see, take inputs, like hello comma world.
After all, how does Scratch know what to say?
You have to provide the cat with input, which
is to say functions can indeed take inputs like this.
In this case one input, but we'll see opportunities
for passing in more input as well.
What the cat is doing though, visually on the screen here at top right,
is what's generally called a side effect.
Sometimes when you call a function, it does something visually.
And in this case, you're seeing literally a cartoon speech
bubble, hello world.
That is the side effect of this function.
여기 보라색 퍼즐 조각들은 실제로 함수이고,
보시다시피 어떤 함수들은 "안녕하세요, 콤마 월드"처럼 입력을 받습니다.
결국 스크래치는 무슨 말을 해야 할지 어떻게 알까요?
고양이에게 입력을 제공해야 합니다. 즉,
함수는 실제로 이와 같은 입력을 받을 수 있습니다.
이 경우에는 입력이 하나뿐이지만,
더 많은 입력을 전달할 수도 있습니다.
하지만 고양이가 오른쪽 상단 화면에서 시각적으로 하는 일은
일반적으로 부작용이라고 합니다.
때로는 함수를 호출하면 시각적으로 무언가를 수행합니다.
그리고 이 경우에는 말 그대로 만화 말풍선, "안녕하세요, 월드"를 보게 됩니다.
이것이 이 함수의 부작용입니다.

So if we now want to map this to our world of inputs and outputs
and see where this side effect is, this is the paradigm
I proposed at the start of class that is computer science in a nutshell
and will be the framework we use literally
throughout the class, no matter how--
no matter how the languages in particular evolve.
So what's the input to this particular program?
Well, this white oval, hello world is my input.
The algorithm, step by step instructions for solving some problem,
is implemented in code, this language called Scratch
by way of this purple puzzle piece.
And the output of that function, given this input,
is the side effect whereby the cat indeed says hello world visually
on the screen in that speech bubble.
이제 이것을 입력과 출력의 세계에 매핑하고
이 부작용이 어디에 있는지 보고 싶다면, 이것이 바로 제가 수업 초반에 제안했던 패러다임입니다. 간단히 말해 컴퓨터 과학입니다.
그리고 이 프레임워크는 수업 내내, 어떤 방식으로든, 어떤 언어가 어떻게 발전하든
말 그대로 사용될 것입니다.
그렇다면 이 특정 프로그램의 입력은 무엇일까요?
음, 이 하얀색 타원, "안녕하세요, 세상"이 제 입력입니다.
알고리즘, 즉 어떤 문제를 해결하기 위한 단계별 지침은
스크래치라는 언어로 코드로 구현되어 있습니다.
이 보라색 퍼즐 조각을 통해서요.
그리고 이 입력을 바탕으로 해당 함수의 출력은
부작용입니다. 고양이가 화면의 말풍선에 "안녕하세요, 세상"이라고 시각적으로 말하는 것입니다.

So the exact same paradigm with which we began today
governs how exactly this cat here works.
Well, let's actually go back to this program
and make it a little more interesting than that.
Let me go ahead and click the red stop sign.
And let me actually use a different type of puzzle piece, another function that
does something a little different.
First, I'm going to get rid of the say block.
So I'm going to not only pull it away, I'm
going to drag it over anywhere at left and just let go
and it will delete itself automatically.
Or I could right click or Control click, and from a little menu
I could also explicitly say delete.
And what I'm going to do now is under sensing,
which is a light blue shade of puzzle piece-- there's a whole bunch here,
but I'm going to focus on this one.
오늘 시작했던 것과 똑같은 패러다임이
이 고양이의 작동 방식을 결정합니다.
음, 이 프로그램으로 돌아가서
좀 더 흥미롭게 만들어 봅시다.
빨간색 정지 신호를 클릭해 보겠습니다.
그리고 다른 종류의 퍼즐 조각, 즉 조금 다른 기능을 하는 함수를 사용해 보겠습니다.
먼저, say 블록을 제거하겠습니다.
그냥 떼어내는 게 아니라
왼쪽 아무 데나 드래그해서 놓으면
자동으로 삭제됩니다.
아니면 마우스 오른쪽 버튼을 클릭하거나 Control 키를 누른 상태에서 클릭하고 작은 메뉴에서
명시적으로 삭제를 선택할 수도 있습니다.
그리고 지금 할 일은 언더 센싱입니다.
퍼즐 조각의 밝은 파란색 음영입니다. 여기에는 여러 가지가 있지만
이것에 집중하겠습니다.

Ask something and wait.
And the default text is, what's your name?
And that's fine.
But because it's a white oval, that input
can be manually changed by me if I wanted to change the question.
I'm going to drag it over here.
It's going to magnetically snap together.
And I'm OK with that question.
But what do I want to say with the answer?
Well, let's go ahead and do this.
I could go to looks again.
I could grab another say block, let it snap in,
and I could say something like, hello, David.
But this is going to be the first of many bugs that I make,
intentionally or otherwise.
Let me click the green flag.
Scratch is now, just like in a web browser, prompting me for some input
here.
So let me go ahead and type in my name.
David.
Enter.
And voila.
It works.
뭔가 물어보고 기다리세요.
기본 텍스트는 "이름이 뭐니?"입니다.
괜찮습니다.
하지만 흰색 타원이기 때문에
질문을 바꾸고 싶다면 제가 직접 입력란을 바꿀 수 있습니다.
여기로 끌어다 놓겠습니다.
자석처럼 딱 맞춰질 겁니다.
이 질문은 괜찮습니다.
하지만 대답으로 뭐라고 말하고 싶나요?
자, 이렇게 해 봅시다.
다시 "looks"로 갈 수도 있습니다.
다른 say 블록을 가져와서 끼워 넣고
"안녕, 데이비드"라고 말할 수도 있습니다.
하지만 이건 제가 의도적이든 아니든 만드는 수많은 버그 중 첫 번째가 될 겁니다.
녹색 깃발을 클릭해 봅시다.
스크래치가 웹 브라우저처럼 입력을 요청합니다.
여기요.
자, 제 이름을 입력해 볼까요?
데이비드.
입력.
그리고 짜잔!
작동합니다.

Hello, David.
I'm kind of cheating, though, right?
Because if I zoom out, stop, and play again.
Let me type in Julia's name here, enter, and it still says hello, David.
So that didn't really implement the idea that I wanted.
All right, so how can I fix this?
Well, it seems that this time I want more than a side effect.
I want to use the value that the human types in.
And for this, we need another feature of functions,
which is that not only can they sometimes have side effects,
something visually happens.
Some functions can hand you back a value, a so-called return value,
that will allow you to actually reuse whatever the human typed in.
안녕하세요, 데이비드.
하지만 제가 좀 속이는 것 같죠?
확대 축소하고, 멈췄다가 다시 재생하면
여기에 줄리아의 이름을 입력하고 엔터를 눌러도 여전히 "안녕하세요, 데이비드"라고 나오네요.
제가 원했던 아이디어는 구현되지 않았네요.
좋아요, 어떻게 고칠 수 있을까요?
음, 이번에는 단순한 부작용 이상의 것을 원합니다.
사람이 입력한 값을 사용하고 싶습니다.
그리고 이를 위해 함수의 또 다른 특징이 필요한데,
그것은 때때로 부작용을 일으킬 뿐만 아니라
시각적으로 무언가가 발생한다는 것입니다.
어떤 함수는 반환 값이라고 불리는 값을 반환할 수 있는데,
이 값을 통해 사람이 입력한 내용을 실제로 재사용할 수 있습니다.

So a return value is something that gets virtually handed back to you
and you can store it in something called a variable, like x, y, and z
in mathematics, and you can generally reuse it one or more times.
So let me actually draw our attention then
to, at left, not only the blue puzzle piece, ask what's your name and wait,
but notice that there's a special puzzle piece below it,
this blue oval called answer, and that represents what a computer
scientist would call a return value.
So MIT has kind of bundled it together side by side
to make clear that one of those pieces relates to the other.
What it means is that I can do this.
I can drag this oval and use this oval as the input to the save function.
Now, notice it's not the same size, but it is the right shape, so that's OK.
Scratch will grow or shrink things to fit properly.
But this too isn't quite right.
Let me go ahead and do this.
Let me go ahead and stop that, click the green flag.
I'll type in my name again.
D-A-V-I-D. Enter.
반환 값은 사실상 여러분에게 되돌려지는 값입니다.
수학에서는 x, y, z와 같은 변수에 저장할 수 있으며, 일반적으로 한 번 이상 재사용할 수 있습니다.
자, 이제 왼쪽에 있는 파란색 퍼즐 조각에 주목해 보겠습니다. 이름이 뭐냐고 묻고 기다리세요.
그리고 그 아래에는 특별한 퍼즐 조각이 있습니다.
답변이라고 불리는 파란색 타원이 있는데, 컴퓨터 과학자가 반환 값이라고 부르는 것을 나타냅니다.
MIT는 이 조각들을 나란히 묶어서
한 조각이 다른 조각과 연관되어 있음을 명확히 했습니다.
즉, 이렇게 할 수 있다는 뜻입니다.
이 타원을 드래그하여 저장 함수의 입력으로 사용할 수 있습니다.
자, 크기가 같지는 않지만 모양이 정확하니 괜찮습니다.
스크래치는 크기를 조절해서 크기를 적절하게 맞춥니다.
하지만 이것도 완전히 정확하지는 않습니다.
자, 이렇게 해 보겠습니다.
그럼 그만하고, 녹색 깃발을 클릭해 볼까요?
제 이름을 다시 입력할게요.
D-A-V-I-D. 입력.

And it's just kind of weird or rude.
Like, I wanted a hello at least, and it just said David on the screen.
OK, so I can fix that.
Let me stop with the red stop sign.
Let me just separate these temporarily.
And I can leave it in the middle there, but they
have no logical connection temporarily.
Let me go back up to looks.
Let me grab a say block, a second one, and let me go ahead
and say, just to be grammatical, hello, space.
And then I'll reconnect this here.
So at the moment it looks like what I want, I want a hello, comma,
and then the return value printed out based on whatever the human typed in.
So let me zoom out.
Let me click the green flag.
Again, what's your name?
D-A-V-I-D. And watch the cat's side effect.
Enter.
좀 이상하거나 무례한 것 같아요.
예를 들어, 적어도 안녕하세요라고 쓰고 싶었는데 화면에 데이비드라고만 나오더라고요.
좋아요, 이제 고칠 수 있겠네요.
빨간 정지 신호는 그만하고요.
잠깐 분리해 볼게요.
중간에 놔둘 수도 있지만,
잠시 논리적인 연결은 없어요.
다시 외모로 돌아가 볼게요.
두 번째 say 블록을 하나 가져와서
문법적으로는 안녕하세요, 공백을 넣어서 말할게요.
그리고 이걸 여기서 다시 연결할게요.
지금은 제가 원하는 것처럼 보이는데, 안녕하세요, 쉼표,
그리고 사람이 입력한 내용에 따라 반환 값이 출력되길 원합니다.
자, 축소해 볼게요.
녹색 깃발을 클릭해 볼게요.
다시 한번, 이름이 뭐니?
데이비드. 그리고 고양이의 부작용을 보세요.
들어가세요.

It's still not greeting me properly.
There's no hello.
And if in case it was too fast, let's do it again.
Green flag.
D-A-V-I-D. Enter.
It rudely just says my name, which is weird.
What's the bug here, though?
It's a little more subtle.
Why?
Yeah?
AUDIENCE: It's just quickly going.
DAVID MALAN: Yeah.
It's just too quickly going over the say command or the say function,
in this case.
아직도 제대로 인사를 안 해요.
안녕하세요도 없어요.
그리고 혹시 너무 빨랐다면, 다시 해 볼까요?
녹색 깃발.
데이비드. 입장.
그냥 무례하게 제 이름을 부르는데, 이상하네요.
그런데 여기 버그가 뭐죠?
좀 더 미묘해요.
왜죠?
네?
청중: 그냥 너무 빨리 진행되거든요.
데이비드 말란: 네.
그냥 say 명령어나 say 함수를 너무 빨리 넘어가는 거예요.
이 경우에는요.

My Mac, your PC, your phone, it's just so darn fast.
Both are happening, but too fast for my human eyes to even notice.
So we can solve this in a number of ways.
I could actually use a different puzzle piece altogether.
In fact, MIT kind of anticipated this.
Notice the first puzzle piece in purple is say hello
for a specific number of seconds, and you
can specify not just the message, but the number
of seconds, ergo two inputs, otherwise now known as arguments to a function.
An input to a function is just an argument now.
And that would be a fix here.
I could maybe a little more explicitly do this.
I could go under events, scroll down a little bit, and-- sorry,
under control in orange, I could grab a wait block
and I could kind insert it in the middle.
And this might actually help.
So I could click on the green flag.
D-A-V-I-D. Enter.
제 맥, 당신의 PC, 당신의 휴대폰, 정말 엄청나게 빠르죠.
둘 다 일어나고 있지만, 제 인간 눈으로는 알아차리기엔 너무 빠르죠.
그래서 이 문제를 해결하는 방법은 여러 가지가 있습니다.
사실 완전히 다른 퍼즐 조각을 사용할 수도 있습니다.
사실, MIT는 이런 상황을 어느 정도 예상했습니다.
보라색으로 표시된 첫 번째 퍼즐 조각은 '안녕하세요'입니다.
특정 시간(초) 동안 말이죠.
메시지뿐만 아니라 시간(초)도 지정할 수 있습니다. 즉, 두 개의 입력, 즉 이제는 함수의 인수라고 하는 두 개의 입력이 있는 셈입니다.
함수의 입력은 이제 인수일 뿐입니다.
그리고 여기서는 이렇게 하면 문제가 해결될 겁니다.
좀 더 명확하게 할 수도 있을 것 같습니다.
이벤트로 가서 조금 아래로 스크롤해서… 죄송합니다.
주황색 컨트롤 아래에서 대기 블록을 가져와서
가운데에 삽입할 수 있습니다.
그리고 이게 실제로 도움이 될지도 모릅니다.
그러면 녹색 깃발을 클릭할 수 있습니다.
데이비드. 엔터.

Hello, David.
And I could change the timing to be a little more natural.
But what if I want the cat to just say hello, David all in one
breath, so to speak.
Well, for that I'm going to need to use a slightly different technique as
follows.
Let me go ahead and get rid of the wait.
Let me get rid of the second say block and stop the cat with the stop sign.
Let me go under operators here and let me somewhat cleverly grab this.
A join block at the bottom.
By default, it's using apple and banana as placeholders,
but those are white ovals so I can change those.
Let me drag this over the white oval for the save function and let
go, and it will snap to fill.
Let me go ahead here and type hello, comma, space instead of apple.
안녕, 데이비드.
그리고 타이밍을 좀 더 자연스럽게 바꿀 수도 있겠네요.
하지만 고양이가 마치 숨을 ​​한 번 들이마시며 "안녕, 데이비드"라고 인사하게 하고 싶다면 어떨까요?
말하자면요.
음, 그러려면 약간 다른 기법을 사용해야 할 것 같습니다.
다음과 같습니다.
기다림을 없애 보겠습니다.
두 번째 say 블록을 없애고 정지 신호로 고양이를 멈추게 하겠습니다.
여기 연산자 아래로 가서 이걸 좀 영리하게 가져와 보겠습니다.
맨 아래에 join 블록이 있습니다.
기본적으로 apple과 banana를 자리 표시자로 사용하지만
그것들은 흰색 타원이므로 변경할 수 있습니다.
저장 기능을 위해 이걸 흰색 타원 위로 끌어다 놓고 놓으면
채워집니다.
여기서 apple 대신 hello, comma, space를 입력해 보겠습니다.

And what should I do instead of banana?
AUDIENCE: Answer.
DAVID MALAN: Yeah.
So it'd be answer return value--
the return value.
So let me go under sensing again.
Let me just drag another copy of it.
And you can use these again and again and again.
They don't disappear.
I want to drag answer over banana so that the second input to join
is actually, if you will, the output of the ask block, like that.
And it snaps to fit.
So now if I go ahead and click the green flag once more.
D-A-V-I-D. Enter.
그럼 banana 대신 뭘 해야 할까요?
청중: 대답하세요.
데이비드 말란: 네.
그럼 answer 반환 값이겠네요.
반환 값 말이죠.
다시 sensing 아래로 가보겠습니다.
복사본을 하나 더 드래그하겠습니다.
이것들은 계속해서 사용할 수 있습니다.
사라지지 않습니다.
answer를 banana 위로 드래그해서 두 번째 입력이
사실 ask 블록의 출력이 되도록 하고 싶습니다.
맞춰서 맞춰줍니다.
자, 이제 녹색 깃발을 한 번 더 클릭합니다.
데이비드. 입장.

Now we have the behavior aesthetically that I cared about.
But beyond the aesthetics of this, the goal here
really was to map it to, again, this same paradigm, which we'll see here.
The algorithm and the output and the input for this example are as follows.
The input to the say block was, quote, unquote, what's your name?
The function, of course, implementing that algorithm in code
was the ask and wait block.
The output, though, of the ask block recalls not some visual side effect.
It is a return value called answer, like a variable,
a special variable like x, y, and z in math.
But in this one, we generally in programming
describe variables with actual words, not just letters.
But this output of the say block, I kind of want to make room for it
to pass it into the say block as a second argument.
이제 제가 신경 쓴 미적인 동작을 구현했습니다.
하지만 미적인 측면을 넘어, 여기서의 목표는
이것을 다시 한번, 여기에서 살펴볼 동일한 패러다임에 매핑하는 것이었습니다.
이 예제의 알고리즘, 출력, 입력은 다음과 같습니다.
say 블록의 입력은 "quote, unquote, 이름이 뭐니?"였습니다.
물론, 이 알고리즘을 코드로 구현하는 함수는
ask와 wait 블록이었습니다.
하지만 ask 블록의 출력은 시각적인 부작용을 떠올리게 하지 않습니다.
그것은 answer라는 반환 값이며, 변수와 같습니다.
수학에서 x, y, z와 같은 특수 변수입니다.
하지만 이 예제에서는 일반적으로 프로그래밍에서
단순 문자가 아닌 실제 단어로 변수를 설명합니다.
하지만 say 블록의 출력은 say 블록에 두 번째 인수로 전달할 수 있도록 공간을 마련하고 싶습니다.

So let's do this.
Let's take one step back and propose that now for the join
block that I just used.
It takes two inputs hello, space and answer.
The function in question is indeed the join block.
The output of this had better be hello, David.
What do I want to do with the output of the join block?
Well, let me clear the screen.
Let me move this over, because now the output of the join block
is going to instantly become the input to the say block
so that the output now in this multistep process
is the side effect of hello, David.
So the fact that I nested these blocks on top of one another
was very much deliberate.
If I zoom in here, notice that hello and answer are on top of join, join
is on top of the say block.
And if you think back to high school math,
this is like when you had parentheses and you
had to do the things inside parentheses before the things outside parentheses.
It's the same idea, but I'm just visually stacking them instead.
But outputs can become inputs depending on what the function there expects.
Let me pause here and see if there's any questions
about not so much what the cat is doing, but how the cat is doing this.
자, 이렇게 해 봅시다.
한 걸음 물러서서 방금 사용한 join 블록에 대해 생각해 봅시다.
이 블록은 hello, space, answer라는 두 개의 입력을 받습니다.
문제의 함수는 바로 join 블록입니다.
이 블록의 출력은 hello, David가 되어야 합니다.
join 블록의 출력으로 무엇을 하고 싶나요?
음, 화면을 비우겠습니다.
이 블록을 옮겨 보겠습니다. 이제 join 블록의 출력은
즉시 say 블록의 입력이 됩니다.
따라서 이 다단계 프로세스에서 출력은
hello, David의 부수적 효과입니다.
따라서 이 블록들을 서로 중첩시킨 것은
매우 의도적인 것입니다.
여기를 확대해 보면 hello와 answer가 join 블록 위에 있고, join은
say 블록 위에 있습니다.
고등학교 수학을 떠올려 보세요.
이것은 마치 괄호가 있고
괄호 안의 내용을 괄호 밖보다 먼저 해야 했던 것과 같습니다.
같은 개념이지만, 시각적으로 쌓아 올리는 것뿐입니다.
하지만 함수가 무엇을 기대하는지에 따라 출력이 입력이 될 수 있습니다.
여기서 잠깐 멈춰서 고양이가 무엇을 하는지가 아니라, 어떻게 하는지에 대한 질문이 있는지 살펴보겠습니다.

Questions at hand?
All right.
Well, let's make the cat more cat-like and do this.
Let me throw away all the say block and just let go there.
And let me introduce at bottom left a nice feature of scratch
whereby there's also these extensions that
tend to use the cloud, the internet, to give you even more functionality.
And in fact, I'm going to click on this extension up here, text to speech.
And if I click on that, I suddenly get a whole new category
of blocks at the bottom.
Text to speech.
They happen to be green.
But what's nice here is that I can actually now
have the cat say something audibly.
So let me drag the speak block here instead of the say block.
I don't want it to just say hello.
Let me stop that.
So let me go back under operators.
Let me grab another join block, because I threw the other one away.
Let me change apple to hello, space again.
Let me go to sensing.
Let me drag answer to banana again.
And now let me hit the green flag and let me type in my name, D-A-V-I-D.
질문 있으신가요?
좋아요.
음, 고양이를 좀 더 고양이답게 만들어 볼까요?
모든 say 블록을 버리고 그냥 놓아보겠습니다.
그리고 왼쪽 하단에 멋진 기능을 하나 소개해 드리겠습니다.
클라우드나 인터넷을 이용해서 더 많은 기능을 제공하는 확장 프로그램들이 있습니다.
사실, 여기 위쪽에 있는 TTS(텍스트 음성 변환) 확장 프로그램을 클릭해 보겠습니다.
그리고 그걸 클릭하면 갑자기 아래쪽에 완전히 새로운 블록 카테고리가 나타납니다.
TTS(텍스트 음성 변환) 블록이죠.
우연히도 초록색입니다.
하지만 여기서 좋은 점은 이제 고양이가 소리 내어 말하도록 할 수 있다는 것입니다.
그러니 say 블록 대신 speak 블록을 여기로 끌어다 놓겠습니다.
그냥 인사만 하게 하고 싶지는 않거든요.
그만 두겠습니다.
그럼 연산자 아래로 돌아가 보겠습니다.
다른 join 블록을 가져오겠습니다. 왜냐하면 다른 블록은 버렸거든요.
apple을 hello, space로 다시 바꿔 볼게요.
sensing으로 가볼게요.
answer를 다시 banana로 드래그해 볼게요.
이제 녹색 깃발을 누르고 제 이름인 D-A-V-I-D를 입력해 볼게요.

And in a moment I'll hit enter and.
COMPUTER: Hello, David.
DAVID MALAN: All right.
It's not exactly cat-like, but it was synthesized.
But it turns out under these text to speech blocks, there are some others.
Set voice to alto, for instance, seems to be the default.
But let's change this.
So notice that some puzzle pieces don't just take white ovals.
They might even have drop downs.
So whoever created that puzzle piece decided
in advance what the available choices are for that input per the dropdown.
So I'm going to change it to squeak, which sounds--
or actually kitten sounds even more apt.
Let me zoom out, click the green flag, type my name.
D-A-V-I-D. Enter.
COMPUTER: Meow, meow.
DAVID MALAN: That's interesting.
So it doesn't seem to matter what I type.
So how about David Malan.
COMPUTER: Meow, meow, meow.
DAVID MALAN: So it seems to meow proportional to how long
the phrase is that I typed in.
It can get a little creepy quickly.
If I change kitten to giant.
Let me go ahead and hit Play.
D-A-V-I-D. Enter.
잠시 후에 엔터 키를 누르겠습니다.
컴퓨터: 안녕하세요, 데이비드.
데이비드 말란: 알겠습니다.
고양이 소리처럼 들리지는 않지만 합성된 소리입니다.
하지만 이 텍스트 음성 변환 블록 아래에는 다른 블록들이 있는 것 같습니다.
예를 들어, 음성을 알토로 설정하는 것이 기본값인 것 같습니다.
하지만 이걸 바꿔 봅시다.
퍼즐 조각 중에는 흰색 타원만 있는 게 아니라는 점에 유의하세요.
드롭다운 메뉴가 있을 수도 있습니다.
그래서 퍼즐 조각을 만든 사람은
드롭다운 메뉴에 따라 해당 입력에 사용 가능한 선택지를 미리 정해 놓았습니다.
그래서 끽끽거리는 소리로 바꾸겠습니다.
사실 새끼 고양이 소리가 더 적절하겠죠.
축소해서 녹색 깃발을 클릭하고 제 이름을 입력해 보겠습니다.
데이비드. 엔터 키를 누릅니다.
컴퓨터: 야옹, 야옹.
데이비드 말란: 흥미롭네요.
그러니까 내가 뭘 입력하든 상관없는 것 같군요.
그럼 데이비드 말란은 어때요?
컴퓨터: 야옹, 야옹, 야옹.
데이비드 말란: 야옹 소리가 내가 입력한 문구의 길이에 비례하는 것 같네요.
좀 소름 돋을 수도 있겠네요.
'kitten'을 'giant'로 바꾸면 어떨까요?
재생 버튼을 눌러볼까요?
데이비드. 엔터.

COMPUTER: Hello, David.
DAVID MALAN: So you can, for very non-academic ways,
start to have fun with this, but just playing around
with these various inputs and outputs.
But let's actually make the cat do something more cat-like and indeed meow
instead of saying any words at all.
So let me throw all of that away.
Let me go now under sound.
Let me drag the play sound until done.
And notice in the dropdown here, by default, you just get the cat sound.
You can record your own sounds.
There's a whole library of dogs and birds
and all sorts of sounds you can import into the program.
I'll keep it simple with cat.
And let me click the green flag.
COMPUTER: Meow.
DAVID MALAN: All right.
So the cat meowed once.
If I want the cat to meow again, I could do this.
COMPUTER: Meow.
DAVID MALAN: If I want the cat to meow a third time, I could again hit play.
COMPUTER: Meow.
DAVID MALAN: So this is kind of tedious if to play this game,
I have to keep clicking the button, keep clicking the button
to keep the cat alive virtually in this way.
So maybe I want this to happen again and again and again.
Well, let me just do that.
Let me sort of drag and drop.
Or I could right click or Control click and then
a little menu would let me Copy-Paste or duplicate blocks.
But I'll just keep dragging and dropping.
Let's do this.
COMPUTER: Meow.
Meow.
Meow.
컴퓨터: 안녕하세요, 데이비드.
데이비드 말란: 아주 학문적인 방법은 아니지만,
다양한 입력과 출력을 가지고 놀면서 재미있게 놀 수 있습니다.
하지만 고양이가 아무 말도 하지 않고 고양이처럼 행동하게 하고, 야옹하게 해 봅시다.
그럼 이 모든 건 다 잊어버리죠.
이제 '소리'로 넘어가 볼까요?
재생 소리를 드래그해서 완성될 때까지 재생합니다.
여기 드롭다운 메뉴를 보면 기본적으로 고양이 소리만 나옵니다.
직접 소리를 녹음할 수도 있습니다.
개와 새 소리 라이브러리가 가득하고
프로그램에 가져올 수 있는 온갖 종류의 소리도 있습니다.
저는 '고양이'로 간단하게 하겠습니다.
그리고 녹색 깃발을 클릭해 보겠습니다.
컴퓨터: 야옹.
데이비드 말란: 좋습니다.
고양이가 한 번 야옹했습니다.
고양이가 다시 야옹하게 하려면 이렇게 하면 됩니다.
컴퓨터: 야옹.
데이비드 말란: 고양이가 세 번째로 야옹거리게 하려면 다시 재생 버튼을 누르면 됩니다.
컴퓨터: 야옹.
데이비드 말란: 이 게임을 하려면 좀 지루하죠.
계속 버튼을 눌러야 하고, 계속 버튼을 눌러야 합니다.
이런 식으로 고양이를 가상으로 살려내야 하니까요.
그래서 이런 일이 계속해서 반복되기를 바라는 걸까요?
음, 그냥 그렇게 해 볼게요.
드래그 앤 드롭으로 할게요.
아니면 마우스 오른쪽 버튼을 클릭하거나 Control 키를 누른 상태에서 클릭하면
작은 메뉴가 나타나서 복사-붙여넣기나 블록 복제를 할 수 있어요.
하지만 계속 드래그 앤 드롭으로 할게요.
자, 이렇게 해 볼까요.
컴퓨터: 야옹.
야옹.
야옹.

DAVID MALAN: Cat's kind of hungry, unhappy.
So let's slow things down so it's adorable again.
So let me go under control.
Let me grab one of those wait one second, and I'll plop this here.
Another one.
Let me plop it here.
Click play again.
COMPUTER: Meow.
Meow.
DAVID MALAN: Cuter.
Less hungry.
Sure.
데이비드 말란: 고양이가 좀 배고프고, 우울해 보여요.
그러니까 속도를 늦춰서 다시 귀엽게 만들어 볼까요?
그럼 제가 좀 진정할게요.
잠깐만요, 이거 하나 집어서 여기에 놓을게요.
하나 더.
여기에 놓을게요.
다시 재생을 클릭하세요.
컴퓨터: 야옹.
야옹.
데이비드 말란: 더 귀여워요.
덜 배고파요.
그럼요.

But this program is now, I daresay, correct
if my goal is to get the cat's meow three times.
But now, even if you've never programmed before, critique this program.
It is not well-designed, even though it is correct.
In other words, it could be better.
How, might you think?
Yeah?
AUDIENCE: A loop.
DAVID MALAN: So using a loop.
And why?
Why are you encouraging me to use a loop even though it works as is?
AUDIENCE: It's easier to plot.
DAVID MALAN: Yeah.
So to summarize, it's just easier to use a loop
because I could specify explicitly in one place how many times I want it
to loop.
And moreover, frankly, any time you are copying and pasting something in code
or dragging the same thing again and again, odds are you're
doing something foolish.
Why?
하지만 이 프로그램은 이제, 감히 말씀드리자면,
제 목표가 고양이 울음소리를 세 번 듣는 것이라면, 옳습니다.
하지만 프로그래밍을 해본 적이 없더라도 이 프로그램을 비판해 보세요.
올바르긴 하지만 잘 설계된 것은 아닙니다.
다시 말해, 더 나아질 수 있다는 뜻입니다.
어떻게 생각하시나요?
네?
청중: 루프입니다.
데이비드 말란: 그러니까 루프를 사용한다는 거죠.
왜요?
그냥 그대로 작동하는 루프를 왜 사용하라고 권하시는 거죠?
청중: 플롯을 짜기가 더 쉽거든요.
데이비드 말란: 네.
요약하자면, 루프를 사용하는 것이 더 쉽습니다.
왜냐하면 루프를 몇 번 반복할지 한곳에 명시적으로 지정할 수 있기 때문입니다.
그리고 솔직히 말해서, 코드에서 무언가를 복사해서 붙여넣거나
같은 것을 반복해서 드래그할 때마다
어리석은 짓을 하고 있을 가능성이 높습니다.
왜?

Because you're repeating yourself unnecessarily.
And this is a bit extreme, but suppose I want
to change this program later so that the cat pauses two seconds in between meows.
Well, obviously I can just go in here and do two.
But what if I forget?
And suppose this program isn't, like, five or six puzzle pieces.
Suppose it's 50 or 60 or 500 or 600.
Eventually I or a colleague I'm working with is going to screw up.
They're going to change a value in one place, forget to change it in another.
So why are you inviting the probability of making a mistake?
Just simplify things so that you only have to change inputs in one place.
So how can I do this?
Let me zoom out.
Let me throw most of this duplication away,
leaving me with just the play and the wait function.
Let me now, under control as well, grab one of these.
I could, for instance, repeat as follows.
Let me grab a repeat.
I'm going to have to move these in two parts.
So I'm going to move this down.
It's too small, but it will grow to fit the right shape.
Then let me reattach it up here.
Let me change the default 10 to a 3.
And now I think I've done exactly what you were encouraging, which is simplify.
And I click play now.
COMPUTER: Meow.
Meow.
DAVID MALAN: Now and.
COMPUTER: Meow.
DAVID MALAN: Yeah.
불필요하게 같은 말을 반복하고 있으니까요.
좀 극단적이긴 하지만, 제가 이 프로그램을 나중에 바꾸고 싶다고 가정해 봅시다.
고양이가 야옹거리는 사이에 2초씩 멈추도록요.
물론 여기서 두 개만 하면 되죠.
하지만 잊어버리면 어떻게 될까요?
그리고 이 프로그램이 퍼즐 조각 다섯 개나 여섯 개가 아니라고 가정해 봅시다.
50개, 60개, 500개, 600개라고 가정해 봅시다.
결국 저나 함께 일하는 동료가 실수를 할 겁니다.
한 곳에서는 값을 바꾸고 다른 곳에서는 바꾸는 걸 잊어버릴 수도 있죠.
그렇다면 왜 실수할 가능성을 감수하는 걸까요?
한 곳에서만 입력을 바꾸면 되도록 단순화하면 됩니다.
그렇다면 어떻게 해야 할까요?
한번 살펴보겠습니다.
이 중복된 부분을 대부분 없애고
재생과 대기 함수만 남겨 두겠습니다.
이제 저도 제어를 해서 이 중 하나를 선택하겠습니다.
예를 들어 다음과 같이 반복할 수 있습니다.
반복을 선택하겠습니다.
두 부분으로 나누어 옮겨야 합니다.
그래서 이것을 아래로 옮기겠습니다.
너무 작지만, 올바른 모양에 맞게 커질 것입니다.
그런 다음 여기에 다시 붙이겠습니다.
기본값인 10을 3으로 변경하겠습니다.
이제 당신이 권유했던 대로 단순화를 한 것 같습니다.
그리고 지금 재생을 클릭합니다.
컴퓨터: 야옹.
야옹.
데이비드 말란: 지금 그리고.
컴퓨터: 야옹.
데이비드 말란: 네.

So still correct, but arguably better designed as a result.
I can keep things simple and change things now in just one place
and it will continue to work.
But this is getting a little tedious now, I claim.
Like, why am I implementing the idea of meowing?
Wouldn't MIT have been better to have just implemented
a meow puzzle piece for us?
Because the whole thing is themed around a cat.
Why is there not a meow puzzle piece?
Why do I need to go through all of this complexity to build that functionality?
Well, what's nice about Scratch and what's
nice about programming languages in general
is you can generally invent your own puzzle pieces, your own functions,
and then use and reuse them.
So let me go ahead and do this.
I'm going to go under my blocks in pink down here.
I'm going to go ahead and click make a block,
and I'm going to be prompted with this interface here.
And I'm going to call this block literally meow, because apparently MIT
forgot to implement it for us.
And I'm just going to go ahead and immediately click OK.
And what you'll see now is two things.
여전히 맞지만, 결과적으로 더 잘 설계되었다고 할 수 있습니다.
이제 한 곳에서만 간단하게 변경하면 되고
계속 잘 작동할 겁니다.
하지만 이제 좀 지루해지네요.
예를 들어, 야옹이라는 아이디어를 왜 구현하는 걸까요?
MIT에서 차라리
야옹 퍼즐 조각을 구현하는 게 더 나았을 텐데 말이죠?
모든 것이 고양이를 주제로 하고 있잖아요.
왜 야옹 퍼즐 조각은 없는 걸까요?
왜 그 기능을 만들기 위해 이렇게 복잡한 과정을 거쳐야 할까요?
음, 스크래치의 장점, 그리고
일반 프로그래밍 언어의 장점은
일반적으로 자신만의 퍼즐 조각과 함수를 만들어서
사용하고 재사용할 수 있다는 것입니다.
자, 그럼 시작해 볼까요?
여기 분홍색 블록 아래로 가 볼게요.
계속해서 블록 만들기를 클릭하면
여기 이 인터페이스가 표시됩니다.
이 블록을 문자 그대로 야옹이라고 부르겠습니다. MIT에서
이 블록을 구현하는 걸 깜빡한 것 같거든요.
그러니 바로 "확인"을 클릭하겠습니다.
지금 보시는 건 두 가지입니다.

One, on the screen, I've been given this placeholder pink piece
that says define meow as follows.
So anything I attach to the bottom of that define block
is going to define the meaning of meowing.
And at top left, notice what I have under my blocks.
I now have a pink puzzle piece called meow
that is a new function that will do whatever that other block of code
tells the cat to do.
So what do I want to do here?
Well, I'm going to keep it simple for now.
I'm going to move the play sound meow until done and wait two seconds.
Though let's change it back to one second to move things along.
And now let me drag the meow puzzle piece
over to my loop such that now, what's it going to do?
It's going to meow three times.
And just to be dramatic, out of sight, out of mind.
Let me, for no technical reason, just drag
this all the way to the bottom of the screen and then scroll
back up just to make the point visually that now meowing exists.
That is an implementation detail that we can abstract away,
not caring how it exists, because I now know at a higher conceptual level,
if I want a meow, I just use the meow puzzle piece, and I or someone else
dealt with already how to implement meowing.
So now let me go ahead and hit play.
COMPUTER: Meow.
Meow.
Meow.
첫째, 화면에 분홍색 플레이스홀더 조각이 있습니다.
다음과 같이 "define meow"라고 적혀 있습니다.
이렇게 "define meow" 블록의 맨 아래에 붙이는 모든 것은
야옹의 의미를 정의합니다.
왼쪽 상단에서 블록 아래에 있는 것을 확인하세요.
이제 "meow"라는 분홍색 퍼즐 조각이 있습니다.
이것은 다른 코드 블록이 고양이에게 시키는 모든 것을 수행하는 새로운 함수입니다.
그럼 여기서 뭘 하고 싶은 걸까요?
음, 지금은 간단하게 하겠습니다.
재생 소리 "meow"를 완료될 때까지 이동하고 2초 동안 기다립니다.
하지만 진행을 위해 1초로 다시 변경하겠습니다.
이제 "meow" 퍼즐 조각을 루프로 끌어다 놓겠습니다.
이제 무슨 일이 일어날까요?
세 번 야옹 소리가 날 겁니다.
극적으로 보이면 마음에도 안 들겠죠.
기술적인 이유 없이, 이걸 화면 맨 아래로 끌어다 놓고
다시 위로 스크롤해서
이제 야옹 소리가 존재한다는 것을 시각적으로 보여드리겠습니다.
이건 구현 세부 사항인데, 어떻게 존재하는지는 중요하지 않습니다.
이제 더 높은 개념적 수준에서 야옹 소리가 필요하다면 야옹 퍼즐 조각을 사용하면 되고, 저나 다른 누군가가 이미 야옹 소리를 구현하는 방법을 알고 있기 때문입니다.
자, 이제 재생 버튼을 눌러 보겠습니다.
컴퓨터: 야옹.
야옹.
야옹.

DAVID MALAN: OK, so same exact code, but arguably better
design because I've now given myself reusable code so I don't have
to Copy-Paste those several blocks.
I can just use meow again and again.
But let's make one refinement.
Let me actually scroll down to where I did in fact implement this.
Let me Control click or right click on it
and let me edit the pink block that I created
a moment ago, because I want to practice what I've been preaching about inputs.
So I don't want this function just to be called meow.
I want this function to also take an input,
and just for consistency with our use of n earlier, which in computer science
generally means number, let me meow n times.
And just so that this puzzle piece is even more programmer friendly,
let me add just a textual label that has no technical significance
other than to make this function read left to right
in a more English friendly way.
Meow n times.
Let me click OK.
데이비드 말란: 네, 코드는 똑같지만, 더 나은 디자인이라고 할 수 있습니다.
이제 재사용 가능한 코드를 만들었기 때문에 여러 블록을 복사해서 붙여넣을 필요가 없으니까요.
그냥 meow를 계속 사용할 수 있죠.
하지만 한 가지 더 개선해 보겠습니다.
실제로 이 코드를 구현했던 부분까지 스크롤해 보겠습니다.
컨트롤 클릭이나 마우스 오른쪽 버튼을 클릭하고
방금 전에 만든 분홍색 블록을 편집해 보겠습니다.
입력에 대해 제가 계속 강조해 온 내용을 연습하고 싶거든요.
그래서 이 함수의 이름을 그냥 meow라고만 짓지 않겠습니다.
이 함수는 입력도 받도록 하고,
앞서 n을 사용했던 방식과 일관성을 유지하기 위해, 컴퓨터 과학에서 일반적으로 숫자를 의미하는 n을 n번 meow하도록 하겠습니다.
그리고 이 퍼즐 조각을 프로그래머에게 더 친숙하게 만들기 위해
기술적인 의미는 없지만 이 함수를 왼쪽에서 오른쪽으로 읽을 수 있도록 하는 텍스트 레이블을 추가하겠습니다.
영어에 더 친숙하게 말이죠.
야옹 n번.
확인을 클릭하겠습니다.

And now notice this thing at the bottom has changed such
that it's not only called meow, there's explicit mention of n,
which is a circle, which is exactly the variable shape that we saw earlier
when it was called answer.
This is not a return value, though.
This is what, again, we're going to call an argument, an input to a function.
So let me do this.
I'm going to move this back up to the top
so I can see everything in one place, and I'm
going to make one modification, because my goal now
is to make a new and improved version of meowing that actually takes into account
how many times I want the cat to meow.
So instead of using a loop in my own program under when green flag clicked,
I'm going to detach this temporarily.
I'm going to move this away.
I'm going to move this code over here, and I'm going to reattach it here.
So focusing for the moment on just the left,
meow is now defined as repeating three times the following two functions.
Play sound and wait.
이제 아래쪽에 있는 이 부분이 변경된 것을 확인하세요.
단순히 'meow'라고 불리는 것이 아니라, n이 명시적으로 언급되어 있습니다.
n은 원을 의미하는데, 앞서 answer라고 불렸던 변수 모양과 정확히 같습니다.
하지만 이것은 반환 값이 아닙니다.
다시 말하지만, 이것은 인수, 즉 함수의 입력이라고 부를 것입니다.
자, 이렇게 해 보겠습니다.
이 부분을 다시 맨 위로 옮겨서
모든 것을 한 곳에서 볼 수 있도록 하겠습니다. 그리고
한 가지 수정을 하겠습니다. 이제 목표는
고양이가 얼마나 자주 야옹할지를 고려하는 새롭고 개선된 버전의 야옹을 만드는 것입니다.
그래서 제 프로그램에서 '녹색 깃발을 클릭했을 때' 아래에 루프를 사용하는 대신
이 부분을 일시적으로 분리하겠습니다.
이 부분을 치우겠습니다.
이 코드를 여기로 옮겨서 여기에 다시 붙이겠습니다.
따라서 잠시 왼쪽에 집중해 보겠습니다.
야옹은 이제 다음 두 함수를 세 번 반복하는 것으로 정의됩니다.
소리를 재생하고 기다립니다.

But that's not quite right.
I want to get rid of the three.
So what can I do?
Because I created this input to the meow function myself a moment ago,
I can actually drag a copy of it over right
that is change the three to be generally an n.
So now I have a function called meow that will meow any number of times.
And what's nice now is my actual program that is governed by that green flag,
I can type in three, I can type in 10, I can type in 100, and it will just work.
And henceforth, I can, again, dramatically
scroll this down so we don't know or care about it anymore.
Now my program is a single line whereby this notion of meowing
has been abstracted away by just defining my own function or custom
block.
하지만 완전히 맞는 말은 아닙니다.
세 개를 없애고 싶습니다.
그럼 어떻게 해야 할까요?
방금 전에 제가 직접 야옹 함수에 이 입력을 만들었기 때문에
실제로 사본을 오른쪽으로 드래그하여
세 개를 일반적으로 n으로 바꿀 수 있습니다.
이제 야옹이라는 이름의 함수가 생겼는데, 이 함수는 몇 번이든 야옹 소리를 냅니다.
그리고 이제 좋은 점은 녹색 플래그에 의해 제어되는 실제 프로그램입니다.
세 개, 10개, 100개를 입력해도 잘 작동합니다.
그리고 앞으로는, 다시 한번, 극적으로
스크롤을 내려서 더 이상 알거나 신경 쓰지 않아도 됩니다.
이제 제 프로그램은 한 줄로 구성되어 있으며, 야옹이라는 개념은
직접 함수나 사용자 정의 블록을 정의함으로써 추상화되었습니다.

Questions, then, about just this idea, this principle
of creating your own functions to hide implementation details once you've
solved a problem?
Therefore, you don't want to have to think about that same problem
ever again.
And that's the beauty of programming, typically.
Questions on what here we just did?
No?
All right.
Well, let's do this.
그렇다면 이 아이디어, 즉 문제를 해결한 후 구현 세부 사항을 숨기기 위해 직접 함수를 만드는 원리에 대해
궁금하신가요?
그러니까 같은 문제에 대해 다시는 고민하고 싶지 않을 겁니다.
그리고 그것이 바로 프로그래밍의 묘미죠.
방금 무슨 일을 했는지 궁금하시죠?
없나요?
좋아요.
자, 시작해 볼까요?

Let's now make this a little more interactive in code.
Let me go to this green flag.
Let me scroll down and just throw all of this hard work
away that we have copies on the courses website of all of these programs step
by step if you want to review them in slower detail.
Let's do this.
Under control, turns out there's other ways to loop.
There's this forever block that will just do something forever.
So in the forever block, there's some place for some other code.
And I'm going to move to the control section
here and grab one of these if blocks, so one of these conditionals.
Let's plug that in here.
And now notice if, and then there's this sort of trapezoid-like placeholder
that's going to probably fit what?
The if is a conditional.
Forever is a loop.
이제 코드에서 좀 더 상호작용적으로 만들어 보겠습니다.
이 녹색 깃발을 보겠습니다.
아래로 스크롤해서 이 모든 어려운 작업은 잊어버리겠습니다.
코스 웹사이트에 이 모든 프로그램의 단계별 복사본이 있습니다.
원하시면 천천히 자세히 살펴보실 수 있습니다.
시작해 봅시다.
제어 하에, 반복하는 다른 방법들이 있다는 것이 밝혀졌습니다.
영원히 무언가를 하는 forever 블록이 있습니다.
그러니 forever 블록 안에 다른 코드를 넣을 공간이 있습니다.
그리고 제어 섹션으로 이동하겠습니다.
여기서 if 블록 중 하나, 즉 조건문 중 하나를 가져옵니다.
여기에 넣어 보겠습니다.
그리고 if를 보세요. 그리고 사다리꼴 모양의 자리 표시자가 있습니다.
아마 무엇에 들어갈까요?
if는 조건문입니다.
Forever는 반복문입니다.

Say and so forth have been functions.
What was the other key term we used?
So a Boolean expression.
We need to put one of those yes, no or true, false questions here.
So what are those?
Well, I've been using Scratch for some years,
so I under sensing there's one of these shapes here.
Touching mouse pointer, question mark.
The question mark literally evokes the whole idea of a Boolean expression
being yes, no.
It's way too big to fit, but it is the right shape.
So let me drag it.
Let go.
It's going to grow to fill.
And now let me go to sound.
Let me grab that play sound, meow until done,
and put it inside that conditional such that what kind of program
have I just implemented here, arguably?
What will this program do when I click the green flag?
Say 등은 함수였습니다.
우리가 사용한 또 다른 핵심 용어는 무엇이었을까요?
즉, 부울 표현식입니다.
여기에 예, 아니요 또는 참, 거짓 질문 중 하나를 넣어야 합니다.
그럼 그게 뭐죠?
음, 저는 몇 년 동안 스크래치를 사용해 왔는데,
여기에 이런 모양 중 하나가 있다는 걸 감지했습니다.
마우스 포인터를 터치하면 물음표가 표시됩니다.
물음표는 말 그대로 부울 표현식의 전체적인 개념을 떠올리게 합니다.
예, 아니요입니다.
너무 커서 들어가지 않지만, 적절한 모양입니다.
자, 드래그해 보겠습니다.
놓으세요.
채워질 때까지 커질 겁니다.
이제 소리로 넘어가 볼까요.
소리 재생, 끝날 때까지 야옹 소리를 선택하고
조건문 안에 넣어 보겠습니다. 그러면 제가 방금 구현한 프로그램은 어떤 종류일까요?
녹색 깃발을 클릭하면 이 프로그램은 무슨 일을 할까요?

Well, nothing at the moment.
AUDIENCE: Not touching the cat.
DAVID MALAN: But I'm not touching the cat.
So if I move the mouse pointer to the cat.
COMPUTER: Meow.
DAVID MALAN: Again.
COMPUTER: Meow.
DAVID MALAN: Again.
COMPUTER: Meow.
DAVID MALAN: It's kind of implementing the idea of petting a cat, if you will,
because I'm forever just waiting and waiting and waiting.
Is the mouse pointer touching that sprite, touching that cat?
And only if so, go ahead and play that sound meow until done.
But now we can make things a little more interesting.
Let me stop this and let me do something actually completely different.
Let me throw all this hard work away.
Let me go under extensions.
Let me go to video sensing, because lots of laptops, my own included,
has a little webcam nowadays.
Let me approve use of that there.
And you can see me in the frame.
And let me do this.
Let me drag one of these when motion exceeds some measure.
And through trial and error, I figured out that 50 tends to work well.
Let me step out of frame here and program off to the side.
And if I go to play sound meow until done,
notice that this is an alternative to using when green flag clicked.
This is a category of block that's constantly
waiting for what we'll call an event.
An event is just something that can happen on the screen, a click, a drag,
a mouse movement, and so forth.
So let me zoom out here.
And now, if I can do this-- here we go.
No, too slow.
Still too slow.
Wait, did I click play?
Let's see.

음, 지금은 아무것도 없습니다.
청중: 고양이를 만지지 마세요.
데이비드 말란: 하지만 저는 고양이를 만지지 않을 겁니다.
그러니까 마우스 포인터를 고양이에게 가져가면.
컴퓨터: 야옹.
데이비드 말란: 또요.
컴퓨터: 야옹.
데이비드 말란: 또요.
컴퓨터: 야옹.
데이비드 말란: 고양이를 쓰다듬는다는 아이디어를 구현하는 것과 같습니다.
저는 계속 기다리고 기다리고 기다리고 있으니까요.
마우스 포인터가 스프라이트에 닿아 있나요? 고양이에 닿아 있나요?
그럴 경우에만, 끝날 때까지 야옹 소리를 재생하세요.
하지만 이제 좀 더 재미있게 만들 수 있습니다.
이쯤에서 멈추고 완전히 다른 것을 해 보겠습니다.
이 모든 어려운 작업은 잊어버리겠습니다.
확장 기능으로 넘어가겠습니다.
비디오 감지로 넘어가 볼게요. 요즘 제 노트북을 포함한 많은 노트북에
작은 웹캠이 있거든요.
그걸 여기서 사용하도록 승인해 드릴게요.
프레임 안에 제가 보이시죠?
그리고 이렇게 해 볼게요.
움직임이 어느 정도 범위를 벗어나면 이걸 하나 드래그해 볼게요.
시도해 본 결과, 50이 잘 작동하는 경향이 있다는 걸 알아냈어요.
여기서 프레임 밖으로 나가서 옆으로 프로그래밍해 볼게요.
그리고 '야옹' 소리가 끝날 때까지 재생하려면
'녹색 깃발을 클릭했을 때'를 사용하는 대신 사용할 수 있다는 걸 알아두세요.
이것은 끊임없이
이벤트라고 부르는 것을 기다리는 블록의 한 종류입니다.
이벤트는 화면에서 클릭, 드래그,
마우스 움직임 등 일어날 수 있는 일입니다.
자, 여기서 줌 아웃해 볼게요.
자, 이제 이걸 할 수 있다면… 시작해 볼까요.
아니, 너무 느려요.
여전히 너무 느려요.
잠깐, 재생을 클릭했나요?
어디 보자고요.

Try again.
COMPUTER: Meow.
DAVID MALAN: There we go.
OK.
50 is a little too high, apparently.
So let's make this a little gentler.
10.
COMPUTER: Meow.
DAVID MALAN: OK, well.
COMPUTER: Meow.
DAVID MALAN: There we go.
COMPUTER: Meow.
DAVID MALAN: There we go.
COMPUTER: Meow.
DAVID MALAN: OK, so we've implemented now more physically the idea of actually
responding to petting a cat.
COMPUTER: Meow.
Meow.
DAVID MALAN: Oh, damn it.
OK.
COMPUTER: Meow.
Meow.
Meow.
DAVID MALAN: All right.
So this is a bug.
Like now-- this is MIT's fault. So it's not stopping in response
to the red stop sign.
So what do you do in doubt?
Most extreme, you reboot.
For now, I'm just going to close the window.
OK.
다시 시도해 보세요.
컴퓨터: 야옹.
데이비드 말란: 됐네요.
좋아요.
50은 좀 너무 높은 것 같네요.
그럼 좀 더 부드럽게 해 볼까요.
10.
컴퓨터: 야옹.
데이비드 말란: 좋아, 음.
컴퓨터: 야옹.
데이비드 말란: 됐네요.
컴퓨터: 야옹.
데이비드 말란: 됐네요.
컴퓨터: 야옹.
데이비드 말란: 됐네요.
컴퓨터: 야옹.
데이비드 말란: 됐네요.
컴퓨터: 야옹.
데이비드 말란: 좋아, 이제 고양이를 쓰다듬는 것에 실제로 반응하는 아이디어를 더 물리적으로 구현했습니다.

컴퓨터: 야옹.
야옹.
데이비드 말란: 아, 젠장.
좋아요.
컴퓨터: 야옹.
야옹.
야옹.
데이비드 말란: 알겠습니다.
이건 버그입니다.
지금처럼 말이죠. 이건 MIT의 잘못입니다. 빨간 정지 신호에도
멈추지 않는군요.
그럼 의심스러우면 어떻게 하시나요?
가장 극단적인 방법은 재부팅하는 겁니다.
일단은 창을 닫겠습니다.
알겠습니다.

So now we've seen all of those primitives
that we saw in that pseudocode, but incarnated in this graphical programming
language, and again, without parentheses and semicolons and double quotes and all
that punctuation that we will introduce before long.
But for now, we have the mechanisms in place
where we can do some really interesting things.
So in fact, I thought, in the spirit of thinking back on olden times,
thought I'd open up the very first program I wrote when I actually took--
I was cross-registered in an MIT class and took
a class that introduced aspiring teachers to Scratch.
And I implemented this program here called Oscartime,
which was a game that used a childhood song that I was a fan of
and it allows you to drag trash into a trash can.
But to bring this to life and perhaps in exchange for one stress ball,
could I get one brave volunteer who wants to come up and control this here
keyboard?
I saw your hand first.
Come on up.
Come on up.
And you'll see, thanks to the team, we also have this amazing lamppost here,
being on Quincy Street as we are.
Do you want to introduce yourself to the group?
AUDIENCE: Hi, my name is Anna.
I'm from Richmond, Virginia, and I'm in Weld.
이제 우리는 의사코드에서 보았던 모든 기본 요소들을 그래픽 프로그래밍 언어로 구현해 보았습니다.
그리고 괄호, 세미콜론, 큰따옴표, 그리고 곧 소개할 모든 구두점 없이 말이죠.
하지만 지금은 정말 흥미로운 것들을 할 수 있는 메커니즘이 마련되어 있습니다.
그래서 옛날을 떠올리며
제가 실제로 수강했을 때 작성한 첫 번째 프로그램을 공개해 보려고 생각했습니다.
MIT 수업에 교차 등록을 했고,
지망생들에게 스크래치를 소개하는 수업을 들었습니다.
그리고 여기에 '오스카타임'이라는 프로그램을 구현했습니다.
제가 좋아했던 어린 시절 노래를 사용한 게임인데,
쓰레기를 쓰레기통으로 끌어다 놓을 수 있습니다.
하지만 이 프로그램을 실제로 구현하기 위해, 그리고 아마도 스트레스 볼 하나를 대가로
여기 와서 이 프로그램을 조종할 용감한 자원봉사자를 한 명 구해 주시겠습니까?
키보드?
당신의 손을 먼저 봤습니다.
어서 오세요.
어서 오세요.
그리고 여러분, 저희 팀 덕분에 퀸시 스트리트에 이렇게 멋진 가로등이 있다는 걸 알게 되실 거예요.

자, 이제 자기소개를 해 주시겠어요?
청중: 안녕하세요, 저는 안나입니다.
저는 버지니아주 리치먼드 출신이고, 웰드에 살고 있습니다.

DAVID MALAN: Nice.
Weld.
AUDIENCE: Yes!
DAVID MALAN: All right, come on over.
So here, Anna, you'll have a chance to play
the very first game I wrote in Scratch, which admittedly
is more complicated typically than we would
expect of a student doing this for the very first time, as in problem set zero.
But what I'm going to do is full screen this here.
I'm going to click the green flag, and what you'll see on the screen
are these instructions.
Drag as much falling trash as you can to Oscar's trashcan before his song ends.
And here we go.
[OSCAR THE GROUCH, "I LOVE TRASH"]
Oh, I love trash
Anything dirty or dingy or dusty
Anything ragged or rotten or rusty
Yes, I love trash.
데이비드 말란: 좋아요.
용접.
청중: 네!
데이비드 말란: 좋아요, 어서 오세요.
자, 안나, 여기, 제가 스크래치로 만든 첫 게임을 해 볼 기회가 있습니다.
사실 이 게임은
학생들이 처음 하는 것보다
더 복잡하죠. 문제 세트 0처럼요.
하지만 제가 할 건 이걸 전체 화면으로 보는 거예요.
녹색 깃발을 클릭하면 화면에 이런 설명이 나올 거예요.
오스카의 노래가 끝나기 전에 떨어지는 쓰레기를 최대한 많이 오스카의 쓰레기통으로 끌어다 놓으세요.
자, 시작합니다.
[오스카 더 그라우치, "나는 쓰레기를 사랑해"]
오, 나는 쓰레기를 사랑해
더럽거나, 음침하거나, 먼지가 묻은 것
누더기 같거나, 썩거나, 녹슨 것
네, 나는 쓰레기를 사랑해.

DAVID MALAN: There we go.
So as Anna continues to play, let's tease this apart a little bit.
So one, there's some costumes on the stage.
Like that lamppost is actually never going to move.
But there's a couple of sprites.
There's the trash can, which seems to be a character unto itself.
There's this piece of trash that keeps coming back and back.
That is a sprite.
There's now this sneaker, which is another sprite.
And in fact, notice that Oscar, of course, keeps popping up from his sprite
once in a while.
So Oscar seems to have multiple costumes.
So I offer this as an example, as you keep playing, if you would.
Very good job so far.
The song goes on forever.
This was a nightmare to implement, to listen to this all day long.
But how do we implement the rest of this?
Well, notice that the trash, every time she throws into the trash can,
does reappear somewhere different.
So there's some kind of randomness involved.
데이비드 말란: 자, 이제 시작입니다.
안나가 계속 연주하는 동안, 이 부분을 조금 더 자세히 살펴보겠습니다.
첫째, 무대에 의상이 몇 개 있습니다.
마치 가로등이 절대 움직이지 않는 것처럼요.
하지만 스프라이트가 몇 개 있습니다.
쓰레기통이 있는데, 그 자체로 하나의 캐릭터처럼 보입니다.
계속 돌아오는 쓰레기 조각도 있습니다.
저것도 스프라이트입니다.
이제 운동화도 있는데, 이것도 또 다른 스프라이트입니다.
그리고 사실, 오스카가 스프라이트에서 가끔씩 튀어나오는 것을 보세요.
가끔씩요.
오스카는 여러 의상을 입고 있는 것 같습니다.
연주를 계속하면서 이걸 예로 들어 보겠습니다.
지금까지 아주 잘했습니다.
노래가 끝없이 이어집니다.
이걸 구현하는 건 정말 악몽 같았습니다. 하루 종일 이걸 듣는 건 정말 힘들었습니다.
하지만 나머지 부분은 어떻게 구현해야 할까요?
음, 그녀가 쓰레기통에 쓰레기를 버릴 때마다
다른 곳에 다시 나타난다는 점에 주목하세요.
그래서 일종의 무작위성이 개입된 거죠.

And indeed, Scratch will let you pick random numbers in a range.
So maybe it could be negative 240, maybe it
could be positive 240, at the 180 point on the top of the screen.
So you can randomly put things on the screen.
There's apparently what kind of construct
that makes the trash fall again and again.
I think no one's listening to me.
They're all just watching you.
What's making the trash fall from top to bottom?
So it's actually some kind of loop because there's a motion block
inside of a forever loop, probably, that just
keeps moving the trash one pixel, one pixel, one pixel, one pixel, one pixel,
creating the illusion, therefore, of motion.
And if we can crank the song a little bit more,
you'll see that this is all synchronized now.
OSCAR THE GROUCH: (SINGING) Because they're trash
Oh, I love trash
Anything dirty or dingy or dusty
Anything ragged--
DAVID MALAN: The song keeps going forever, seemingly.
And now notice more and more sprites are appearing because they waited for--
here we go.
Climax.
OSCAR THE GROUCH: (SINGING) I love trash
DAVID MALAN: All right.
A big round of applause for Anna.
Nicely done.
OK, here you go.
Here you go.
All right.
So this is an interminable song.
실제로 스크래치에서는 일정 범위 내에서 무작위 숫자를 선택할 수 있습니다.
그러니까 -240일 수도 있고,
화면 상단 180도 지점에 -240일 수도 있죠.
그래서 화면에 무작위로 물건을 놓을 수 있습니다.
쓰레기를 계속해서 떨어뜨리는 어떤 구조물이 있는 것 같습니다.
아무도 제 말을 듣지 않는 것 같습니다.
다들 당신을 보고만 있을 뿐입니다.
쓰레기를 위에서 아래로 떨어뜨리는 것은 무엇일까요?
사실 일종의 루프가 있습니다.
아마도 무한 루프 안에 모션 블록이 있어서
쓰레기를 한 픽셀, 한 픽셀, 한 픽셀, 한 픽셀, 한 픽셀씩 계속 움직여서
움직이는 듯한 착시 효과를 만들어냅니다.
그리고 노래를 조금 더 크게 틀어보면
이제 모든 것이 동기화되어 있는 것을 보실 수 있을 겁니다.
오스카 더 그라우치: (노래하며) 쓰레기니까
아, 쓰레기 좋아해
더럽거나 음침하거나 먼지 쌓인 거
누더기 같은 거--
데이비드 말란: 노래가 끝없이 이어지는 것 같아.
그리고 이제 점점 더 많은 스프라이트가 나타나는 걸 봐. 왜냐하면 그들은 기다렸으니까--
자, 시작이야.
클라이맥스.
오스카 더 그라우치: (노래하며) 쓰레기 좋아해
데이비드 말란: 좋아.
안나에게 큰 박수 보냅니다.
잘했어요.
좋아, 시작이야.
시작이야.
좋아.
끝없는 노래네요.

And indeed, I spent hours building that, and just listening to that song on loop
was not the best way to program.
But the goal here is to really use it as just an intellectual exercise as to how
that was implemented.
And we won't do the entire thing in detail,
because I will say back in the day when I was younger,
I didn't necessarily write the cleanest code.
And in fact, if we see inside this and we poke around the bottom of the screen
here, you can see all of my different sprites.
And the code is kind of complex.
Like, things just kind of escalated quickly.
But I did not set out and write all of these programs
all at once for each sprite.
I pretty much took baby steps, so to speak.
And so, for instance, let me open up just a few sample building blocks here
that speak to this that are written in advance.
So here's version zero.
Computer scientists typically start counting at zero.
And let me show you this example here that only has two sprites on the screen.
We have Oscar the trashcan and we have the piece of trash.
And now notice, what does Oscar do?
Well, let me go ahead and zoom in on this script, as it's called.
A program is a script.
When the green flag is clicked, Oscar switches his costume to Oscar one.
That's his default costume where the lid is closed.
Then Oscar does this forever.
사실, 저는 몇 시간 동안 이걸 만들었고, 그 노래를 반복해서 듣는 것만으로는
프로그래밍하기에 가장 좋은 방법은 아니었습니다.
하지만 여기서의 목표는 이 코드를 어떻게 구현했는지에 대한 지적인 연습으로 활용하는 것입니다.
그리고 모든 것을 자세히 다루지는 않겠습니다.
제가 어렸을 때,
꼭 깔끔한 코드를 작성했던 건 아니니까요.
사실, 이 코드 안을 들여다보고 화면 아래쪽을 살펴보면
여기 다양한 스프라이트를 모두 볼 수 있습니다.
그리고 코드는 꽤 복잡합니다.
뭐, 상황이 순식간에 커졌죠.
하지만 저는 이 모든 프로그램을 한꺼번에 작성하지 않았습니다.
각 스프라이트마다 말이죠.
말하자면, 거의 아기 걸음마를 떼는 셈이죠.
예를 들어, 미리 작성된 몇 가지 샘플 구성 요소를 보여드리겠습니다.
이것이 버전 0입니다.
컴퓨터 과학자들은 일반적으로 0부터 계산을 시작합니다.
화면에 스프라이트가 두 개뿐인 이 예시를 보여드리겠습니다.
쓰레기통 오스카와 쓰레기 조각이 있습니다.
자, 이제 오스카가 무슨 일을 하는지 보세요.
자, 이 스크립트를 확대해서 살펴보겠습니다. 이 스크립트는 프로그램이라고 합니다.
프로그램은 스크립트입니다.
녹색 깃발을 클릭하면 오스카는 의상을 오스카 1로 바꿉니다.
뚜껑이 닫힌 기본 의상입니다.
그리고 오스카는 이 동작을 영원히 반복합니다.


If Oscar is touching the mouse pointer, change the costume to Oscar two,
otherwise change it back to Oscar one.
So that whole idea of animation where Oscar is popping in and out
is just like a quick costume change based
on a loop inside of which is a conditional waiting for the cursor,
like Anna did, to get near the trash can.
Meanwhile, if we look at the piece of trash here,
notice that the trash is actually not doing anything in this first version
because I didn't even implement falling first.
So let me hit the green flag.
Nothing is happening in this very first version.
But notice, if I click on the trash and drag as soon as I'm touching Oscar,
there comes that trash can lid.
And it was just the result of making this one program respond to that input.
All right.
What did I do next?
Well, next, after taking that single baby step, I added one other feature.
Let's see inside this version one.
Again, Oscar is behaving the exact same way.
But notice this time the trash is designed to do the following.
First, I'm telling the program that the drag mode is draggable.
That is, I want the trash to be movable when the user clicks on it.
Then I tell the piece of trash to go to a random x location.
x is the horizontal, so it's going somewhere between 0 and 240,
but all the way at the top of the screen.
180.
오스카가 마우스 포인터를 터치하면 의상을 오스카 2로 변경하고,
그렇지 않으면 오스카 1로 다시 변경하세요.
오스카가 갑자기 나타났다 사라지는 애니메이션은
안나가 그랬던 것처럼 커서가 쓰레기통에 가까이 다가갈 때까지 기다리는 조건문이 있는 루프를 기반으로 빠르게 의상을 바꾸는 것과 같습니다.

한편, 여기 쓰레기 조각을 보면
첫 번째 버전에서는 쓰레기가 아무 동작도 하지 않는다는 것을 알 수 있습니다.
처음에는 떨어지는 동작도 구현하지 않았기 때문입니다.
그러니 녹색 깃발을 눌러 보겠습니다.
이 첫 번째 버전에서는 아무 일도 일어나지 않습니다.
하지만 오스카를 터치하는 순간 쓰레기를 클릭하고 드래그하면
쓰레기통 뚜껑이 나타납니다.
그리고 그것은 이 프로그램이 그 입력에 반응하도록 만든 결과일 뿐입니다.
좋습니다.
그다음에는 무엇을 했을까요?
음, 이렇게 작은 단계를 거친 후, 또 다른 기능을 추가했습니다.
이 첫 번째 버전 내부를 살펴보겠습니다.
오스카도 똑같은 방식으로 동작합니다.
하지만 이번에는 휴지통이 다음과 같은 동작을 하도록 설계되었다는 점에 유의하세요.
먼저, 프로그램에 드래그 모드가 드래그 가능하다고 알려줍니다.
즉, 사용자가 휴지통을 클릭하면 휴지통이 움직일 수 있도록 합니다.
그런 다음 휴지통을 임의의 x 위치로 이동시킵니다.
x는 가로 좌표이므로 0에서 240 사이의 어딘가에 위치하지만
화면 맨 위에 있습니다.
180입니다.

Then forever, the piece of trash just changes by negative one.
So it just moves down and down and down.
And without looking at the second script yet, let me just hit play.
And notice, without even doing anything-- and eventually,
once there was lots of trash falling, like
Anna was struggling to keep up with this.
It's just moving one pixel at a time forever until, thankfully, MIT
does stop things automatically if they hit the bottom, lest a six-year-old get
upset that all of a sudden their sprite is gone forever.
So there is some special casing there.
But what else is this trash doing?
Let me zoom in here.
The piece of trash also, when the green flag is clicked,
is forever asking this question.
If you are touching Oscar, then pick a new random location between 0 and 240
at positive 180 and go back to the top.
So in other words, as soon as this piece of trash
is dragged over to Oscar like this and I let go, it recreates itself at the top.
It's just sort of teleporting to the top, and thus was born this feature.
And I won't slog through all of the individual features here,
but if we do just one more and see inside this one-- so now let me go ahead
and hit Play.
Notice at the top left of the screen, there's a score.
Currently zero.
그러면 영원히, 쓰레기 조각은 -1만큼만 변합니다.
그래서 계속 아래로, 아래로, 아래로, 아래로 움직입니다.
아직 두 번째 스크립트를 보지 않고 재생 버튼을 눌러 보겠습니다.
그리고 아무것도 하지 않고도, 결국에는
쓰레기가 많이 떨어지기 시작했습니다.
안나는 마치
쓰레기가 떨어지는 것을 따라잡으려고 애쓰고 있었습니다.
한 픽셀씩 영원히 움직이다가, 다행히 MIT에서는
쓰레기가 바닥에 닿으면 자동으로 멈추게 합니다. 여섯 살짜리 아이가 스프라이트가 갑자기 사라져서 화를 내지 않도록 말이죠.
그러니까 뭔가 특별한 게 있는 거죠.
하지만 이 쓰레기는 또 뭘 하고 있는 걸까요?
여기를 확대해 보겠습니다.
쓰레기 조각은 또한 녹색 깃발을 클릭하면
끊임없이 이 질문을 합니다.
오스카를 터치하고 있다면, 0에서 240 사이의 새로운 무작위 위치를 +180으로 선택하고
맨 위로 돌아가세요.
그러니까, 이 쓰레기 같은 게 오스카에게 이렇게 끌려와서 제가 놓는 순간, 맨 위에 다시 생성됩니다.
그냥 맨 위로 순간이동하는 셈이고, 그래서 이 기능이 탄생한 겁니다.
그리고 여기서 모든 개별 기능을 하나하나 자세히 설명하지는 않겠지만,
한 가지만 더 살펴보고 이 기능의 내부를 살펴보겠습니다. 자, 이제
재생을 눌러 보겠습니다.
화면 왼쪽 상단에 점수가 있습니다.
현재는 0점입니다.

But now when I click the trash and let go,
notice that the score is being incremented by one.
And this, in fact, is how, Anna, your score kept
going higher and higher and higher.
Every time I noticed, oh, the trash is touching Oscar, let's not only teleport,
let's also increment a variable.
And we didn't see this before, but if I go to this Oscar Scratch now,
you'll see that it is exactly the same.
하지만 이제 휴지통을 클릭하고 놓으면
점수가 하나씩 증가하는 것을 볼 수 있습니다.
그리고 사실, 안나, 당신의 점수는 이렇게
점수가 점점 더 높아졌습니다.
오, 휴지통이 오스카에 닿았구나, 순간이동만 하는 게 아니라
변수도 증가시키는 걸 생각해 봤어요.
전에 본 적이 없지만, 지금 오스카 스크래치로 가 보면
정확히 똑같다는 것을 알 수 있을 겁니다.

But if I now go to the trash piece here and we go to when green flag clicked,
you'll see that I'm initializing a variable in orange called score to zero.
But if we scroll down to the bottom, Oscar
is also doing another thing in parallel at the same time.
When the green flag is clicked, Oscar is forever checking,
is the piece of trash touching Oscar?
If so, change the score by one and then go to top,
which is another location on there, that screen.
So in other words, even though at a glance something like Oscar
time might look very complicated and it did take me hours,
the goal, especially with problem set zero,
is not going to be to bite off all of that at once,
but to take proverbial baby steps.
Implement one tiny feature so that you feel like you're making progress.
Add another feature, another.
하지만 지금 여기 쓰레기 조각으로 가서 녹색 깃발을 클릭했을 때로 가면,
주황색으로 표시된 score라는 변수를 0으로 초기화하는 것을 볼 수 있습니다.
하지만 아래로 스크롤하면 Oscar가
동시에 다른 작업을 동시에 진행하고 있습니다.
녹색 깃발을 클릭하면 Oscar는 끊임없이
쓰레기 조각이 Oscar와 닿았는지 확인합니다.
만약 닿았다면 score를 1만큼 변경한 다음 맨 위로 이동합니다.
그곳은 화면의 다른 위치입니다.
즉, Oscar와 같은 것이 언뜻 보기에 매우 복잡해 보이고 몇 시간이나 걸렸지만,
특히 문제 세트 0의 경우 목표는
한 번에 모든 것을 해치우는 것이 아니라
아기처럼 천천히 나아가는 것입니다.
진행 중이라는 느낌이 들도록 작은 기능 하나를 구현하세요.
다른 기능을 추가하고, 또 추가하세요.

And invariably you might run out of time and not
get to the best version of your vision, but hopefully it'll be good.
Hopefully it'll be better, but you'll have these sort of mental milestones,
hoping that you at least get to that point.
Because as you will soon discover, everything in the world of programming
unfortunately takes longer than you might expect.
That was true for me 25 years ago and is still true today.
Well, let me introduce one final set of examples here.
This one written by one of your own predecessors, a former student.
Let me go ahead and open up three baby steps, if you will,
toward an end of implementing a game called Ivy's Hardest Game, whereby
it's now more interactive, quite like Oscartime.
So at top right here, notice-- and I'll zoom
in-- we have this world that's initially very simple.
Two black lines, two walls, if you will, and a Harvard sprite in the middle.
But when you click the green flag, notice
that nothing happens initially except that the sprite jumps to the middle.
But I can hit the up key or the down key or the left key or the right key.
But if I try to go too far, even though it's not the edge of the world,
it's only touching that there black line, it's still going to stop as well.
So intuitively, how could you implement that type of program?
How could you get a sprite from what we've seen to respond to up, down, left,
right, but actually move when I touch my arrow keys?
Like, what does it mean to move?
Yeah?
그리고 변함없이 시간이 부족해서
비전을 완벽하게 구현하지 못할 수도 있지만, 잘되기를 바랍니다.
더 나아지기를 바라지만, 적어도 그 지점까지는 도달할 수 있기를 바라면서 일종의 정신적 이정표를 세울 것입니다.
곧 알게 되겠지만, 프로그래밍 세계의 모든 것은
불행히도 예상보다 시간이 오래 걸립니다.
25년 전 제게도 그랬고 지금도 마찬가지입니다.
자, 마지막으로 몇 가지 예를 들어보겠습니다.
이것은 여러분의 선배이자 제자 중 한 분이 쓰신 것입니다.
자, 이제 세 가지 작은 단계를 소개해 드리겠습니다.
아이비의 가장 어려운 게임이라는 게임을 구현하는 과정의 마지막 단계입니다.
이 게임은 이제 오스카타임처럼 더욱 인터랙티브합니다.
자, 여기 맨 위에 있는 것을 보세요.
확대해서 보여드리겠습니다.
처음에는 매우 단순한 세상입니다.
두 개의 검은 선, 두 개의 벽, 그리고 가운데에 하버드 스프라이트가 있습니다.
하지만 녹색 깃발을 클릭하면
처음에는 아무 일도 일어나지 않고 스프라이트가 가운데로 이동합니다.
하지만 위쪽 키나 아래쪽 키, 왼쪽 키나 오른쪽 키를 누를 수 있습니다.
하지만 너무 멀리 가려고 하면, 세상의 끝이 아니더라도
검은 선에만 닿으면 멈추게 됩니다.
그러니 직관적으로 어떻게 그런 종류의 프로그램을 구현할 수 있을까요?
어떻게 지금까지 본 스프라이트가 위쪽, 아래쪽, 왼쪽, 오른쪽에 반응하면서
화살표 키를 누르면 실제로 움직이도록 할 수 있을까요?
이동한다는 게 무슨 뜻일까요?
맞아요?

AUDIENCE: Maybe if then.
DAVID MALAN: Exactly.
So much like with representing information, at the end of the day,
all we've got is zeros and ones.
When it comes to algorithms, at the moment,
all we have are functions and loops and conditionals
and Boolean expressions and soon some more things too.
But there's not all that much we have at our disposal.
So let me zoom out from this and let me actually show you
what the Harvard sprite is doing.
It's doing this.
When I go up to the green flag here, the Harvard sprite is going to 0, 0.
So dead center in the middle.
And then it's forever doing two things, listening for the keyboard
and feeling for walls, left and right.
Now, those are not puzzle pieces that come with Scratch.
I created my own custom blocks, my own functions to implement those ideas.
Let's not abstract away for now.
Let's actually look at these features.
And indeed, to your instincts at left here,
what does it mean to listen for the keyboard?
Well, if the up arrow key is pressed, change y by one.
Move up.
청중: 그렇다면 그럴 수도 있겠네요.
데이비드 말란: 맞아요.
정보를 표현하는 것과 마찬가지로, 결국 우리가 가진 건
0과 1뿐이죠.
알고리즘에 관해서라면, 현재 우리가 가진 건
함수, 반복문, 조건문,
부울 표현식, 그리고 곧 더 많은 것들뿐입니다.
하지만 우리가 활용할 수 있는 것은 그렇게 많지 않습니다.
자, 여기서 벗어나서
하버드 스프라이트가 무엇을 하는지 실제로 보여드리겠습니다.
이렇게 하고 있습니다.
제가 여기 녹색 깃발로 다가가면 하버드 스프라이트는 0, 0으로 이동합니다.
즉, 정중앙이죠.
그리고는 키보드를 듣고
좌우 벽을 감지하는 두 가지 일을 계속합니다.
자, 이것들은 스크래치에 기본으로 제공되는 퍼즐 조각이 아닙니다.
저는 이러한 아이디어를 구현하기 위해 저만의 맞춤 블록과 함수를 만들었습니다.
지금은 추상화하지 않겠습니다.
실제로 이 기능들을 살펴보겠습니다.
그리고 실제로, 여기 왼쪽에 있는 여러분의 본능에 따르면,
키보드를 듣는다는 것은 무슨 뜻일까요?
음, 위쪽 화살표 키를 누르면 y를 하나 변경합니다.
위로 이동합니다.

If the down arrow key is pressed, change y by negative one.
If the right arrow key is pressed, change x by one.
If the left arrow key is pressed, change x by negative one.
So take all the magic out of moving up, down,
left, right by just quantizing it as plus, minus, this, and that.
It's all numbers, indeed, at the end of the day.
But what else is it doing?
Notice that it did, indeed, bounce off the wall.
So my other custom function, which I chose,
feel for walls to evoke this idea, it's asking two questions.
If you're touching the left wall, then change x by one,
so bounce in the other direction.
Else if you're touching the right wall, bounce in the negative one direction.
And so what are left wall and right wall?
I mean, I kind of cheated.
I just used two more sprites.
These sprites are literally nothing except black lines.
But because they exist, I can ask that question in my conditional saying,
are you touching those other sprites?
And I could have colored them any way I want, but this is enough, if I zoom in,
to implement this idea of going up, down, left, and right,
and preventing the sprite from leaving that little world.
All right.
아래쪽 화살표 키를 누르면 y 값을 -1만큼 변경합니다.
오른쪽 화살표 키를 누르면 x 값을 1만큼 변경합니다.
왼쪽 화살표 키를 누르면 x 값을 -1만큼 변경합니다.
위, 아래, 왼쪽, 오른쪽으로 움직이는 마법 같은 효과를 없애려면
더하기, 빼기, 이것저것으로 양자화하면 됩니다.
결국 모두 숫자입니다.
하지만 그 외에는 무슨 역할을 할까요?
실제로 벽에 부딪혀 튕겨 나갔습니다.
제가 선택한 다른 사용자 지정 함수는
벽을 느껴서 이 아이디어를 떠올리게 하는 것입니다. 두 가지 질문을 던집니다.
왼쪽 벽에 닿으면 x 값을 1만큼 변경하여
반대 방향으로 튕깁니다.
오른쪽 벽에 닿으면 -1 방향으로 튕깁니다.
그렇다면 왼쪽 벽과 오른쪽 벽은 무엇일까요?
제가 약간 부정행위를 한 것 같습니다.
스프라이트 두 개만 더 사용했습니다.
이 스프라이트들은 말 그대로 검은 선일 뿐입니다.
하지만 스프라이트가 존재하기 때문에, 조건문에서 "다른 스프라이트들을 건드리고 있나요?"라는 질문을 던질 수 있습니다.
그리고 원하는 대로 색칠할 수도 있었지만, 확대해서 보면 이 정도면 충분합니다.
위, 아래, 왼쪽, 오른쪽으로 이동하면서 스프라이트가 그 작은 세계를 벗어나지 못하게 하는 아이디어를 구현할 수 있죠.
좋아요.

So if you'll agree that there's a way now to implement motion up,
down, left, right, let's go ahead and implement this idea
by adding a rival into the mix, like a Yale sprite.
And what the Yale sprite is going to do, if I click the green flag, is this.
So Harvard at the moment is still going to be movable with the arrow keys,
up, down, left, right.
But Yale, for better or for worse, is just
going to mindlessly bounce back and forth from left to right forever,
it would seem.
The operative word being forever.
So how is that working?
Well, let's look.
Here's the Yale sprite at the bottom.
Let's zoom in on its actual code here.
The Yale sprite starts at 0, 0.
It points in direction 90 degrees, which means left, right, essentially.
And then it forever does this.
If touching the left wall or touching the right wall, turn around 180 degrees.
So I don't want the Yale sprite to just stop
by moving it one pixel to bounce off slightly.
I want it to wrap around and just keep going and going and going forever.
And that's it.
Everything else is the same.
So one final flourish.
Let's add a more formidable adversary, like MIT here,
whereby if I zoom in and hit play, notice
that if I move the Harvard sprite, MIT comes chasing me now.
이제 위, 아래, 왼쪽, 오른쪽으로 움직이는 방법이 있다고 생각하신다면,
예일 스프라이트처럼 라이벌 스프라이트를 추가해서 이 아이디어를 구현해 보겠습니다.
그리고 녹색 깃발을 클릭하면 예일 스프라이트가 하는 일은 다음과 같습니다.
현재 하버드는 화살표 키로
위, 아래, 왼쪽, 오른쪽으로 움직일 수 있습니다.
하지만 예일은 좋든 나쁘든
무심코 영원히 좌우로 왔다 갔다 할 것 같습니다.
마치 영원히 말이죠.
그게 어떻게 작동하는 걸까요?
자, 한번 봅시다.
아래에 예일 스프라이트가 있습니다.
여기서 실제 코드를 확대해 보겠습니다.
예일 스프라이트는 0, 0에서 시작합니다.
90도 방향을 가리키는데, 이는 본질적으로 왼쪽, 오른쪽을 의미합니다.
그리고 영원히 이렇게 움직입니다.
왼쪽 벽이나 오른쪽 벽에 닿으면 180도 회전합니다.
그래서 예일 스프라이트가 그냥 멈추는 게 아니라
한 픽셀씩 움직여 살짝 튕겨 나가도록 하고 싶습니다.
그냥 주변을 감싸고 끝없이 계속 움직이도록 하고 싶습니다.
그게 전부입니다.
다른 건 똑같습니다.
자, 마지막으로 한 가지 더 꾸며 보겠습니다.
여기 MIT처럼 더 강력한 적을 추가해 보겠습니다.
확대해서 재생 버튼을 누르면
하버드 스프라이트를 움직이면 MIT가 저를 쫓아오는 것을 볼 수 있습니다.

Now, how is this actually working?
Yale is just kind of doing its thing, bouncing back and forth.
Now MIT has really latched on to me and it's following me up, down, left, right.
So how is that logic now working?
Well, again, it's probably doing something forever,
because that's why it's continually doing it.
Let's click on MIT.
This too is pretty simple, even though it's a pretty fancy idea.
Initially the MIT sprite goes to a random position,
but thereafter, it forever points toward the Harvard logo outline, which
is just the long name that your predecessor or former student
gave the name for that sprite.
And then it moves one step, one step, one step.
So suppose this were an actual game, and in games things
get harder and harder, the adversary moves faster and faster.
How could we make MIT even faster by changing just one thing here?
자, 이게 실제로 어떻게 작동하는 걸까요?
예일은 그냥 앞뒤로 튀어다니는 식으로 제 역할을 하는 거죠.
이제 MIT가 제게 완전히 달라붙어서 위아래로, 좌우로 저를 따라다니고 있어요.
그럼 이 논리는 어떻게 작동하는 걸까요?
음, 다시 말하지만, 아마 영원히 뭔가를 하고 있을 거예요.
왜냐하면 그게 바로 MIT가 끊임없이 뭔가를 하고 있는 이유니까요.
MIT를 클릭해 봅시다.
이것 역시 꽤 간단하지만, 꽤 멋진 아이디어입니다.
처음에는 MIT 스프라이트가 무작위 위치로 이동하지만,
그 이후로는 하버드 로고 윤곽선을 계속 가리키게 됩니다.
그건 그냥 선배나 전학생이 그 스프라이트에 붙인 긴 이름일 뿐입니다.
그리고 스프라이트는 한 걸음, 한 걸음, 한 걸음 움직입니다.
자, 이것이 실제 게임이라고 가정해 봅시다. 게임에서는 상황이 점점 더 어려워지고, 상대는 점점 더 빠르게 움직입니다.
여기서 한 가지만 바꿔서 MIT를 더 빠르게 만들 수 있을까요?

Like, how do we level up?
Change the one to two pixels at a time, two steps at a time.
So let's see that.
Let's go ahead and zoom out.
Let's hit play.
And now notice that MIT is coming in much faster this time.
All right.
So it wasn't noticeably faster.
Let's do this.
Let's move 10 steps at a time.
So 10 steps faster than originally.
I mean, now-- and now notice it's kind of twitching back and forth in this way.
Why?
Well, probably, if we worked out the math, probably
the MIT sprite is touching the sprite and it's bouncing off of it,
but then it's realizing, oh, I went too far.
Let me move back.
Wait a minute.
I'm still touching it.
Let me move down.
어떻게 레벨업을 하죠?
한 번에 1~2픽셀씩, 두 단계씩 바꿔야 하죠.
자, 한번 볼까요?
계속해서 줌아웃해 볼까요?
재생 버튼을 눌러 볼까요?
이번엔 MIT가 훨씬 더 빨리 들어오는 걸 보세요.
좋습니다.
눈에 띄게 빠르진 않았어요.
이렇게 해 볼까요?
한 번에 10단계씩 움직여 볼까요?
원래보다 10단계 더 빠르게요.
제 말은, 지금... 이렇게 앞뒤로 흔들리는 걸 보세요.
왜 그럴까요?
음, 아마, 수학적으로 계산해 보면, 아마도
MIT 스프라이트가 스프라이트에 닿아서 튕겨 나가다가
아, 너무 지나쳤구나 하는 걸 깨닫는 것일 거예요.
뒤로 가 볼까요.
잠깐만요.
아직 닿아 있네요.
아래로 가 볼까요.

So you can get into these perverse situations
where there is actually a bug, be it logical or aesthetical.
But in this case, we probably want to fix that.
So 10 is probably too fast for this to work particularly well.
But the final flourish here really is to show you the actual version of a game
that one of your predecessors, a past classmate, actually implemented.
Before, thereafter, we will adjourn for cake
in the transept, which is the CS50 tradition.
But can we get one more final volunteer to come on
up to play Ivy's Hardest Game?
I'm seeing your hand most enthusiastically there.
Yeah, come on down.
Very happily.
[APPLAUSE]
그래서 여러분은 이런 엉뚱한 상황에 빠질 수 있습니다.
논리적이든 미학적이든, 실제로 버그가 있는 경우죠.
하지만 이 경우에는 아마 그 버그를 수정하고 싶을 겁니다.
그래서 10은 아마 너무 빨라서 제대로 작동하지 않을 겁니다.
하지만 여기서 마지막으로 보여드릴 것은 여러분의 선배, 옛 동창이 실제로 구현한 게임의 실제 버전을 보여드리는 것입니다.
그 전에, 그 후에는 CS50 전통에 따라 익랑에서 케이크를 먹으며 시간을 보내겠습니다.
그런데 마지막으로 한 명 더 자원해서 아이비의 가장 어려운 게임을 할 수 있을까요?
아이비의 가장 어려운 게임을 할 수 있을까요?
거기서 당신의 패가 가장 열정적으로 보이네요.
네, 내려오세요.
아주 기쁘게요.
[박수]

In just a moment, we will indeed adjourn.
But the goal here now is going to be to navigate a maze that's
a little more difficult than the last.
Let's have you first, though, introduce yourselves to your classmates in front.
AUDIENCE: Hi, y'all.
I'm Eric.
I'm from Philadelphia and I'm also from Hollis Hall.
[CHEERS]
DAVID MALAN: One person from Hollis.
Nice.
OK.
Welcome.
All right.
Eric, go ahead and take the keyboard here.
It, too, will be all about up, down, left, right as soon
as you click the green flag.
And if we can crank the music.
[MC HAMMER, "U CAN'T TOUCH THIS"]
You Can't touch this
DAVID MALAN: So notice, the black walls are a little more involved
than last time.
But the goal is to get to the sprite all the way at right
and just touch it, at which point you move to the next level.
The next level, of course, has Yale doing its thing back and forth.
You've made it to level three.
But now there's two Yale.
So another sprite is in the mix that's randomly
moving a little different in terms of direction.
Three Yales.

Next level.
MIT is in.

Nice.

The walls are now gone.

Princeton's in the mix.

Nice.
Two Princetons.

OK.
New life.

OK, another life.
Nice.
Nice.
Oh.

Nice.
Second to last level.
Three Princetons.
Last level.

Yeah!

Congratulations.
[APPLAUSE]
Thank you.
All right.
This, then, was CS50.
Welcome aboard.
Cake is now served.
[MUSIC PLAYING]

잠시 후, 드디어 폐회하겠습니다.
하지만 지금 목표는 지난번보다 조금 더 어려운 미로를 헤쳐나가는 것입니다.

하지만 먼저 앞에 있는 반 친구들에게 자기소개를 해 주세요.
청중: 안녕하세요.
저는 에릭입니다.
필라델피아 출신이고, 홀리스 홀 출신이기도 합니다.
[건배]
데이비드 말란: 홀리스 출신입니다.
좋아요.
좋습니다.
에릭, 키보드를 잡으세요.
역시 녹색 깃발을 클릭하는 순간 위, 아래, 왼쪽, 오른쪽으로 쭉 뻗을 겁니다.

그리고 음악을 크게 틀 수 있다면 말이죠.
[MC 해머, "U CAN'T TOUCH THIS"]
You Can't touch this
데이비드 말란: 검은색 벽이 지난번보다 조금 더 복잡해졌네요.

하지만 목표는 스프라이트를 완전히 오른쪽에 두고
그냥 터치하는 것입니다. 터치하면 다음 레벨로 넘어갑니다.
다음 레벨에서는 물론 예일이 앞뒤로 움직입니다.
세 번째 레벨까지 왔습니다.
하지만 이제 예일이 두 명입니다.
그러니까 방향이 약간 다르게 움직이는 또 다른 스프라이트가 있습니다.
세 명의 예일입니다.

다음 레벨입니다.
MIT가 합류했습니다.

좋아요.

이제 벽이 사라졌습니다.

프린스턴도 합류했습니다.

좋아요.
프린스턴 두 명입니다.

좋아요.
새로운 삶입니다.

좋아요, 또 다른 삶입니다.
좋아요.
좋아요.
오.

좋아요.
마지막에서 두 번째 레벨입니다.
프린스턴 세 명입니다.
마지막 레벨입니다.

네!

축하합니다.
[박수]
감사합니다.
좋습니다.
그럼, 이것이 CS50이었습니다.
탑승을 환영합니다.
케이크가 준비되었습니다.
[음악 재생]
