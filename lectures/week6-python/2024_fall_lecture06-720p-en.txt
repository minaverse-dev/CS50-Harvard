[MUSIC PLAYING]

DAVID J. MALAN: All right, this is CS50.
And this is week 6, wherein we transition away from that programming
language called C to another programming language called Python.
And, whereas a language like C, as you've probably come to appreciate,
for better or for worse, is very low level--
like, if you want the computer to do something,
you have to do most everything yourself, including asking for memory,
giving memory back.
Python is actually representative of a type of programming language
that's generally referred to as a higher-level language, which
does a lot of that lower-level stuff for you.
In other words, you don't have to manage your own memory.
You can iterate over things much more quickly
than using a traditional for loop as in C. And so, in short,
a language like Python is just easier and more pleasant, daresay, more fun
to use.
Moreover, it has even more of an ecosystem
of libraries, libraries being code that other people wrote that you can use.
And, as we'll see today, it's so much easier to get real work done
and really focus on the problems that are of interest to you.
What today is also going to be about is teaching yourself a new language.
And, indeed, the way we're going to approach this lecture
and the coming weeks problem set and beyond
is to give you all of the right tools and techniques via which
to learn a new language in the confines of CS50
initially but, after this course, on your own
because even if you don't go off and major in computer science,
odds are you'll have some occasion for programming in the future,
be it for academically, professionally, or for fun.
And so odds are a lot of the languages we're talking about today
are not going to be nearly as useful in a few years and few years out.
But the fundamentals, the ideas underlying them will be the same.
And so the goal today is to pick up new ideas and syntax along the way.
So recall that where we began was this in week 0, like hello, world.
Everything was so cute and easy to do.
It sort of escalated quickly when we got to see
where all of a sudden hello, world became a little something like this.
But, to my point about Python being higher level
and just doing more work for you, today, in Python,
if you want to implement hello, world, it's
going to be reduced to a single one line.
And we'll see this in all sorts of contexts.
The catch, though, is that if you want to run Python programs,
that process today is going to change a little bit.
Recall that, in C, we've had this technique for a while now where you have
to make your program, and then you can run it with ./whatever the name
of the program is.
Technically, we reveal that that's short for a longer form command where
Clang is the actual compiler.
But, today, the command is going to be simpler and fewer in quantity
and that this is the command, henceforth, via which we'll run
a program in a language like Python.
And, in particular, there's a few things that have changed here.
Obviously the file extension is different.
Instead of c, it's going to be .py or py for Python.
But, notice too, it's only one step instead of two.
And that's because, as we'll see, Python is generally
described as an interpreted language where a C is generally
described as a compiled language.
And that's not a characteristic.
That's intrinsic to the language just by convention.
Most everyone in the world, when writing C code,
compiles it thereafter from source code to machine code, the 0's
and 1's that your computer, your CPU ultimately understands.
But Python and other languages like it are a little more user-friendly
in that you don't need to write your code, compile your code, run your code,
change your code, compile your code, run your code.
You can actually skip the compilation step
and just use a program that coincidentally is called Python itself.
But, whereas Clang, for instance, was a compiler that
converted source code to machine code, Python, in this case,
is an interpreter, which, for now, you can
think of as just running your code top to bottom, left to right,
and looking at each line of code and figuring out
what to do with it without actually compiling it to 0's and 1's first.
So it's a little more user-friendly, half as many steps.
And so that too is a good thing.
Well, let's actually see this in context for a moment in VS Code.
Let me go over to the very first program we
wrote in C, which was this one here in a file called hello.c, or, in this case,
hello0.c.
And what I want to do here is create a new program that's
the distillation of this in Python.
So let me do code of hello.py, in this case.
Notice, that it's opened a second tab as always.
But what I'm going to do a bit of today is open two files side by side
just so we can see exactly what's going on.
So if I drag this tab over here, you'll see
that it'll split the screen in this nice, convenient way.
So now I have two files open.
But, in this file, I'm just going to do print, quote, unquote,
"Hello comma world", and that's it.
Well, what am I next going to do?
Well, in order to run this code at right, I don't need to compile it.
I just need to interpret it by running a program called Python on a file
called hello.py, crossing my fingers, as always.
And, voila, now I have written my first program in Python, so kind of neat.
And, so far at least, it's now one line of code instead of six.
There's no curly braces.
There's no includes.
There's no int, main, and void.
There's just a lot of less-- there's a lot less clutter in there.
But the idea's ultimately the same.
But what's exciting about Python and just
to motivate why we're introducing a higher-level language here on out,
you can just get a lot more interesting work done quickly too.
So, for instance, let me go ahead and do this.
Let me go ahead and open up in my own pset5 directory files
that I brought in advance, which was a solution to problem set 5's spell
checker whereby recall that you made a program called speller,
but that compiled a file along with it called dictionary.c,
which you had to implement the functions within.
So if I go ahead and run this program, recall,
on maybe one of the bigger files, like the Sherlock Holmes text and hit
Enter, that's going to churn through all of the seeming misspellings
therein and tell me that time in total took 1.17
seconds to spell check that whole file.
Well, that's pretty darn fast.
But consider how many hours, days, week it
took to actually implement that spell checker, the contents of dictionary.
Let me propose that what I'm going to do here
is open up a new file called dictionary.py.
And I'm going to propose to implement four functions,
but in Python instead of in C.
And those functions are going to be check, load, size,
and unload, and let's see how quickly I can churn out problem set
5 using a language like Python instead of C. I'm going to go ahead
and open a file called dictionary.py.
And, in the first line of code, I'm going
to give myself a variable called words.
And I'm going to set that equal to a function
called set, which, just like in math, gives me
a container for a set of values, so no duplicates, for instance.
You can think of it sort of like an array, sort of like a list,
but less well defined in this case.
It's just going to be a set of words.
Now, I'm going to go ahead and define a function in Python called check.
Just like in C, it's going to take one word as input.
And the way I'm going to implement this check function in Python
is quite simply is this. return word.lower in words.
All right, that's it for the check function in Python.
Now, I'm going to go ahead and define another function called
load, which, just like in C, takes a dictionary as input.
And then I'm going to implement that as follows.
With open dictionary as file colon.
And then, below that, words.update file.read .splitlines,
and that's it for that.
And then I'm going to go ahead and return true, capital T. Below that,
I'm going to define a size function whose purpose in life is just like in C,
to return the size of this here dictionary.
So I'm going to return the length of that words variable
that I created on my first line.
And then down here I'm going to define, lastly, a function called unload.
But, as I mentioned earlier, because Python manages your memory for you,
you don't need to go and free anything like that.
So, you know what, I'm just going to say return true, and I'm done.
This then is problem set 5 written in Python.
So a bit of a flex, to be fair, because I had the cheat sheet in front of me
with all the answers.
And it might've taken me, though, a few minutes to actually implement
this instead of indeed a few hours or, again, a few days.
And what's in here should not necessarily be obvious.
These are some somewhat cryptic lines of code vis-a-vis what
we've been doing in C. But, by the end of today, by the end of this week,
by the end of the course, after which you've seen more Python,
you'll be able to read and understand what's going on here.
And, in fact, the way I myself wrote this code some time ago was I opened up
in one file dictionary.c, and then I opened up another file, dictionary.py,
and I essentially translated the left to the right
by googling, as needed, the syntax in Python or looking back at my own notes.
But that, too, is going to be how we, today and this coming week,
introduce you to this new language by showing you
how it is similar to and sometimes different
from a language you already know.
And so the hard part is done.
Now that you know a fairly low level and challenging language like C,
even though it's been just a few weeks, you
can really bootstrap yourself to knowing and understanding
new languages, present and future, by just
recognizing similarities and patterns.
And, along the way, there's undoubtedly going
to be new features that you encounter in Python, in future languages.
But no big deal, you're just going to be filling in some gaps in your knowledge
at that point, instead of starting from scratch.
I guess, pun intended.
Well, let's do one other sort of revelation here.
Recall that in problem set 4, you had to implement
a few filters like that of blurring.
And maybe you were feeling more comfortable,
and you did a bit of edge detection.
Let me propose that I could do exactly that in some Python code too.
So let me go ahead and open up a new file, for instance, called blur.py.
Let me go ahead and use a library that comes with Python that we've already
installed.
It's called the Python image library, so from PIL import Image comma ImageFilter.
Then, on my next line, I'm going to create a variable called before.
I'm going to set that equal to the return value of a function
called Image.open.
And I'm going to open a file that you've seen before, bridge.bmp.
My next line of code, I'm going to create a variable called after
to represent after the filtration of this image and set that equal
to the before variable .filter, passing in as an argument ImageFilter.BoxBlur
open parenthesis 1 close paren.
And then, lastly, I'm going to do after.save.
And I'm going to save this file as out.bmp.
Now, of course, I'm relying on the fact that there is a file called bridge.bmp.
So I'm going to grab a copy of that from problem set 4,
and that file is going to be a nice, pretty picture of the Weeks Bridge down
by the river.
And, in fact, if I open that up with code of bridge.bmp,
this here is the original version of that there bridge.
So let's run my four lines of blur.py code on this.
And, just to make it a little more obvious on the screen
here, instead of just looking at one pixel around every pixel to blur things,
I'm going to be a little dramatic and use 10 pixels just
to make it even blurrier as to appear nicely on the screen.
I'm going to go ahead and run Python of blur.py.
And, when I hit Enter, those four lines of code will be interpreted,
so to speak, top to bottom, left to right.
Nothing seems to happen.
But if I type ls now, I should see, indeed, a file called out.bmp as well.
Let me go ahead and open that, out.bmp.
And, whereas the before version was this,
the after version is now this in just four lines of code.
And, for those of you who were indeed feeling
more comfortable with that same problem set,
let me propose to implement the edge-detection algorithm that you
might recall.
And let me create a different file for that, so code of edge.py.
And, inside of edge.py, I'm going to go ahead and do the same thing as before
from the Python image library.
Import an image feature and an image filter feature.
Then give myself a variable again before equals Image.open,
quote unquote, bridge.bmp.
Then a variable called after as before equals before.filter,
passing in this time ImageFilter.FIND_EDGES,
which is a feature that just comes with this library.
And then I'm going to go ahead and do after.save and, again, out.bmp.
I'm going to very quickly then run Python,
the name of the interpreter on edge.py, which
is going to use as input bridge.bmp again, which is the original version.
But if I now open up out.bmp and hit Enter, instead of looking like this,
now, after four lines of Python, it looks like this.
So if you've been feeling a little frustrated by just how much
time, how much energy, how many lines of code
it takes to solve problems that ultimately may very well be
interesting visually or otherwise, it's now
going to get a lot easier to do some of those same features.
But, of course, we'll give you the capability
to do some more things as well.
But, before we do that, let's actually take a tour of what some of the features
are that we're going to get now with a language called Python, sort of evoking
memories of week 1 when we transitioned from Scratch to C. So,
in the world of Python, there's absolutely functions.
You just saw a whole bunch of them.
And, again, the syntax looks new and different and perhaps a little weird
versus C. But, over the course of today and this week, everything I just typed
will become more familiar.
Here is going to be a side-by-side comparison now of Scratch,
just like from week 0, to this week in Python.
But we'll compare it along the way to some C code as well.
So this was, of course, the simplest function
we used back in Scratch to just say hello, world on the screen.
In C, it looked a little something like this,
but I've claimed already today, in Python,
it's going to instead look like this.
And, just as a little bit of a comparison, what's different?
Let's see, yeah.
So there's no semicolon.
Amazingly, Python largely gets rid of the semicolon.
So, when your thought is done, that's it.
Python will figure out that it's done.
You don't need to terminate your thought with a semicolon.
What else is different here?
Yeah.
AUDIENCE: Backslash n.
DAVID J. MALAN: Yeah, so backslash n is missing, which, in C,
we needed to tell the computer to add a new line, so to speak.
Move the cursor to the next line.
Turns out that, after years of experience,
humans decided that, gosh, we are so often using backslash n in our print
statements, let's just make it the default instead of vice versa.
That does invite the question, well, how do you undo that?
But we'll come back to that before long.
But, indeed, you don't need the backslash n.
The third and final difference, perhaps obvious now,
is that it's print instead of printf.
That doesn't mean you can't format strings,
but the word print is just so much easier to remember.
It's a little less arcane.
So the Python community decided, in their language,
to call this print instead.
And what you're seeing already is the slightest hints of the reality
that, after years pass and different programmers start using languages,
they come up with opinions, what they like, what they don't like.
They eventually decide we're going to invent our own language that's
better than everything before it.
And so what you'll see is that a lot of the frustrations,
confusions you might have encountered, you're in good company
because some of those now will go away.
The catch is, of course, sometimes people
will disagree as to what the right outcome is, the right design.
And this is why there's actually hundreds, maybe thousands,
of programming languages in the real world.
Thankfully, there's probably only a few dozen
that are actually very popular and commonly used in practice.
All right, so, in the real world too, we, of course, have libraries.
And we saw some of those libraries in the world of C,
we're also going to see them in the world of Python,
even more powerfully so, like the filtration
we just did of images being able to very quickly implement a spell
checker with the code that I wrote.
In the world of Python, just know that libraries are generally
called modules and packages.
And there's some slight difference between those two,
but, for now, module packages are just Python terminology
for what we already to be libraries.
CS50 has its own library.
And, in fact, in C, we use this atop any program
that we want to use get_string, get_int, and strings themselves.
In Python, they're still going to be a CS50 library, but very
brief training wheels that are available,
if only to ease the transition from C to Python.
But the syntax for using CS50's library henceforth is going to be more
simply import CS50, very similar to what we saw a moment ago with that Python
imaging library--
Python image library.
There's alternative syntax you might see over time where
if you only want to import one or specific things,
you don't have to import the whole library.
You can import from cs50 a specific function or symbol more generally
like this.
So you'll see two different techniques like that.
Well, let's go ahead now and actually build
on the program we wrote already by doing something just like we did in week 0
as well as in week 1, where we actually got input from the user.
So, in Scratch, here was how we prompted the user.
What's your name?
We got back a so-called return value.
And then we joined hello comma space with that there return value.
In C, this didn't translate nearly as cleanly.
We had to introduce, of course, not only get_string for the same function.
But we also had to introduce, in the context of printf,
these placeholders like %s.
For better or for worse, what you're about to see
is several different ways to solve the same problem in Python, some of which
are a little more similar to Scratch, some of which
are a little different from scratch as well.
Don't have to absorb them all from the get-go.
But here's how we might do this in Python instead.
One, we can declare a variable called answer.
We can then set it equal to the return value of get_string, which, for now, is
in the CS50 library for Python.
You don't need it per se in the real world.
But, for now, for parity with C, we've given you this get_string function.
It, like in C, takes an argument like, quote, unquote, "what's your name?"
But no semicolon at the end of this line.
Second line of code, notice that we're again using print in Python, not printf.
We're saying, quote, unquote, "hello comma space".
And then a little weirdly, we're using what looks like the addition operator
to add, so to speak, the answer to that end of that phrase.
But those familiar or not, what might the plus really represent here?
It's not addition in a mathematical sense.
Yeah.
AUDIENCE: Concatenation.
DAVID J. MALAN: So it's what we would call concatenation,
to take one string on the left, one string on the right, and join them,
that is, concatenate them together, which is why I need not only the comma
grammatically here but also a space so that we actually have
a string that looks the way we intend.
So this is one way then to implement this here program that we already
implemented in Scratch as follows.
But there's other ways as well.
I can also change this, a little weirdly,
to be a comma-separated list of arguments.
So, it turns out, unlike in C, in Python, if you pass one, two, three,
or more arguments to the print function, by default, they
will just all be printed 1, 2, 3, but with a single space in between them.
So that's just the way the print function works per its documentation,
which we'll see before long.
So here I've gotten rid of that space, and I've just
said my first argument is hello comma.
And my second argument is answer.
And I just leave it to print to effectively concatenate them together
on the screen by printing one followed by the other.
So that's the second way we might do this in Python.
Here's a weird-looking third that, for better or for worse,
is probably the most common way to do things nowadays even
though it's more of a visual mouthful.
So I'm still using the print function, but there's that f
again but in a weird place.
It turns out, if you want Python's print function to format a string for you
by plugging in one or more values, the way you do that is you tell Python,
not next to the print function, but to the left of the string itself
that, hey, Python, here comes a format string, aka, an f string.
And then, inside of those quote marks nicely enough,
you can actually use literal placeholders,
these curly braces, that say put the value of the answer variable there.
So it's sort of a new and improved version of printf in C, which,
annoyingly, always had us using %s, %i, %f, and so forth.
Now, you just put curly braces and the name of the actual thing
you want to plug in to that location.
This is called variable interpolation whereby the variable's value, answer
in this case, will be substituted without the curly braces appearing
in the final output.
So that's then how we might implement exactly
that same feature using this thing called a format string.
So how might I go about doing this?
Well, let me actually go back to VS Code in just a moment here.
And let's go ahead and open up my same file called hello.py.
So code of hello.py, let's go ahead and implement this variant thereof.
So, in hello.py, I previously had just this single line of code-- uh-oh.
Yes, what's going wrong?
IAN: Just a little crimp.
DAVID J. MALAN: Oh, it was making noises.
Sorry.
OK.
That was Ian.
Thank you, Ian.
[APPLAUSE]
OH, thank you, thank you, Ian.
So, here, let me go ahead and open a file called hello1.c, which
I brought back from week 1 itself.
And let's go ahead and open up hello.py here again.
Just so we can see these things side by side,
I'm going to drag this one over to top-right
so we can see hello.c on the left, albeit somewhat cut off, and hello.py
on the right.
And let's now change hello.py to actually get some user input.
So, from CS50's library, I'm going to import a function called get_string.
And then, inside of this actual program, I'm
going to create a variable called answer.
I'm going to set it equal to the return value of string.
I'm going to pass in a prompt like, what's your name question mark space,
and then close quote and close parentheses.
And then, lastly, I'm going to use one of those f strings
and print out, quote, unquote--
or, rather, f, quote, unquote, "hello comma answer", close quotes.
And it's a little weird now with the f and the quotes
and the curly braces and the parentheses,
but if you just follow them from inside out,
they are all nicely symmetric and balanced.
If now, in my prompt, I go back down and run Python of hello.py, Enter.
Instead of seeing, of course, hello comma world Immediately,
I can type in my name and hit Enter.
And now I see exactly that.
But there's a few things I could do wrong here.
For instance, if I forget this here format string and just do, quote,
unquote, "curly brace answer" and then I go back and run Python of hello.py,
I'm still going to be prompted for my name, like David.
But what's going to go wrong now intuitively?
What am I going to see?
Yeah.
AUDIENCE: You're going to [INAUDIBLE]
DAVID J. MALAN: Perfect, because I haven't told Python
that this is a special formatted string with that little f,
it's indeed going to print out hello comma curly brace answer
just as we see here.
So a subtle bug, but one that's very easily fixed with that there f,
but there's something else worth noting here.
Let me go back over to highlight this code.
This varies from C, oh, in another way too.
There's indeed no semicolons on lines three or four.
But what else is different vis-a-vis the C version here still at left?
What's different?
How about here?
AUDIENCE: There's no main.
DAVID J. MALAN: So there's no main.
So there's none of this.
There's none of this, and there's no curly braces.
Yeah, what else?
AUDIENCE: Declare the type.
DAVID J. MALAN: I didn't have to declare the type of the variable.
So this too, for better or for worse, is a feature of Python.
We'll see that Python has data types.
There are strings, there are ints, there are floats,
but you don't need to tell the interpreter what your variables are.
Rather, Python as an interpreter will just figure it out from context.
So if you're assigning a variable called answer
to what clearly is going to be a string, the type of that variable answer
will be a string.
If, though, you used get_int or something similar,
the type of that variable might be an int, instead.
So here too, a lot of the things that, why doesn't the computer just figure it
out? are baked into Python as features.
So if I go back over here after now having
implemented this version of hello, we can revisit perhaps something
that I glossed over earlier whereby, in Python, the default seems
to be to give you a new line at the end of any print statement.
But that does invite the question, well, how do you actually get those back--
or get rid of that if you indeed do?
Well, this gives us a brief opportunity to talk about one piece of jargon
in the world of Python and certain other languages, which
is that all of these parameters or arguments we've been using for weeks,
where you just put a comma-separated list of arguments or values
inside of parentheses when calling a function to give those functions input,
those have, all this time, been called positional parameters because the order
has always mattered.
The first thing, the second thing, the third thing
influences what the function does with those arguments.
But, in Python and certain other languages,
there's also what we're going to call named parameters whereby
you can actually specify not just a generic comma-separated list of values
for which the order matters.
You can instead provide the name of a variable and its value,
the name of a variable and its value, specifically, the name of a parameter
and its value as a comma-separated list, the upside of which
is that it's a little clearer to you, the reader, you the programmer,
what does what?
And it's also not nearly as vulnerable to you just screwing up the order
and getting them slightly out of order and constantly
having to check the documentation as to what goes in what order.
If you recall using fread or fwrite, for instance, which takes a few arguments,
I mean, those two are particularly annoying.
And even I always forget which comes first.
If I could just use the names of those parameters,
it might've eliminated some ambiguity.
So how can we use in Python named parameters.
Well, let's just do a relatively simple example
that's actually pretty commonly leveraged, which is this.
If I, for whatever reason--
let me get rid of my C version now.
And, in fact, let me simplify this and just go back
to printing out in hello.py, hello comma world.
This, as before, will print out hello comma world with a new line.
If I want to get rid of this, though, I can do that
by consulting the documentation for Python.
And, in fact, the official documentation for Python lives at this URL,
docs.python.org.
The upside of this documentation existing
is that, unlike C, which doesn't really have an official place
to go for documentation other than the manual pages
that we, recall, at manual.cs50.io have given you student-friendly versions
thereof.
Everyone in the world goes to this URL when looking up things for Python
officially in its own documentation.
For instance, at this particular URL, there is a list of all of the functions
that come built into Python itself.
And if we poke around further there, there's
one indeed called print, which is really the only one I've been using
thus far that comes with the language.
And in that documentation, you'll see a somewhat cryptic line like this.
This is the so-called signature or prototype for the print function.
The syntax for this is a little different from what we saw in C,
but what I see here in the documentation,
if you go to that same URL, is that there's
a function called print that takes potentially one, two, three, four,
five or more arguments, five more arguments or parameters.
But what are they?
Well, over here is some new syntax.
And, trust me, this does not mean pointers.
There's a * but nothing to do with memory or * or memory or pointers.
This just means that there's going to be 0 or more objects that
can come as a comma-separated list.
And we've used that feature already when I printed hello plus name.
When I printed hello comma name, I got back one--
I passed in one or two arguments.
This just means you can pass in 0 or more just by their position.
The rest of these are so-called named parameters
whereby the print function comes with one named parameter called sep
for separator, whose default value is a single space per the, quote, unquote.
The print function also comes with an end named parameter whose default
value-- and here is going to be the answer to that question earlier--
is backslash n.
So this is why every line ending, from the print function,
has a backslash n automatically given.
There's something called file.
There's something called flush.
More on those perhaps another time.
But this is why I automatically got a free space
when I passed in two arguments.
This is why I keep seeing my cursor moved to the next line.
But the fact that these things have names sep and end
means I can use these named parameters if I so choose
to override their default arguments.
So, for instance, if I want to override the separator, I can use, quote,
unquote, "something else" in between words.
If I want to override the new line, I can change the backslash n to something
else as well.
So if I go back to VS Code here and, for whatever reason,
I do want to get rid of that new line ending,
I can pass a second argument into print, specify that the name of this parameter
is E-N-D, end, and set it equal to not backslash n, but really anything I want.
So, just to be dramatic, let's use an exclamation point to excitedly
say hello, world.
And if I now rerun this program as such, now I see hello, world!
But then my prompt is immediately on the same line.
I can get rid of that too if I really want.
I can do backslash n after the exclamation point and rerun this again.
And now we're back to the usual.
But I do get that exclamation point now for free as default functionality.
So it's a little weird because I'm mixing sort of apples and oranges,
so to speak, whereby this is positional and this is named,
but, so long as you put your positional arguments first and any things that
have explicit names after those, Python can distinguish one from the other.
Questions then on any of this just yet?
Questions?
Yeah.
AUDIENCE: Can you change the type of the variable [INAUDIBLE]?
DAVID J. MALAN: Oh, really good question.
Can you change the type of a variable once it's there?
Can you change, for instance, a string to an integer or maybe vice versa?
Short answer, yes.
And we're going to trip over that with an example in just a bit.
And let me call out one other thing that's worth noting here.
In the documentation for Python and even in your own code,
it turns out that you can use single quotes in ways we have not thus far.
Recall that in C double quotes meant it was
a string, so typically a phrase, a sentence, a paragraph, whatever.
But single quotes in C represented what?
So a single character.
That is the definition.
In Python, this seems to suggest single characters too,
but I clearly just did an exclamation point and then
backslash n, so two characters.
And that's in fact allowed.
In Python, there's no difference between single quotes and double quotes.
Stylistically, in CS50 and style50, we'll
actually nudge you toward using double quotes just for parity with C,
but it is perfectly reasonable to use single quotes instead in Python,
but, stylistically, you should be consistent.
Why are they both tolerated?
Well, all these weeks, you've been holding the darn shift key
and then hitting the quote mark to get double quotes.
Now, you don't have to hit the Shift key anymore
if you don't want to just speed up your code even more.
And that, frankly, is probably part of the motivation for even
little syntactic differences like that.
All right, how about some other features that we
might want to bring into the mix?
We've seen use of variables already, like answer.
Let's make this a little more--
let's do this side by side with Scratch and with C as well.
So, in Scratch, this is how we created a variable called counter and initialized
it to 0.
In C, we achieved that by doing int counter equals 0 semicolon.
In Python, we've already seen something reminiscent
of this, albeit with strings instead of integers,
but probably not a logical leap to assume that this, in Python, is
how you could create a variable called counter,
assign it an integer, namely 0, no semicolon, no data type.
And this will simply be an int because it's pretty obvious to the interpreter
that 0's an int, not a string.
So, of course, underneath the hood, this is going to be an int.
What else could we do in Scratch?
We could change the counter by 1, by incrementing it, adding 1 to it.
In C, we saw a few different ways to do this.
We can do counter equals counter plus 1, which
seems like a paradox that how could that possibly be.
But, recall, we do the addition at right.
We copy the value from right to left when using the assignment operator.
In Python, meanwhile, we would do this-- counter equals counter plus 1.
Same exact thing, except for, of course, the semicolon no longer being necessary.
But, in C, we could also do this-- counter plus equals 1 semicolon.
Turns out you can do the exact same thing in Python without the semicolon.
But there's one thing you can't do.
Who knows why?
But what can you probably not do?
AUDIENCE: counter++.
DAVID J. MALAN: Yeah, so counter++.
If you've been in the habit of using ++ and --, for better or for worse,
Python does not have those.
So we're back to the slightly more verbose version here.
So we get two out of the three possibilities,
but just a minor difference that will be ingrained over time.
Well, what about the actual data types that Python supports?
Well, we've used strings already.
I just showed some integers there.
Python does have its own list of data types, which is actually, at a glance,
shorter than C's when it comes to the most primitive ones.
In C, we saw at one point pretty much this list.
And then we created some of our own.
In Python, this list indeed gets a bit shorter such
that we have bools still for true/false values.
But, as you might have glimpsed earlier, it's
capital True and capital False, T and F, respectively, just because.
There are still floats in the world of Python,
there are still ints in the world of Python, and there are strings,
but they're called strs, S-T-R for short.
And there are indeed some other ones as well.
But there are no doubles, per se.
There are no longs.
Rather, Python generally uses a bit more memory so you as the programmer
don't need to worry about how many bits are being used, particularly
for something like integers, so more on that before long.
AUDIENCE: Are there no characters?
Would that be strings?
DAVID J. MALAN: Good question.
Are there no characters?
Short answer, correct.
There are no characters.
There are only strings which can be single characters and even 0 characters
because, heck, that seems sufficient rather than distinguishing
between one or the other.
So if you want a character in Python, really, the best you can do
is a string with a single character instead.
Now, it turns out, in Python, there's going
to be other features as well, data structures.
So, just a week ago, we spent on week 5's material
when looking at trees and tries and hash tables and more.
Python just gives you those and other data structures built in.
No longer do you implement your own spell checker with your own dictionary.
You can use, as we did earlier, a set.
Turns out there are dictionaries or dict objects
that come with Python that you can yourself use.
There are tuples which are like x comma y values
or latitude comma longitude, so short lists of values.
There's actually lists, which are similar in spirit to C's arrays.
But recall that the headache of C's arrays as of week 5 was it's
not very easy to grow them or shrink them because of all
the darn memory management.
Python, if you use a list, essentially gives you a linked list automatically.
You don't have to think or use any memory management or pointers at all.
And range, we're going to see, just gives you a range of values.
If you want to count from 1 on up to something else,
range is actually a function that can give us some
of that same functionality as well.
So let's perhaps take some of these out for a spin here.
Let me go back to VS Code.
Let me close up hello.py.
And let's focus on maybe implementing a simple calculator
as we did a few weeks ago.
In fact, let me go ahead and open up from my distribution code from lecture
today wherein I brought in advance-- and these were on CS50's website--
a whole bunch of examples from earlier weeks that we already
implemented together.
So, for instance, in week 1, we actually implemented a calculator
that prompted the user for two ints, x and y,
and then simply added them together using printf in this way,
with percent i as the placeholder and a second argument,
which was the sum thereof.
Well, if I want to implement this in Python,
it's actually going to be pretty similar.
So let me also run code of calculator.py.
That's going to open a second tab.
For the sake of comparison, let me drag this over to the right
so we can see these things side by side.
And now let me do this, from CS50's library import
the get_int function, which I claim exists in that library.
Then let's go ahead and create a variable
called x, set it equal to get_int, and pass in a prompt of x colon space
just so the user knows what we're asking for.
Then let's do y equals get_int and prompt the user for a y value.
And then, down here, let's go ahead and print out x plus y.
I think it's pretty straightforward as written there.
We don't mention the semicolons.
We don't mention the data types.
But, for the most part, the logic is exactly the same.
Let me run Python of calculator.py, type in 1, type in 2,
and I do get back, in fact, 3.
So that calculator seems actually to work.
But let's get rid of CS50's library.
So, just as quickly as we put these training wheels on today,
let's take them back off so, at the end of the week, at the end of the course,
certainly, you're not relying on any of these training wheels anymore.
So let me get rid of this line of code at the very top,
no longer using get_int.
And let's do this using Python's own built-in functionality.
So Python itself supports this here function
called input, which similar to get_string and get_int and get_float
takes a prompt as input.
So I'm going to say x colon as before.
I'm going to go ahead and say input y colon as before,
and then I'm just going to print these both out using Python's own input
function instead of CS50's get_int.
Let's run Python of calculator.py again, Enter.
Type in 1, type in 2, and the answer, of course, should be not 12.
So what just happened here?
Should still be 3.
Yeah.
AUDIENCE: Yeah, format [INAUDIBLE] strings.
DAVID J. MALAN: Yeah, so it seems that x and y came back as strings.
And so what's happening with the plus operator here
is it's actually being interpreted as concatenation.
So I'm really saying not 12 per se, but 1 2 join together because the variable
that apparently-- the return value that comes back from Python's own input
function appears to be a string, that is, a str by default.
Now, there are ways to fix this in Python.
And, in C, recall that we were able to cast some values from one
to another, like ints to chars and back and forth.
It's not quite as easy as that in Python because, technically,
a string, as we know underneath the hood has one or more characters.
Maybe there's a backslash 0 somewhere in there.
Who knows how Python is doing it, but there is a function in Python
called int, which takes as input a string.
And it will do its best to convert that string
to the actual int that resembles it.
So if it's, quote, unquote, "1", it's going to give me the actual int known
as 1 and so forth.
So let me do that here as well as here.
Let me again run Python of calculator.py, Enter.
1 again, 2 again, and this time 1 plus 2 equals 3.
So similar in spirit, but now I just needed new tool in my toolkit,
this int function which does that conversion for me.
Now, what actually is in this library, CS50's own
that you may or may not want to use?
So, in C, we had these functions as well as some other stuff,
including the actual definition of string.
In Python, there are indeed strings that come with the language.
They're simply called strs, S-T-R.
In CS50's library for Python, though, we kept
it simpler and consistent with Python the language itself.
So CS50's library for Python has get_string.
It has get_int.
It has get_float.
These we'll see are still useful because, just like in C,
recall that if the user types in like cat or dog
when you're actually asking them for an integer, our functions
prompt the user again and again and again.
So these functions will do that as well.
We'll soon see that the input function in Python,
it's quite similar to get_string, but it's not
as tolerant of invalid input like cat or dog.
If you're actually trying to get an int or a float,
you're just going to see a scary error message instead on the screen, which
we'll come back to before long.
But this is to say the library is there to get you started, but not
strictly necessary, ultimately.
But if you want to use those functions, you
can do as before, from cs50, import the name of the function,
and you can do this three times.
If, for whatever reason in a program, you're using all three of these
can just separate them by commas in this way and import all three of them
here at once.
Or, as you might recall earlier, you can just
import the name of the library, so something like import cs50,
though, the syntax thereafter changes a bit.
Before we forge ahead to now conditionals,
just comparing something side by side, and then we'll
build up some more interesting programs.
Questions?
For the most part, it's just syntactic differences and not
really fundamentally different intellectual ideas under the hood
just yet.
So here we are with conditionals.
In Scratch, if you wanted to compare x and y as variables
and say conditionally x is less than y, we converted that to C as follows.
The curly braces are about to go away, the semicolon's about to go away,
and there's going to be one new piece of syntax here.
In Python, the same idea looks like this.
What is the one piece of syntax that did get added, though, in this case?
Feel free to shout it out.
AUDIENCE: Colon.
DAVID J. MALAN: There's a colon suddenly,
which we did not have in C. It turns out,
in Python, though, this is both a plus and a minus depending on your religion
when it comes to whitespace in programs.
So, in C, if you were not in the habit of clicking style50 and letting
it guide you toward better formatted code,
frankly, you could just left align everything in your C programs,
and, even though it would be a mess to read, difficult to grade,
it would still work.
It would still be correct, but just stylistically bad.
In Python, it seems that humans over the years
were just so darn frustrated by students and presumably colleagues
alike formatting their code poorly that, in Python, indentation matters.
So if you want to execute print conditional on x being less than y,
you can't just put print right below if and expect
the reader and the interpreter to figure things out.
You must indent by convention four spaces instead.
You can override that, and you can adopt different paradigms
within your own company or school.
But four is what style50 would now expect.
So this is to say, the colon means execute conditionally
everything that's indented below that as though there were curly braces instead.
All right, how about something else in Scratch?
If you wanted to do an if-else, it looked like this.
In C, it looked like this, which is identical except for the else
block here.
In Python, you can probably predict how this
is going to get a little more succinct.
No more semicolons, no more curly braces, no more backslash
ends for that matter, but a colon here and a colon here.
And, again, indentation matters and must be consistent,
four spaces in this case for both.
Finally, if, else if, else we did in Scratch.
You can do that same thing in C almost identical,
except we've got this else if.
This is the only one that's weird, and even
I forget how to spell this all of the time.
In Python, the semicolons are about to go away,
the new line is going to go away, the curly braces are going to go away,
and we're going to misspell else if as such.
So it's elif, in Python, colon, which is how
you would implement if, elif, elif, elif, else for a conditional like this.
Some languages very confusingly use else if or elsif but no e
and probably shouldn't've said that because now you'll
be as confused as I have been for years.
But let's move on to what we can actually do now with these here strings.
So we know what we can use these conditionals in this way.
Let's go ahead now and revisit some programs
from C but this time using some new syntax and features.
So let me go back to here VS Code.
Let me open up in one window here.
How about compare3.c?
So this was from today's distribution code,
a file called compare3.c, which we looked at some time ago.
And what this program did, quite simply, is
exactly what we just saw on the screen, but with a full-fledged main function
and the header files and the like.
But all this program does is tell us whether x is less than y or not.
All right, how can we go about implementing this in Python?
Pretty straightforward.
Let me open my terminal.
Let me do code of compare.py for this version.
Let me drag it over to the right so I can see these things side by side
and hide my terminal again.
Let's go ahead and import from cs50 the get
int function just to make our lives a little easier for now.
Let's use x equals get_int and prompt the user for What's x question mark,
just like I did at left.
Let's do y equals get_int, passing in, What's
y question mark, just like at left.
Then let's just do if x is less than y colon, Enter.
And, notice, VS Code is not only smart enough but deliberately configured by us
to know something about Python.
So it automatically indented for me.
Just like C very often has to.

Let's print out x is less than y quote unquote.
Elif x greater than y colon, then let's print out x is greater than y,
close quote.
Else colon print out x is equal to y.
So nothing different versus the slides, but you can kind of
see visually just how much more compact the code is, like 11 actual lines
instead of 21.
So it's just eliminating a lot of distraction and clutter
and tightening things up.
If nothing else, let's go ahead and run Python of compare.py, Enter.
Let's type in 1, type in 2, and let me just wave my hand at the reality
that I'm pretty sure the code is correct and would work correctly
if we typed in 2 and 1 or 1 and 1, 2 and 2, and so forth.
So this is to say that comparing integers in Python
logically works exactly the same way as in C, but things, recall, in Python
got a little weirder when we actually tried comparing, say, strings instead.
And recall that when we compared strings in Python,
we had a solve a problem we encountered.
The very first time we compare two strings in C, s and t,
as I think I called them weeks ago, they were never the same
according to my first version of my code.
Why is it harder to compare strings in C?
AUDIENCE: The address [INAUDIBLE] the wrong address.
DAVID J. MALAN: Exactly.
So recall from week 4, where we really looked underneath the hood
and we realized that, oh, a string is really
a char star, which is the address of the first character in the string.
So whenever you compare two strings with equals equals in C,
you're really comparing the memory addresses,
and those probably are not going to be the same.
So even if the strings look the same, they're always different.
That was a pain in the neck.
We had to add in the string library and the str
compare function, str comp-- strcmp.
It was just a lot of work to do something so darn common.
It is super common to want to compare strings.
In Python, wonderfully-- let me close the int-based version from C here--
let me propose here that in Python, if you want to manipulate strings,
you could use CS50's own get_string function.
But I don't even need that.
I can use the input function, as we saw earlier.
So if I want to prompt the user for s equals, the return value of input,
and just prompt them for a string like s. t equals the input function-- prompt
them for a string called t.
In Python, wonderfully, it works the way you would hope.
If s equals equals t, then print out, quote unquote, "Same."
Else, print out, quote unquote, "Different."
So here, again, it just works the way you would hope.
And you don't have to pull out your textbook or your old examples
to figure out how to do something relatively straightforward--
conceptually is comparing two strings.
Let's do one other example that evokes a past example as well.
Let me open up a program that, in week one, we called agree.c.
So at left, here is a program that we wrote several weeks ago now that used
the CS50 library, the standard IO library.
It used the getchar function to ask the user,
do you agree with some terms and conditions or whatever.
And then we use this syntax, which was very new in week one
because not only were we using equals equals,
we used the vertical bars, which meant what logically?
Or.
So we used or to detect if someone typed in uppercase or lowercase for either y--
or big Y, little y or big N, little n as well.
So, in Python, let's do this instead--
code of agree.py.
I'll hide my terminal window, but I'll drag this here over at left.
And in the Python version of this, turns out,
I can do something similar as follows.
Let's do S equals input and prompt the user, do you agree, question mark.
Then let's say if s equals equals quote unquote y or s equals quote unquote
little y, then print out quote unquote "Agree," just like in the C version.
Elif s equals equals capital N or s equals equals lowercase n,
then print out "Not agreed," just like in the C version.
And here, again, we're sort of seeing just how much this condenses our code.
It's working logically the same, but what are some of the differences
visually?
Well, there's no curly braces, there's no semicolons, there's no new lines.
But what is there?
This is why Python 2 is considered more user-friendly.
If you want to express the idea of "or," literally write "or" instead of vertical
bars and double ampersands and the like.
So I'm using or here as well as or here.
Notice there's no parentheses either around these conditionals.
So we didn't see those on the slides.
We don't see them here.
What Python does with parentheses is that if you
don't need them logically to combine Boolean expressions,
just don't use them at all.
You could use them here and here and here and here.
But if it's not necessary, why bother further cluttering your code?
You simply do not need to do it.
But let's see if there's a way to improve this.
Let me first run this and make sure it works as intended--
python of agree.py.
Do I agree?
An emphatic yes.
Let's do a lowercase n.
And agreed and not agreed are indeed the answers I get back.
But this feels a little redundant, I would say.
Notice that my code here is really just asking the same question twice,
albeit for lowercase, and it's asking the same question twice here,
albeit for lowercase for the n as well.
Well, it turns out, in Python, I can actually tighten this up.
Let me get rid of my C version and focus on this one, and let me go ahead
and condense this further as follows.
If s is in the following list of values, quote unquote, "Y," quote unquote,
little "y", colon, and then, down here, I'm going to do the exact same thing,
logically.
Elif s is in this list of comma-separated values, capital N,
lowercase n, this now would achieve the same result.
It's a little tighter because I'm not using or.
I'm not using equals equals four times.
I'm using it not at all, in fact.
I'm using a new keyword which, in Python, exists--
"in"-- as a preposition-- is a Python keyword, does not exist in C.
But this here would be a little tighter as well.
So let me go ahead and run Python of agree.py, Enter.
Do I agree?
Capital Y-- it still works.
Or if I do lowercase y, it still works.
But this isn't as featureful as would be ideal because what if the user types
in, for instance, an emphatic YES in all caps?
Well, now it just ignores me altogether.
Now you could go in and, of course, address that.
I could do capital YES and lowercase yes.
But wait a minute, what if they just capitalize the first letter?
So I should really have y.
And then, well, what if their Caps Lock is not working as intended, and maybe
we do something like this?
And now we've got to do this.
I mean, these are all spelled the same, even if they're miscapitalized.
So this just feels like it's becoming a mess pretty quickly.
So, logically, whether it's in C now or in Python,
what would ideally be a better logical solution
to this than enumerating all possible values that we care about?
Yeah?
AUDIENCE: Change the input to lowercase.
DAVID J. MALAN: Yeah, why don't we just change the user's input
to lowercase or equivalently-- just change
it to uppercase, to canonicalize it, make it the way I expect it to be,
and then compare it against a much shorter, finite list of values?
So how do we do this?
Well, in the C type library, we had a tolower function, which was handy,
and we had toupper.
But in Python, what's nice is that Python actually has not only strs,
or strings, as first-class objects that come with the language itself,
Python itself as a language is known as an object-oriented language.
And it has other features as well.
And some of you in high school, if you ever studied Java or the like,
you might already know about object-oriented programming, otherwise
known as OOP.
And what this is referring to is a new and improved version of C structs.
Recall that in C we had structs whereby we could create our own data
types for like persons or nodes--
for instance, by creating our own data types
that have one or more other values inside of them.
Well, what C doesn't offer you-- at least not easily--
is to associate functionality with those structures as well.
For instance, for a person object, wouldn't it
be nice if there were a function, especially
if running the code on your phone, that was a call function that would just
automatically call that person or an email
function that would just automatically email that person if we're keeping
track of their email address as well?
Well, you could implement a call function
and pass the person in as input.
You could implement a call function and pass the person in as input,
and then it would work.
But wouldn't it be nice to associate more tightly
and encapsulate related functionality, just like we've
been encapsulating related data?
And this is what object-oriented programming allows you to do.
Instead of having what are called structs in C,
you have what are called objects in Python
and certain other languages as well.
And those objects are typically defined--
what's called a class, when a Class is really
just like a blueprint or a template out of which multiple objects can be made.
And, specifically, in the context of this here example,
we could consult the documentation for the functions that come with the str
object, the string object.
And technically, whenever functionality is associated with a specific data type,
it's encapsulated inside--
it's still a function, but you technically
call it a method, in that case, instead.
So a function is what all we've been discussing in C and in Scratch.
In Python, you still have functions, but if those functions
are associated with a data type, tucked away inside of them,
then they're just also called methods.
It's a minor nuance there.
And among the functions, among the methods,
rather, that comes with strs, or strings,
is a little something called lower.
And there's different ways to go about doing this.
So let me go ahead and, one, simplify this list to just be the list of values
that I actually care about.
So let's suppose that I want to support, quote unquote, "y" and quote unquote,
"yes," but I don't care about the capitalization thereof.
So I could do this.
I could take the s variable and I could-- actually, let's do this.
I can create another variable, t, set it equal to s.lower,
open paren, close paren.
So notice the dot operator, just like in C, goes inside of the object.
Same thing in Python, but here, I'm not going inside of it
to get the person's name or their number or their email address.
I'm going inside of it to call a method that just comes with that type of value.
So in C, just to be super clear, we would have done tolower and pass in s.
Python-- in an object-oriented programming more
generally-- just kind of flips that paradigm
and says start with the variable in question
and call its own lowercase method as such.
And now, if I change this code to t, down here and here,
and I go in here and I search for lowercase n or lowercase no,
and I run this version of agree.py, Enter, I can now type in "Y" for yes,
capitalized, "y" for yes lowercase, YES all capitalized for yes,
y lowercase capital S, like that, any of those variants that exist,
and I only have to enumerate canonical versions thereof.
Even better, I can tighten this up further.
I don't really need a t variable.
In fact, I could just do s equals s.lower and change the value of s
to be the lowercase version thereof.
What's nice about Python, too, is you can chain method calls together.
So if you know that input as a function already returns a string,
you don't need to tuck it in a variable before you
call that string's lower method.
And you can just chain them together in this way.
And you could do this sort of again and again.
This is not a real function, but you could
keep chaining these things together one or more times.
At some point, it's going to look stupid because it's just
going to be too long of a line of code, and then we
get into discussions of style.
But for now, having two function calls like this is pretty reasonable,
I would argue.
And so this just tightens up the code further.
So that is perhaps the newest feature that we've now
seen of Python, this notion of methods, which
derives from this feature of object-oriented programming.
But any questions before we take a quick tour of a few other features as well?
No?
OK, about a couple more examples, then introduce some loops,
and we'll skate our way toward some snacks in just a few.
So let me propose that we look at one other problem from our week
4, where in memory and the fact that it exists and has to be managed by
us was creating some underlying problems.
So let me open up a program from week 4 that was called copy5.c.
At least that was our several iterations in.
And that program looked a little something like this.
And I'll just skim it for a second.
This was getting kind of annoying just to copy one string into another.
So I had to use all of these libraries in C. I used CS50's get_string
function still, but this is when we took the training wheels of strings off,
quote unquote, and started talking about them as char stars.
I checked to make sure that s is not null, just in case
we're out of memory for some reason.
I used malloc, ultimately, to create more memory,
to get more memory for the copy, but still checking if it's null.
I then copied the string from one to the other using strcpy.
I then made sure the string was long enough,
and then I uppercased the first letter in it.
Then I printed them out, then I freed the string, and so forth.
Like, it was a lot of work just to make a copy of a string, which
in programming in general, it'd be nice if you could just do it more simply.
So in Python, here too, it's as simple as that.
Let me go into VS Code, open up a new file called copy.py Then
let me put these two side by side.
And in the right-hand version in Python, let's do this. s equals input,
and prompt the user as before for a string like s, quote unquote.
Then let's go ahead and create a second variable called t,
set it equal to the s variables, capitalize methods return value,
and then print out down here--
how about s and then print out t.
Let me open my terminal.
Let me run Python of copy.py.
Recall that, last time, when I did "hi!," it capitalized the whole thing,
as I recall, as opposed to capitalizing just the first letter.
Enter-- this time, it works as expected.
Now the print is technically a little different.
Down here, I use these format strings.
So if I really want to make this identical,
I can do f quote unquote s colon and then plug in the value of s
with curly braces, f quote unquote t colon t.
This looks uglier, but it's just now printing out prefixes,
s and t respectively.
So if I run this again and do hi in all lowercase,
it capitalizes it correctly for t and only for t.
So here, more so than ever, 33 lines of code at the left, 6 lines, two of which
are blank at right in Python.
Questions about this here example?
Yeah?
AUDIENCE: [INAUDIBLE] question about style.
Those blank lines [INAUDIBLE] not make it all [INAUDIBLE]?
DAVID J. MALAN: Those blank lines--
do you mean get rid of the blank lines?
Oh, you absolutely could.
I have been doing this visually just to make related chunks of code stand out.
So I got s, then I capitalize t, and then I printed them both,
but yes, you could totally format this in different ways,
just as I did at left as well.
Other questions about what we've done here?

How about this?
Let me propose that, in C, we also at one point
try to just uppercase everything in a string.
So let me open up what was a program called, from week 2,
uppercase.c, or really version 2 thereof here.
And this was a program that looks a little cryptic, but all it does
was ask the user for a string, the before version.
It then printed out after colon.
It's just a placeholder for an uppercase version thereof.
We then use strlen and this for loop to iterate over
all of the characters in the string.
And then, one at a time, we use the C type library's toupper function
to capitalize them again and again.
So you can probably imagine where this is going.
We don't need toupper anymore.
We can just use dot upper in some way.
But we do need to have the ability to do things with loops.
So, in Python, we still have loops, but the syntax
is going to be a little different and, frankly, a little easier, ultimately.
So in Scratch, if you wanted to repeat something three times like this,
you could implement it in C very mechanically,
so to speak, like this-- create a variable i,
increment it with plus plus again and again
and again, so long as it's less than three printing meow each time.
In Python, you can do the exact same thing, if you really want,
by saying variable equals value, but no semicolon, no data
type, while i less than 3 colon.
So just like conditionals, you don't need parentheses
if they're not logically necessary.
But you do need the colon, and you do need indentation.
You don't have the plus plus, so we have to do this slightly more verbose Python
version here, but that's exactly the same idea
to implement meowing three times.
Suppose, though, that we wanted to take a different approach here.
We could, in C, use not a while loop but a for loop.
And maybe you're nowadays in the habit of using these a bit more.
They're a little more succinct without all of the vertical clutter.
But this is how we could implement the same in C.
In Python.
It's not quite as obvious how to do this, but we could do it this way.
We could say for i in the following list of values--
and literally in square brackets, as I did
earlier, just enumerate one after the other the things I want to check for.
Instead of y and yes and no and n, I can iterate over three values.
This is fine, but just allow your mind to wander, if it hasn't already,
into thinking how this could get us in trouble.
Why is this approach of just enumerating 0, 1, and 2 probably not the best way
long term to do this?
What do you think?
Yeah?
AUDIENCE: What if you need a lot of values, like 100?
DAVID J. MALAN: Yeah, are you really going
to go-- what if you need a lot of value, like 100 of them?
Are you really going to do 0 comma 1 comma 2 comma 3 dot, dot,
dot to comma 99?
That's got to be a better-- there's got to be a better way than that, if only
because it's going to wrap around the screen.
I'm going to miscount and screw something up.
So indeed there is.
You can alternatively use a function in Python
called range, which does, as I said earlier, give you a range of values.
And if you want a range of three values, starting at 0 by default,
and going up to but not through this value,
you literally call the range function and say, how many values do you want?
And, essentially, what the range function does
is it hands you out one value at a time more
efficiently than the hardcoded list, which puts them all in memory at once.
Range is a little smarter and it knows how to give you, indeed,
just one value at a time.
But notice here, I'm using for i in range of 3, which is similar in spirit
to C, because I have this variable i but I'm not actually using i anywhere.
I'm not incrementing it.
I'm not comparing it against a value.
So strictly speaking, in Python, this is correct.
But stylistically, some people would actually, by convention,
change the i to just an underscore character, which
is a valid character for a variable, but it's just this visual indicator
that yes, this is a variable because for loop requires it in Python,
but who cares what it's called because I'm never actually going to use it.
So you'll see this convention sometimes but perfectly
reasonable to also use i by convention because i means integer,
and that's really what's happening anyway.
But just FYI-- a convention there in Python.
So how can we now use these loops in some actual code?
Well, let me propose that what we could do here is the following.
Let me go back to VS Code here in my uppercase version,
and let me quickly whip up a Python version that
achieves something quite similar.
Let me go ahead and run code of uppercase.py at top left,
after dragging this over.
Let's go ahead and implement the following.
In a variable called before, set it equal to the return value of the input
function with quote unquote "Before" as the prompt.
Then let's just do a placeholder of quote unquote "After" colon space,
space, so they lined up in terms of numbers of letters, close quote, comma,
but let me do end equals quote unquote because I don't want a new line to move
the word below the word After.
So this is just a silly aesthetic detail,
but that overrides the default new line to being no new line.
Now let's do this.
In Python, instead of using this convoluted for loop and the semicolons
that in and this constant checking of a conditional,
I can actually just do this.
For every character called c in the Before string,
go ahead and print out that character uppercase, like that.
But don't print out a new line yet until we get to the very end,
go ahead and print a new line-- by printing nothing, but by default,
I'm going to get a new line.
So passing nothing in gives me one new line, and that's it.
So let me open VS--
let me open my terminal.
Run Python of uppercase.py, hi exclamation point in lowercase,
Enter, and I've messed something up.
Not intentional, but so be it.
Notice the error here.
So this is-- I can make this work.
So there's these things in Python called tracebacks which kind of trace
backwards what you did wrong.
And, in this case, what I did wrong, as for all of these carrot symbols,
is c dot uppercase is bad, but you probably already know that from earlier.
What I should have typed?
AUDIENCE: Dot upper.
DAVID J. MALAN: So dot upper.
So there's a lot of distraction here.
But much like Clang's output, there is some helpful information.
One, the file in question is uppercase.py.
Line 4 is where I made the mistake.
So even though the output is different from Clang's, it is similar in spirit.
Specifically, I messed up an attribute error
because some string object doesn't have an attribute that
is a method called uppercase.
Well, that's an easy fix.
As you noted, I should have written c.upper.
Delete, delete, delete, and now let's clear
my screen, rerun Python of uppercase.py, Enter, hi exclamation point,
and there we have the After version thereof.
But even here, note that, in Python, I'm doing even more work than I need to.
This is indeed how, in Python, I can enumerate all of the characters--
I can iterate over all of the characters in a string.
There's no i's.
There's no conditionals.
Python will just, on every iteration, update the variable c
to contain one letter, then the next, then the next, then the next.
It just sort of works the way you would hope.
But, in Python 2, recall that you don't have individual characters anyway,
so technically, I'm wasting my time by doing this one string of size
1 at a time again and again and again.
I can tighten all of this up here, and I can just, for instance, do this.
I can go ahead and print out, for instance,
before.upper and just uppercase the whole thing all at once.
And then I could technically get rid of the new line,
but now I'm just wasting my time, too.
Let me get rid of all of this.
Let me go over here and let me output, for instance--

let me create a variable called After equals Before.upper.
That's going to store in the After variable exactly what I want all at once
without even using a for loop.
And now I can print out as before an f string saying after colon space, space,
and the value of the After variable.
So this, if I run it again, Python of uppercase.py,
Enter, hi in all lowercase, Enter, that too now works.
And one final flourish-- strictly speaking,
you can interpolate the value of what's returned from a function as follows.
Instead of even bothering with a variable here,
I could put a modest amount of code inside of the curly braces.
And I say modest because if this gets too long,
it's just going to confuse everyone, yourself included.
But in this case here, I can run this one more time, type in hi
in all lowercase, and that, too, now works
because I'm formatting it as an f string.
So, in short, I'm just getting more and more features at my disposal
that I can now use to solve some of these same problems.
So that there was a lot.
Let's go ahead and take a 10-minute break with some Fruit by the Foot,
and we'll be back with more complicated problems.
All right, we are back.
So let's go and use some of this new syntax
to actually make a meowing cat, albeit textually in Python.
So back here in VS Code, I'm going to go ahead and create
a program called meow.py.
And let's first do it the super simple way.
If we want the cat to meow three times, let's literally just do that in code.
So print, quote unquote, meow.
And we get the new line for free.
And then I'm just going to copy paste this again and again.
It's just going to give me three such lines, python of meow.py,
Enter, and there we have it, a cat that meows three times.
Of course, this is correct, but not well-designed
because what should I obviously be using instead as a feature of any language,
instead of three copy-pasted statements?
Probably a loop of some sort.
So let's borrow some of the inspiration from those previous slides.
Let's go into meow.py and change this to maybe a while loop, initially.
So how about i equals 0 then while i is less than 3,
go ahead and print out meow.
And then, let's go ahead and do i plus equals 1,
which is the relatively quick way to do that in Python but not like C++.
Python of meow.py, Enter--
so correct and better designed now.
How else could I do that?
Well, we saw earlier that I could do for i in 0, 1, 2, colon,
and then I can do print quote unquote "meow."
That too would work.
If I rerun Python of meow.py, that works.
But notice I'm not using i, and indeed, I'm not using 0 or 1 and 2.
So, technically, I could do something like, quote unquote, "cat," "dog,"
"bird."
I just need three things to enumerate over.
And that too is going to give me three meows.
So to be clear, the square brackets, much like in C,
are giving me a list of values, but it's not an array.
It's indeed a Python list.
And as we'll see over time, a list in Python is nice versus an array in C
because lists in Python can grow and shrink automatically for you.
So not only are they linked lists of some sort, underneath the hood,
you do not need to worry about resizing them anymore.
But, of course, as we saw before the break,
we should probably just do this more dynamically.
So for i in the range of three values and let Python generate those for me.
If I rerun Python of meow.py, I still get three values.
But here too, stylistically, recall, we said that you don't really
need the name of the variable if you're just
going to do something three times without ever touching that value.
So we could just use an underscore by convention,
which just kind of looks like there's no variable there,
even though there in fact is.
But let's build on this and actually now introduce and really revisit
the ability to define our own functions, which we've seen in Scratch.
We've seen in C, and I technically, at the start of class,
used it to implement my own spell checker.
In dictionary.py, i used def, which stands for define,
and that's how I defined four functions identically named to problem set 5.
Well, let me go ahead and do this and implement an abstraction for meowing,
much like we did in Scratch, much like we did in C. Let me go ahead
and define a function called meow whose purpose in life is simply for now
to print out, quote unquote, meow.
And now let me use that.
Let me go ahead and do something like before.
So for i in range of 3, go ahead and call meow, like this.
I think that's going to get the job done.
Python of meow.py, Enter, and indeed, it's
still working exactly as I expected.
But recall from our discussion of C, we generally stylistically encourage you
to put your main code at the top of the file, if only
because that's the entry point to the program.
If you want to wrap your mind around the code in there,
it makes sense to start with main instead of random functions like meow
at the top of the file.
So let me actually kind of practice what we preached in C.
Let me move this meow function just to the bottom of my file
so that it's sort of out of sight, out of mind
because, now that it's implemented, it just exists.
Let me go back to VS Code and my terminal in VS Code, run Python of meow
again, and hit Enter.
And there's one of those tracebacks, a different one this time.
This time, it's a name error instead of an attribute error.
But where did I go wrong?
Apparently, M-E-O-W no longer exists by nature of having moved it from top
to bottom.
So, intuitively, even if you're new to Python, why might that be?
Yeah?
AUDIENCE: Because you need to define before you call it.
DAVID J. MALAN: Exactly.
I need to define it before I call it, very
similar to C, whereby at least in C, we had
that little trick of just copy pasting the prototype of the function,
just a borrowing its very first line.
Python actually doesn't use that mechanism.
Instead, Python has a different convention instead.
Technically, in Python, you do not need a main function.
Clearly, from all of the programs I've written,
it just works without a main function.
But if you get yourself into a situation where
you're defining your own functions, but the order in which you
define them and then use them clearly matters,
you might as well go ahead and implement a main function after all.
And the convention would be to do this, literally
define with the def keyword a function called main that
doesn't need to take any arguments.
And then, inside of that main function, put your actual code.
Indentation in Python matters, and so I've
hit Tab to indent everything all at once.
And now I have a main function.
So it would seem that maybe now the problem
is solved by just introducing main.
So Python of meow.py, Enter--
it's solved in the sense that I'm not seeing an error message anymore,
but explain to me, intuitively, why I'm not seeing anything at all?
Yeah?
AUDIENCE: You did not call main.
DAVID J. MALAN: I didn't call main.
So it's sort of like we're taking a step forward but then another step
backwards here in the sense that Python doesn't come with support
for a main function by default. So if you invent it yourself,
the onus is on you to call that function.
So this is going to look a little stupid.
But the convention in Python is, indeed, at the very bottom
of your program, if it's contained in a single file,
is literally call main at the very bottom.
So now I'm going to go back to VS Code.
I'm going to rerun meow.py, and now I get back the functionality,
but I don't get an error message either.
Why?
Well, in this case, on line 1, I'm defining the main function as follows.
On line 6, I'm defining the meow function as follows.
I am not using either of those functions in actuality
until line 10 calls main, which then calls meow.
So I fixed my sort of order of operations, so it's fine for main
to be defined above it so long as I don't actually call meow
until I've defined it as well.
So this defines main, defines meow, and then actually calls main.
So this is a nice way in Python to avoid what could be a very complicated design
problem by just defining our own functions, including one called main.
Strictly speaking, it doesn't even have to be called main,
but it would be frowned upon as a matter of design, as a matter of style,
to call it anything other than main, even though that has
no special meaning beyond convention.
Well, let's make one tweak here, just as in C, just as in Scratch,
it would be nice if meow actually took an argument, which
is the number of times I want to meow.
So let's assume that that functionality exists by calling meow of 3
as the input to that function.
But how do I now change the definition of meow?
Well, just like in C, you put inside of the parentheses
when defining the function a comma separated list of one or more
of 0 or more parameters, and I can call it anything I want.
I'll call it n for number of times.
I don't have to specify int though because we know that already.
But in, now, this loop, I can do for i in range of n--
i doesn't have to be 3.
It can be n as a variable's value.
Then indent this line so that it indeed iterates n times, printing out "meow,"
in this case.
If I run it again as Python of meow.py, Enter, now I see meow, meow meow.
But this is arguably the best designed of my versions
thus far because it is indeed parameterizing
how many times I'm meowing.
Now as an aside, especially those of you who might have used Python before
or might go on and look at tutorials and such for Python
itself as a language, technically the conventional way to call main
is with this weird syntax.
If __name__ equals equals quote unquote "__main__" colon Tab,
we don't bother doing this in most of our class examples because it
doesn't actually solve a problem that we ourselves will encounter,
and it's just really hard to remember and confusing to read.
But you will see this in the wild, in the real world.
And long story short, this syntax of line 10 being added
solves problems where you're implementing not your own program per
se, but your own library, your own library that may
very well have its own main function.
But for now, I'm going to wave my hand and make that go away
and keep it simple because this is the juicy idea for now.
As an aside, there's other ways to have loops in Python that's worth noting.
So, for instance, in Scratch we had this forever block
saying meow again and again and again without ever stopping.
In C, maybe one way to do this was like this, like while true because true
is always true.
So this condition is always true.
So it's just going to print endlessly.
In Python, the syntax is roughly the same,
while True, but capital T and capital F for False,
this too would achieve the same result.
And so just to demonstrate, though, a very common mistake
might be to have some kind of infinite loop in your code
that might happen just the same in Python.
So if I go back to meow.py, and just for kicks,
I simplify this to literally just while capital True colon print quote unquote
"meow," you could get yourself into some trouble here by running that code,
and it just seems to meow endlessly.
How do I get out of this situation besides reloading my browser
and closing the terminal?
What's the more elegant way.
AUDIENCE: [INAUDIBLE]
DAVID J. MALAN: Yeah, Control-C. So Control-C for interrupt
will cancel what's going on there, just like in C. This, though, does not
mean there's an error in your code.
C did not do this.
Python does show a keyboard interrupt error, if you will,
but that's because you literally interrupted
the program while it was running.
This doesn't mean there's a problem in your code.
You've simply interrupted it because you lost control over the thing.
So what are some other issues we can perhaps now revisit together?
So in the world of C, recall that we ran into issues of truncation, whereby
if we did integer math, like 1 divided by 3, that would give me, ideally
in the real world, 0.3333333 forever.
But it ended up coming out as 0 in C as well.
So let's see what happens in the world of Python now.
And I'm going to move away from showing left and right C in Python for now.
Let's go ahead and just focus on the Python code.
So let's try this.
Let me go and create a new program after closing me out up high called,
say, calculator.py again.
Let me throw away the relatively simple code
earlier that simply added two numbers together, and let's
do some division now.
So let's do x equals int, passing in the input, asking for an x-value, like this.
Let's do y equals int input, passing in a y prompt like that.
Then let's do a variable called z equals x divided by y,
and then let's print out z.
So this is actually very similar to something we did weeks ago in C
when we first tripped over this issue.
Let me run Python of calculator.py, type in 1 for x, 3 for y,
and it would seem as though truncation is not an issue in Python.
By simply using the slash symbol for division.
It turns out there's another symbol you can use in Python if you
want to get back truncation.
You can do slash slash, which is not a comment.
It actually means do division, like the way C used to do it.
But in Python, probably for the benefit of all of us
globally, division works as you would expect, and you get back, in fact,
this here value instead.
What about another issue we saw in C?
That a floating point imprecision, whereby
even though something's supposed to be 0.3333333, infinitely many times,
it seemed, remember, like grade school was lying to us
because there were weird numbers in even a fraction like one third.
Well, let's try this out in Python.
Let's go back to my here calculator, and I only
need to make a slight tweak here, for instance, though, the syntax is
going to be a little weird here.
Instead of just printing out z to some default number of significant digits,
let's actually format the string as follows.
And this is not syntax you'll need frequently,
but in Python, you can use an f string by doing f quote unquote something.
And inside the double quotes this time, instead of just doing
z to print out and interpolate the value of z inside of those curly braces,
let's specify that, yes, I Want the value of z,
but I want to print it to, like, 50 decimal places as a floating point
value.
I have to google this syntax all the time to remember what it is,
but this is saying exactly that.
Show me 50 significant digits in this here number.
So let's go back to my terminal, Python of calculator.py, Enter, 1, 3
should get 0.33 repeating forever.
But, of course, we do not.
So, unfortunately, Python does not solve all of our problems.
Floating point in precision is still an issue.
Does that mean you shouldn't use it for scientific computing,
for financial computing and the like?
No, there are libraries that you can use,
third-party code that sort of addresses this kind of concern.
But you still need to be mindful of the fact that these problems still exist,
and either you or someone else still needs to handle something like this.
What about something like integer overflow?
Well, wonderfully in Python, integer overflow is not a thing.
Recall that in C, if you use an int of 32 bits,
it's eventually going to overflow and go negative
or go back to 0 once you count beyond, 2 billion or 4 billion,
depending on if you're doing negatives or not.
You could use a long in C, which gave you
64 bits, which means it's still going to overflow,
but probably after we're all dead because the number is going
to count up much, much, much higher.
Fortunately, in Python, you don't have to worry about int.
You don't have to worry about long.
It will just allocate more and more bits for you automatically, secretly,
underneath the hood so you can just iterate from 0 on up toward infinity,
and the program will run theoretically forever
without ever actually overflowing the int.
So at least integer overflow-- not a problem.
But there are problems that might still happen.
And let's explore how there are new mechanisms in Python
and languages like it that we didn't have in C. So,
in particular, let's introduce something called
exceptions, which is sort of a concept and a feature
that's worth understanding so that you'll
encounter it not only in Python but also likely in the real world.
And let's do it as follows.
Let me go back to VS Code after closing my calculator and let me go ahead
and open up a new program called integer.py just
to play around with integers.
And let me go ahead and do this.
Let me first prompt the user for a number n,
set it equal to the return value of input
by just asking them in between quotes a prompt of input.
Like, I really just want them to type a number, but maybe they won't.
So let's see what happens.
There are ways now to detect if the human has typed in
not only a string but a numeric string, like 1 or 3 or something else.
I can simply use a conditional in Python pretty easily.
In C, I would have to do this pretty much character by character.
By character.
In Python, I can do it the whole string at once.
If n.isnumeric, open paren, close paren, thereby
using a method that comes with all strings in Python that will just
tell me true or false, this whole thing is numeric or not,
then I can go ahead and print out, for instance, integer, just concluding
that this here thing is an integer.
Else, if it is not all numeric, I'm going to go ahead and print out "not
integer," quote unquote.
Let's try this out.
Let me run Python of integer.py.
I'll type in one.
That's an integer.
Let's run it again, type in 3, that's an integer.
Let's run it again, type in cat, that is not an integer.
So it seems to work at a glance.
But how else might we go about doing this, especially if--
so that we don't have to litter our code with all of these darn conditionals
every time I'm just trying to get an int?
I don't want to resort to the CS50 library.
Ideally, I don't want training wheels.
But I want to do this the Python way, and there's a word for that--
the "Pythonic" way.
So that too is a term of art, which means
there might be different ways to do it, but do it the way
where a majority of people out there would probably
agree with you Pythonically.
So let's do this.
Instead of bothering with the conditional,
because this is kind of annoying that one line of code
really becomes four all of a sudden, let's just go ahead and proactively
convert what the human types in to an int,
as I did before, to fix the 12 problem.
Let's run Python of integer.py, Enter.
Let's do 1, Enter--
seems to not make any errors.
Nothing bad happened.
Let's type in 3.
That there works, too.
Let's type in cat, and that throws one of those tracebacks, where the traceback
itself is not the error, but it's diagnostic information
that's trying to help me figure out where I screwed up.
Apparently, I screwed up somewhere in this whole thing,
and this is a little cryptic, but this is a value error, something--
I screwed up a value here.
Invalid literal for int with base 10 "cat."
So that's a very verbose way of saying, by default, the int function
assumes base 10, a.k.a. decimal, and it doesn't understand cat,
so it's just not working on cat.
So how do I solve this?
Well, notice what's happening here.
Simply trying to convert cat to an integer
is not just returning some special value, like 0 or negative 1.
Like, it's literally terminating my whole program.
And this is different from C. Recall that, in C,
the only way you could signal errors that we've seen
is that you have to return a sentinel value, like 0 or negative 1
or positive 1 or null or whatever.
You have to know in advance what special value is going to come back.
But there's a problem with integers in particular.
Suppose that the int function was defined in its documentation
as printing out-- as returning 0 if anything goes wrong.
You could check for 0.
So if n equals equals 0, then you could say print not
integer because, according to the documentation I'm pretending exists,
that is an invalid value.
Of course, where does this get me into trouble if I run Python of integer.py?
Type in 1.
We're good.
Type in 2, we're good.
Type in 0--
0 is not an integer, but I'm pretty sure it is.
So there's a problem whereby if you're relying on return values
to signal that something went wrong, you have
to sacrifice a potentially valid value.
And that's fine, but you're going to have to pick a number.
It's got to return 0, negative 1, positive 1, 4 billion,
negative 4 billion-- like, you've got to pick a lane.
And that's unfortunate because you're sacrificing some value unnecessarily.
So what Python does and what other languages
do is instead of returning some sentinel value that means something went wrong,
they just throw up their hands, so to speak.
They throw an exception.
And an exception, by default, just terminates the program
because something unexpected happens, something exceptional where,
in this case, exceptional is a bad thing.
Something exceptional happened.
So how can we handle this?
How can we actually detect that something has gone wrong?
Well, it turns out-- this is sort of encouraging--
you can try to do something instead in Python as opposed
to just blindly doing it.
So if I go back into VS Code here and I try to do that, let's do the following.
Ideally, I want the end result to look like this-- print integer
if this thing works.
And so, to be clear, let me run this once more.
Python of integer.py, 1 is an integer, 2 is an integer, cat--
not an integer.
But I'd like to see not integer, and not some crazy message on the screen.
So how can I fix this?
Well, let's do this instead.
Please try to do all of this, except if there's a value error,
as I know can happen because I just experienced it,
then go ahead and print out "not integer," quote unquote.
So let me just keep my grammar the same.
Python of integer.py, Enter--
1 works.
Python of integer.py-- 3 works Python of integer.py-- cat doesn't work per se,
but it doesn't throw an error message anymore and that scary traceback.
I'm somehow catching the exception or handling the exception, so to speak.
Now, as an aside, the slightly better way to do this would also be as follows.
Generally speaking, it's considered a bit lazy and bad design
to put more lines of code in a try statement
than you strictly need because imagine a program has 30 lines of code.
Maybe it's your whole Pset problem, and you
know you're occasionally getting those traceback errors on the screen.
A bad student, for instance, would just put everything in the try block
and literally just try to do your homework.
And if there's an exception, then you just catch it at the very bottom.
That's frowned upon because there's just bad design.
When you're trying to do something, you should really
only wrap the one or more lines that will actually
raise an exception inside of it.
So, technically, print is not going to fail.
You can't screw up print when you're just printing out, quote unquote,
"integer."
So, weirdly, the try accept statement in Python
also supports an else whereby if there's not an exception,
you can then do this statement instead.
It's a little weird because we've only seen elses and conditionals.
But you'll see this in the real world.
This, though, would achieve the exact same thing.
But it's a little better because now the only line of code I'm wrapping
is the one that can actually raise this exception in the first place.
So Python of integer.py--
1 works.
3 works.
Wait a minute.
Oh, wait, that's completely logical--
it does not work.
This is supposed to say integer if it is not, in fact,
an exception-- sorry, user error.
Python of integer.py-- 1 works.
3 works.
Cat is caught but therefore not an integer in this case.
So long story short, why do we introduce this?
Well, one, these exceptions are actually omnipresent in higher level languages,
and this is the way that many languages actually
raise exceptions to signal that error has happened as opposed
to reserving arbitrarily some special return value that you must check for.
But you need to now try to do certain things, except if errors happen,
in which case you can catch them, so to speak, in this way.
As an aside, how does CS50's get_int function in our library work?
We essentially are using try and accept inside
of a loop that just keeps prompting and prompting and prompting
the user for an actual integer until you oblige,
and then we return that value in CS50's Python version of get_int.
So we're using the same fundamental in there.
Let's try now a few familiar things here on stage in homage to the Python
crawling on Mario's bricks here.
So recall that, a few weeks ago, we played around with something
super simple like this in C, which wasn't syntactically as simple,
but the idea was to print out a column of for instance, three bricks.
How might I go about doing this in code?
Well, let's see.
Let me open up a new file called mario.py today.
And let's just do it the simplest way possible.
If I want to print three bricks, I could do for i in range of 3,
and then I could print out a single hash mark to represent exactly that.
I'm going to get the new line for free because that's the automatic default
behavior for print.
So if I run this, I get something that's a little underwhelming but pretty close
to the spirit of what I just did here on the screen.
What if, though, I want to prompt the user for the height of this thing,
just as we did in problem set 1 with the Mario problems?
How can I make sure the user actually gives me a number I want?
Well, let's go back to VS Code here, and just so that I don't have to implement
all the try-except stuff myself, let's go ahead and, from CS50 library,
import the get_int function that I've claimed exists, and then let's do this--
while True.
It turns out, in Python especially, it's actually pretty common
to deliberately induce infinite loops if only because Python does not
have do-while loops.
Recall that do-while loops and C were super useful
because they guarantee that you do something
while a condition is still true.
And that allowed us to get user input at least once and maybe again and again
and again and again.
Python does not have a do-while.
But you can implement the idea of it by just
saying start an infinite loop that I'm going to plan
to break out of when I am ready.
And I can do something like this-- n equals get_int, prompting
the user for height here as a prompt.
Then, if n is what I want it to be, a value greater than 0 as in problem
set 1, go ahead and break out of this loop.
So even though I don't have a do-while, I
can certainly deliberately get myself into an infinite loop
and break out of it when I'm logically ready to do so.
And now, here, I can do for i in range of n,
which is just going to iterate from 0 on up to that value
and then print out a hash mark as follows.
Let me go ahead and run Python of mario.py, type in a height of 3,
and it still works.
Type in a height of, say, 5--
it too works by iterating five times instead of three.
As an aside, what are some modifications that might be germane here?
Well, if I want to import the entirety of CS50 library,
I can indeed, as I said earlier, just import the library itself.
But notice what happens now.
Python of mario.py, Enter--
a traceback, specifically a name error, get_int is not defined.
This is because Python actually solves a problem that C does not.
In C, we didn't actually encounter this because our programs
haven't been too big.
But in C, if you include this library and this one and this one and this one,
you will get into trouble if two people out there
have named a function the same thing.
If they've typed up something the same thing-- there's no notion of scope
when it comes to importing libraries in C. You will get name collisions,
and the solution is just don't do that.
Don't use that library that conflicts with one you're using.
Humans realized, eventually, this is probably not the best design,
so they introduced the notion of namespacing,
whereby you can scope certain symbols to specific files in effect.
And so there is a solution to this.
If you import the entirety of CS50, that's fine.
But you have to say that you want the function called get_int
that's inside of the CS50 library.
So if I do cs50.get_int and rerun this, now I no longer see that error,
and I'm on my way again with the code.
And this just allows me to keep all of my
get underscore something functions scoped to the CS50 symbol
as opposed to importing them all into the top-level namespace, where they're
just essentially global instead.
Questions about this-- the new ideas here
really being now infinitely looping, deliberately,
until you're ready to break out.

No-- seeing none.
All right, how about this.
So we had these four coins, question marks in the sky here,
different in that they were horizontal instead of vertical.
How we might implement this in code instead?
Well, let's go back to mario.py.
Let's delete the vertical version we just did,
and there's a bunch of ways I can do this.
But let's do it in a way that lets us play
around with some new features of Python as well.
For i in range of, let's say, 4--
though I could use a variable if I want--
print out quote unquote question mark, and let's try this.
Python of mario.py, Enter--
this is, of course, buggy because they're coming out
vertical instead of horizontal.
So what's the fix there, intuitively?
What do I-- yeah?
AUDIENCE: Add end equals--
DAVID J. MALAN: Yeah, so add end equals quote unquote
to turn off the new line by default. That's close now,
so if I run mario.py again, I get 4 horizontally,
but I don't get the prompt on the new line.
So I think I just need one extra print at the end, which
does give me a default new line.
So if I now run this one more time--
there we go.
Now we're back in business.
So pretty straightforward-- pretty much the same as in C,
albeit with Python's more succinct syntax.
But this is kind of cool.
What you can alternatively do in Python, which we've not seen before,
if you want to print something four times or some number of times,
you can literally say print out a question mark four times.
So multiplication is now used in the way that plus kind of is for concatenation.
But this does something again and again.
Python of mario.py, and that too now works.
Doesn't really save us a huge amount of time,
but it's kind of cool now that you can do these one liners, so to speak,
that achieve a lot more functionality as well.
What about this final example we had from the world
of Mario Underground, which was a 3 by 3 grid?
How could I do this in Python instead?
Well, let's go back here and delete the version of code I had there.
Just like in C, we can have nested loops,
so I could do something like for i in range of 3 and then maybe for j
in range of 3, using different variables deliberately here.
Let me go ahead and print out a hash mark
with no line ending until we're at the end of that row, at which point
I do want a line ending, the new line character there.
So if I run Python of mario.py, I get a 3
by 3 grid, which roughly resembles what this thing here looks like.
Now you don't strictly need all of that because we can combine
these ideas for better or for worse.
If I go back to my code here, well, if I want to just print out three things,
I could just do-- let's see, print quote unquote hash mark times 3
and allow me to have a new line there.
And if I run this version, which is a little tighter,
I get the same exact thing, too.
So where is the line?
Which way do you do it?
Whatever is most comfortable to you.
And, in fact, when I said earlier that I was
doing-- kind of flexing when I implemented dictionary.py using
the fewest lines of code possible, that was just because I really
wanted to distill it into the essence of the minimal number of lines of code.
But I could absolutely have used some loops in dictionary.py.
I could have used a little more verboseness.
But, as we're seeing here, it's not strictly necessary.
Python has even more syntactic sugar, if you will,
that lets you achieve more stuff more succinctly.

How about, now, some more on lists and dictionaries, just to dovetail
with what we did last week.
We'll touch on some final features, too, when it comes to command line arguments
and using exit commands.
And then we'll end with a couple of fun examples that kind of ties
this all together.
So, in Python, we indeed have lists, which are like arrays,
but they dynamically resize themselves.
So they're effectively linked lists that you don't need to manage yourself.
It turns out the documentation for those are at this URL here,
but that's discoverable via docs.python.org itself.
In particular, there's functions you can use on lists like len,
L-E-N, for short, which gives you the length of a list.
In C, it was up to you to keep track of the length of an array.
In Python-- like in Java, like in JavaScript, if you're familiar--
you can just ask the list how long it is at any moment in time.
So that's going to make our lives a little easier as well.
In particular, here's some documentation for that length function,
and let me take it out for a spin by recreating some of our prior examples
in code.
Let me go back to VS Code here, and let me go ahead
and create a program called scores.py, which, just like our example in week 2,
sort of iterates over quiz scores or homework scores or however
you want to think about scores.
In Python, I'm going to give myself just a list
of three scores, same as in week 2.
So scores equals square brackets 72, 73, 33.
So this is different from C. In C, if you were initializing
an array with values like these, you would actually
use curly braces and a semicolon.
And the data type in Python, you use square brackets, no data type,
no semicolon, as before.
Now let's compute the average of my score.
So average equals-- and here's another function that actually
exists in Python's documentation.
You can actually call a function called sum pass.
In most anything that you can iterate over, like a list,
passing in scores, and then divide by how many of those things
there are, like len, passing in scores there.
And now, if I want to print out the average,
I can print out, for instance, a format string that says average, colon,
and then plugs in that value there.
I can try running this Python of scores.py,
and there's my average as we've seen before, weeks ago, 59.33333
with a little bit of imprecision thrown in for good measure, as before.
But what's nice is that, notice, sum just comes with the language.
Length just comes with the language.
You don't need some annoying for loop or a while
loop just to figure out the average of these values by doing all of that math
yourself.
So that seems to be nice, at a glance.
What else can we do with these here scores?
Well, let me propose that we could get them one at a time from the user
instead of hard coding them.
So let me do this.
Let me go ahead and, from CS50's library,
import get_int, just so I don't throw any of those exceptions
by typing in cat or dog or anything not an integer.
Let's give myself an empty list by just using two square brackets, like that.
And now let's go ahead and put things in that list as follows.
For i in range of 3, if I want to prompt the user still
for three scores for the sake of discussion,
let's prompt the user for a score, putting it in a variable called score,
setting it equal to the get_int function,
prompting them for their first score.
But then let's put that score in the list.
In C, this was a pain in the neck.
In C, this was like what you had to do in problem set 5
and build the darn linked list yourself by iterating over the chains
and appending it to the end or to the beginning or something like that.
In Python, if you want to append a value to an existing list,
you do whatever that list is called, scores in this case.
You use a method that comes with it called append,
and you append that score, and voila, Python takes care of it for you,
putting it at the end of the list.
Now, outside of that loop, let me calculate the average, just as before,
the sum of those scores divided by the length of those scores.
Then let's go ahead and print out an f string that says average, colon,
and then interpolates the value of that variable.
Now, if I didn't screw up, let's try this again.
Python of scores.py--
72, 73, 33, which are now, per that for loop, being added to the list.
And then the logic is exactly the same.
So way easier than it would have been in C to navigate or manage
all of that stuff for me.
There's another way to see this syntactic sugar, if you will.
If you don't like this syntax, whereby you are adding to the scores
variable a new score by appending it using the built-in append function
or method that comes with any list in Python, you can also do this.
You can set scores equal to the existing scores
list plus another mini list containing just that score.
Or I can condense this a little further and say plus equals score.
So it turns out, plus is overloaded in Python in the sense
that it's not a concatenation per se, like for strings, but it's append.
You can append more and more things to a list
by concatenating two lists together in this way.
So, again, it seems the exact same thing,
but maybe you prefer the syntax if only because it's a little more concise.
But, in short, lists are wonderfully useful in this way.
Questions, then, on this here feature as well?
We're essentially just solving past problems more easily is the theme,
hopefully.
How about one other problem, when we implemented a phone book back in week 3?
Let me go ahead and do this.
In VS Code, let me clear my terminal and close out scores.py, and let me go ahead
and create a new program called phonebook.py.
And, in this, let's write a program that just iterates over some names,
looking for one that I want.
So maybe I have an array, a list called names, set it equal to 3 of us,
as in week 3, so Yuliia and David and maybe John Harvard, like this, all three
strings.
Then let's go ahead and prompt the user for a specific name using Python's input
function or our get_string function, prompting them for a specific name.
And now let's do this old school with a for loop for each name in names.
And I'm just keeping it short--
n for each name.

If the name I'm looking for equals the current name that I'm iterating over,
then print out "Found," as we did weeks ago,
and then break out of this loop because I'm done,
and let's see what happens here.
So Python of phonebook.py-- let's search for my own name, D-A-V-I-D, Enter,
and David's name is found.
So that's kind of handy.
Let's do this once more, search for John.
John is now found.
Let's search for, say, another name.
But let me mistype it, maybe like YULIIA in all caps.
I'm not handling any of the capitalization here,
so I don't think she will be found.
And, indeed, we see no mention of found.
Now this is a feature of Python that's kind of handy, too.
And it's a little weird because, in C and in Scratch,
the only time you could use else was with conditionals.
But we've seen in Python, you can also use else with exceptions,
those special errors that can be triggered. .
You can even use elses in Python with for loops by saying else print "Not
found."
And what happens in Python is if Python realizes you never actually break out
of this loop yourself, it will then print out this
only if you've not broken out, the logic being that,
OK, you clearly didn't find who you were looking for,
so else let's just say as much.
So if I now run this again, typing in Julia's name all capitalized--
so miscapitalized here--
Enter, I do now see that she's not found.
So it's just a nice little trick because it's
so common to iterate through things, fail to find a value,
and then you just want to say some default--
you want to execute some default line of code as well.
But, turns out, let's tighten this up too.
Python does not need you to do all of this work
by iterating over every name in the list, checking if each name is in there.
Rather, we can tighten this up even more.
Let me get rid of this entire for loop and just say this.
If the name you're looking for is in the list of names, then print "Found."
Else, in this conditional, print "Not found."
In other words, I can literally just ask Python,
you search over the darn list for me, and if it's in there, wherever it is,
return True in that Boolean expression--
in that if conditional, the Boolean expression in effect,
so I can print out "Found" or "Not found."
So this, too, will just work.
Let me go ahead and run this again at the bottom.
Python of phonebook.py, search for myself, David, and I am indeed found.
But I don't need to implement the searching for it left to right.
It's still using linear search under the hood,
but someone else has now written that code for me, built into the language
itself.
So what more do we get?
So it turns out that, in the world of programming,
maybe the most useful, one of the most useful data structures
is indeed a hash table, which gave us the abstract data type last time
known as a dictionary, which is just a set of key value pairs.
What's wonderful about Python, unlike Pset 5 in C,
is that you actually get a data type called dict, short for dictionary,
which gives you exactly that-- key value pairs,
but you don't have to implement any of the darn logic of problem set 5.
It still gives you, in effect, something that
looks a little something like this in memory--
key value, key value, key value.
But you don't have to worry about the array.
You don't have to worry about the chains of linked lists.
You don't have to worry about the hash function, even.
Python takes care of all of that for you.
Now this will be a bit of a mouthful to set up, but let me go ahead and do this.
Back in VS Code, I'm going to go ahead and create
another version of phonebook.py here by first creating
a dictionary of people instead of just a list because, up until now,
we've had no phone numbers involved.
I do actually want to have a bunch of names and phone numbers.
And the way I'm going to do this is as follows.
At the top of this file, I'm going to go ahead and create a list called people.
Rather, I'm going to create a list called people.
And a list, of course, uses square brackets.
But every person now I want to have some keys
and values, like a name and a number.
So how can I do this?
Well, I'm going to make some room for this.
This is not incorrect.
I'm moving this closed square bracket to a new line
because I want every element of this list to be very clearly
a dictionary, a set of key value pairs.
And you couldn't do this in C, but you can do this in Python.
In Python, you can use curly braces to represent
a dictionary of key value pairs.
How do you define the keys?
You put the first key in quotes.
You then put a colon, and then you specify the value for that key.
If you want another one, you do a comma, you then do quotes,
and you do another key, colon, and then its value.
And if I think back to week 3, we used plus 1-617-495-1000 for Yuliia's number
then.
And that's it.
It's a little cryptic because it's all in just one line,
but it's like having two rows in this visualization here--
name, Julia, number, plus 1-617-495-1000 in that there chart.
So if I want a second one of these, I'm going
to put a comma at the end of Yuliia's dictionary.
I'm going to put myself on the second line.
So open curly brace, quote unquote, name, colon, and then David in quotes,
then comma, number, close quote, colon, plus 1-617-495-1000 as well, and then,
lastly, a second comma, so that we'll put John Harvard in here so his name is
quote unquote "John."
His number is +1-949-468-2750.
And now we have a list of three dictionaries.
Each of those dictionaries has two keys and two values, respectively.
Syntactically, this is a pain in the neck,
and we would probably just store all of this information in a CSV
or a database or something like that.
But for now, I typed it all up manually so we have a working example.
Now let's actually search this list of dictionaries for the people I want.
Let's set a variable called name equal to the return value of input,
prompting, as before, the name we care about.
Then let's do this for each person in that list of people,
let's check if the current person's name equals equals the name the user typed
in, then get their number by looking at that person's number field and then go
ahead and print out with an f string something like "Found."
And then I'll just print out that number in curly braces,
and then I will break out of all of this.
Or, as before, else let's go ahead and print out "Not found."
So this is a mouthful, but let's consider what's happening here.
First, on line 8, I'm iterating over every person in people.
What is people?
It is a list of three dictionaries.
So on the first iteration is this person, second iteration, this person,
third iteration, this person.
And Python just takes care of that for me, like we've seen with our for loops
already.
If that person's name field has this name,
then I found the person I'm looking for-- get their number stored
in a variable called number if only so that I can print it out
with this f string.
Else, let's go ahead and print out "Not found"
if I never actually break out having found someone.
Notice, then, that just like in C, when we use square brackets to index
into an array, in Python, you can index into a dictionary
by literally using the same square bracket notation.
So instead of saying bracket 0, bracket 1, bracket 2,
you can say bracket name, quote unquote, and that
will look up the value for that key.
So, again, it's like going into this chart that we see here visually,
looking for name in the left column, finding that person's name,
looking for the number value in the left column,
and looking for its corresponding value at right.
It's all sort of happening for us automatically.
Now It turns out we can do this more simply if we, instead,
restructure our variable called people.
So let me go ahead and do this.
Let me go ahead and delete all of the code we just wrote,
including that for loop.
And let me redefine people as follows.
And I'm going to leave the first version up there so we can see before and after.
Let's redefine this variable as equaling people,
but instead of people being a list of dictionaries, let's just make people
one big dictionary, whereby it has two columns, key and value,
but where the key this time is going to be the person's name
and the value is going to be their number.
This is super useful in this case because I only have
keys and values, names and numbers.
This will not work if I also want to keep
track of their email address, their student ID, and multiple values as well.
In this case, it suffices to keep track of names and numbers,
if only so that I can remove some of this redundancy of saying name, name,
name, number, number, number.
Let's do it as follows.
So people equals open curly brace, close curly brace,
and let's add a key of Yuliia, whose number is exactly this one here.
I'll copy-paste to save time.
Let's add another key whose name is David whose
value happens to be the same number.
Let's add a third key whose value is John
and set that equal to this number so that
now, at the end of these lines of code, we have Yuliia as a key,
David as a key., John as a key, and their numbers
respectively as values effectively implementing
this chart for everyone instead of one of these charts for each person.
So if I go back to VS Code, let's get rid of the old, more verbose version.
Let's go back here and, instead of using any kind of loop
now, because there's no list involved, let's just
do this-- prompt the user using the input function
for the name whose number they want.
Then let's just say if the name you're looking for
is in that people dictionary, well, great.
Go ahead and print out a format string that
says that person's number is whatever is in the people dictionary at that name's
location.
Else let's go ahead and print out, for instance, "Not found."
So the only weird thing here, I dare say, is this--
if naming people works just like searching a list,
but you can search a dictionary by key, and if you
find a key like Julia or David or John, it's
going to allow you to use people as well indexed into that chart
at the name location with the appropriate row,
and that's going to give us implicitly that person's number
because even though we don't mention name, we don't mention number,
this is what a dictionary is, a collection of key value pairs.
And the key can be any string you want, and the value
can be anything you want as well.
So that was a lot.
But you'll see, then, in the real world, these dictionaries,
really, these hash tables underneath the hood
are so useful because you can constantly associate one thing with another.
Questions on any of this to date?
OK, a few final examples--
I feel like it's a tough crowd because we're
teaching an entire language in a week.
But we're almost at the finish line here,
and then everything else is going to be icing on the cake.
How do we go about implementing now from, in Python, some of the features
we eventually introduced in C, namely things
like command line arguments, which we've not used thus far in Python.
I've gotten all of my input using get_int, get_string,
and Python's own input function, but I've
never typed any words after the prompt when
running Python and the name of a file.
Well, how can I go about doing this in Python?
Well, let me open up my terminal window here.
Let's open up a program like greet.py, reminiscent of week 2's greet.c program,
and let's do this.
From a feature of Python called sys, import argv,
which is very different from C, but the same idea at the end of the day.
If the length of that argv variable happens to equal 2,
let's go ahead and print out a format string that says "hello,
comma argv bracket 1," close quote.
Else, go ahead and print out the default from week 2, which was just "Hello,
world."
All right, what has just happened?
Well, first, let's run it and try to infer.
So.
Python of greet.py, Enter--
I didn't write any other words after the prompt, so I literally see the default,
"Hello, world."
What if, though, I write Python of greet.py and then David?
Well, what's going to happen here is Python, via this sys library,
is going to automatically put every word I typed at the prompt after the name
Python into a list called argv by convention.
By definition, I can then check how many words are in argv,
and if it's 2, that means that the human typed in not only the name of the file
to execute but also something after that as well.
So if I now run this by hitting Enter, now I see "Hello, David,"
because there's two things in that list, greet.py and David.
There's no mention of Python because that's the interpreter.
And without the interpreter, none of this would work anyway.
You get the name of the file and the word you typed after that.
It's not going to work, though, just like in week
2, if I do David Malan because now, argv's length will be 3 instead of 2,
so I'm again going to get the default. But this is to say there is still argv.
There's no argc because you can just use the length function, len, to find out
what the length of argv now is.
What more can we now do?
Well, let me go ahead and propose that we introduce how about exit statuses
as well, whereby recall that, in C, we had the ability
to actually exit with some value, like 0 on success or 1 or anything else
upon failure.
Turns out that that feature is also tucked away inside of this sys library.
Let me go ahead and create another program called, say, exit.py,
just to demonstrate this one, let me go ahead
and import sys so as to have access not only to argv
but also a function in there called exit, which just worked in C,
but in Python, we'll see that we want to use the version tucked away in sys.
Let's do something like this.
After importing sys, let's check if the length of argv does not equal two
things, let's go ahead and yell at the user quote unquote "Missing command-line
argument."
And we didn't spend long on this in C, but we did something
like this a few weeks back.
And then let's go ahead and call exit of 1.
Otherwise, if we get down here, let's go ahead and say,
as always, a format string of Hello comma sys.argv bracket 1,
just as before, so as to greet the user, and then we'll say exit(0).
But I do want to use argv that's inside of sys
and I want to use exit that's inside of sys because, according
to the documentation, that's where these symbols are.
So I can now do sys.argv, and I can do sys.exit and sys.exit, which
just makes super clear that those two symbols, argv and exit,
are inside of that sys library.
And we did this earlier when I played around with the CS50 library.
Either importing specific things or the whole library itself,
the idea here is ultimately the same.
So let me run Python of exit.py with no command line argument, so Enter,
and I indeed get an error message.
And this is probably not something you've
needed to run since I last did it.
But if you do dollar sign question mark after echo,
you can quickly see what was the actual secret exit status.
If I run this again with my actual name, David, Enter, I actually get greeted.
And if I do that dollar sign question mark again after echo,
I see now the secret exit status.
So, again, not something we've used often,
but by convention-- we can still do in Python what we've been doing in C,
namely signaling that something was successful or a failure.
Let's do one last set of examples that are reminiscent of past ones,
and we'll conclude with two new ones altogether.
Recall that we've had this phone book that previously took input just
from a hardcoded list of dictionaries or one dictionary.
Let's actually reintroduce the idea of CSV files, comma-separated values,
whereby we can actually save this information to disk so
that we can add and add and add and, heck, even remove
names and numbers eventually.
In Python, one of the things that's wonderful
is that you have built in support for CSV files.
You don't have to worry about the commas, the quotes, or anything
like that, as follows.
So let me run code of phonebook.py to reopen that same file from earlier.
But let's delete everything therein and let me now do this.
Let me import Python's own CSV library, which is against comma-separated values,
and we used this briefly for my last phonebook a few weeks back.
Let's now open a file using the open function that
comes with Python it turns out, opening a file
called phonebook.csv in append mode so we can add to it as we
did done in the past line by line.
Let me then go ahead and ask the user for a name using input,
and then let's ask the user for a number using input.
And then let's actually put those that name and number into the file.
How can I do this in Python?
And, again, the goal here is not to absorb
exactly how to do this in Python-- it's certainly reasonable to look this up--
but just to show you how relatively easy it is.
I'm going to create a variable called writer.
So we could call it anything I want.
And I'm going to set that equal to the CSV library's writer
function that just comes with it, and I'm
going to pass to it the name of that file.
This is a feature that says open this file
and be ready to write to it hereafter.
How do I do that?
I can do writer.writerow, and I can pass in a list
of the things I want to write to it.
So I can say name comma number in square brackets,
so that prints out a new line to the file.
And then at the very end of this, let's do file.close to close the whole thing.
Now let's see what just happened.
Let me go ahead and open up phonebook.csv, Enter, which is empty
initially because nothing's in there.
Let me show it at write continually.
Let me now run Python of phonebook.py, Enter, and let's do Yuliia's name--
Yuliia, Enter, and then her number, plus 1-617-495-1000,
and watch what happens at top right when I hit Enter because that row will be
written.
All right, she's now in the file.
Let me run it once more with my name, and plus 1-617-495-1000, Enter,
and now I am written to that file.
And if I want to do this for John Harvard or anyone else,
I can do that, then, as well.
So what's nice is that notice that the writerow function is actually
outputting the commas for me.
And if there were weird characters or commas,
it would actually escape them by using quotes as well.
As with Python in general, I can tighten this up further.
In fact, it turns out that, in Python, you
don't need to be so pedantic as to open the file, then do some stuff,
then close the file.
There's this weird other preposition in Python, namely width,
that allows you to do multiple things at once.
So let me do this.
Let me get rid of the close line and let me instead do this--
with open as file colon, and then let me indent all of this here.
That now is going to have the effect of actually doing all of that
but automatically closing the file for me
so I don't run the risk of forgetting, maybe leaking some memory somehow,
and so forth.
And there's one final flourish I can do here, too.
Right now, I'm using this basic writer function which essentially just writes
a list, writes a list, writes a list.
There's one other way where I can write dictionary after dictionary
after dictionary, which is handy, especially
if I don't just have names and numbers, but maybe email addresses and student
ID numbers and other types of values as well.
And I can do it as follows.
Let me go ahead and let me say--
oops, and, actually, just to be clear, this code can be outside of that width
because I can ask for this once without the file actually being opened yet.
So let's change just these two lines here.
I can create a writer, but this time use a dictionary writer,
which allows me, again, to write dictionaries-- key value pairs instead
of just lists of values lists.
I can say use this file for my dictionaries.
Let's use field names of quote unquote name comma number,
and then let's go ahead after that and do writer dot write row.
And I can now pass in any dictionary I want that I want written to that file.
So I can do name colon name and then, for instance, number colon number.
And let me go ahead and reopen phonebook.csv, Enter.
Let me move it right here.
Let me delete all of that.
And notice what happens this time.
More like your real world of using Excel and Google Sheets and Apple Numbers,
notice now, when I run Python of phonebook.py, Enter,
and I type in Yuliia and plus 1-617-495-1000, Enter, notice that it,
too, works as well.
And if I wanted to, as well, using a dictionary writer,
I could additionally tell this writer to include the names of these columns
in that file so that when I open it up in Excel or Apple Numbers or Google
Sheets, also, the data is described in that first row of headers
that you're probably familiar with from having just
used spreadsheets in the real world.
So, long story short, this is not to ingrain in you exactly how you
read and write CSVs or write in this case,
but rather, with just a few lines of code, like six lines of code,
you can do a lot more in Python than you can in C.
So now to end on a lighter note, let's do this.
It turns out, in Python, there's not only all
of these libraries that come with the language,
but there's also third-party ones that you can install as well.
And there's a program you can run in a Linux environment,
like your own code space, called pip, which
allows you to install additional packages-- that is to say,
third-party libraries that other people have written.
What this means is that, in advance, of your using cs50.dev,
we essentially ran pip install cs50 to make sure that, by default,
you just have access to CS50's own library.
It does not come with Python, but it's out there in the cloud somewhere,
and pip knows how to install it.
But suppose I want to do something fun, like from a few weeks
back, where we did cowsay, and we had a cow moo on the screen.
And we had a dragon and other things too.
Well, it turns out there's a package called cowsay
that I can install for Python with pip install cowsay, Enter.
You'll see on the screen a bunch of stuff happening
because it's downloading it, and it's installing it
into the appropriate location.
But now this means there is a library called cowsay in my own code space.
So if I go ahead and create a program called, like, moo.py in this file,
I can now import cowsay, which will give me access
to any functions and symbols therein.
And I can do something like this per its documentation-- cowsay library dot cow,
because this is going to print a cow on the screen,
and I can say "This is CS50."
And down here, I can do Python of moo.py,
Enter-- oh, let's make the terminal window bigger.
Let's do this again--
Python of moo.py, Enter, and I get a cow saying, "This is CS50"
in a little speech bubble, like that.
I can make it more interesting now in code, though, as follows.
If I shrink my terminal window and I use something like Python's input function,
I can ask the user for their name, like, what's
your name, as we did way back with Scratch and then C.
And then I can use one of these f strings in here.
And instead of saying, "This is CS50," I can say something like, "Hello, name"
in curly braces.
Then, down here, I'll make my terminal window bigger.
Run Python of moo.py, Enter--
what's my name?
David, Enter-- and now the cow is mooing dynamically
based on what I've just actually typed in.
We can do things even fancier than this.
Lastly, let me see if I can type this out correctly.
In my terminal window, let me go ahead and install
pip install qrcode, these two-dimensional bar codes nowadays
that are seemingly everywhere.
This is going to install a library that's going to know how
to automatically create a 2D bar code for me based on any text that I give it,
including a URL, because someone else wrote the code that figured out how
to do all of that and output a two-dimensional code.
So let me go into a program called qr.py that I myself will write,
but I'm going to stand on that person's shoulders
and I'm going to import a Python OS library, which gives me access
to the file system so I can read and write files,
and I'm going to import that person's library, qrcode.
I'm going to now create a variable called
image, set it equal to qrcode.make, because I want to make a QR code,
and I'm going to type in the URL of one of CS50's lectures,
so https://youtu.be/xvFZjo5PgG0, and, hopefully,
I made no typographical errors there.
Then, on my next line, I'm going to call image, which
is the name of that variable, dot save.
I'm going to save this as a file called qr.png.
Turns out, this library supports different file formats, like PNG,
for Portable Network Graphics.
So I'm going to say, give me that type of file.
Then I'm going to go ahead and run this program as follows, Python of qr.py,
Enter--
no errors.
I'm going to now open up qr.png, Enter, hide my terminal window,
give you all a chance to open your phone,
and open the URL that's secretly embedded in this QR code,
and at the risk of incurring your ire--
there we go-- this was CS50.
We'll see you next time.
[APPLAUSE]
