[THEME MUSIC]

DAVID J. MALAN: All right, this is CS50.
And this is week 2 our third together.
Last week, of course, we introduced C on the heels of Scratch.
And it might have indeed felt like things escalated quickly.
But that's really because there was a lot of new syntax,
especially if you've never programmed before.
But keep in mind, that vis-a-vis what we did in week 0, there
weren't that many new ideas.
Last week, we just translated them literally to another language.
There were still functions and loops and conditionals
and variables and things like that, even though the syntax
was, and will remain for some time until you get ample practice under your belt,
quite different.
Now, today, what we're going to do is try
to take some of the magic out of what we did last week.
So even though it might have seemed complicated,
there was some sort of magic.
Somehow, you write some code.
You literally type make and then Enter, and a program somehow
gets made, assuming there's no errors within the code.
Well, today we'll take the hood off of that process,
give you a better sense of what's going on, because at the end of the day,
and by the end of the course, there really won't be any surprises.
And even if you won't feel an expert at every little detail,
you'll at least have this bottom up understanding of what's going on,
so that once you're out of this class and in the real world,
and maybe dabbling or doing full-time programming,
you'll have a much better technique and mindset for actually solving
real-world problems.
So in fact, one of the real world problems
we thought we'd begin with today is a specific domain
like this, like reading levels.
So if you look at a block of text, at what reading level is someone reading?
Is it maybe kindergarten, first grade, middle school, high school, or the like?
There's certainly a range there.
And while all of us might have an instinct for what
makes something easy to read versus harder to read,
we'll see this week if we can't quantify that a little bit.
And I thought we'd do this by way of some examples.
In fact, if we could give us some mood lighting here,
we'll introduce three of our volunteers, who stood up early in class.
If you'd like to each say hello.
STUDENT: Hello.
I'm Eric.
I'm from Philadelphia.
And I'm in Hollis Hall.
STUDENT: Hi.
I'm Elizabeth.
I'm from Baltimore.
And I'm also in Hollis Hall.
DAVID J. MALAN: But no one else seems to be from Hollis Hall this year.
OK
STUDENT: I'm Jesse.
I'm from South Florida.
And I'm in Canaday.
[CHEERING]
DAVID J. MALAN: Wow--
all Canaday.
All right, so the first exercise we thought we'd do is,
have Eric open the envelope that he has in front of him, inside
of which is a reading snippet from a book with which many of you
might be familiar.
And we'll ask Eric to read this aloud, and then we'll
ask you at what level Eric seems to read.
He's turning on the POV glasses.
We'll give you the microphone and read away.
STUDENT: "One fish, two fish, red fish, blue fish."
DAVID J. MALAN: Wonderful to Eric.
So at what level would you say that Eric is currently reading?
Yeah.
STUDENT: First grade.
DAVID J. MALAN: First grade.
And why first grade?
STUDENT: The words are really simple.
There's not much complexity.
DAVID J. MALAN: Yeah so the words are really simple.
There's not much complexity.
And if look at it textually, there is indeed very short sentences,
very few words in each.
And so if we adopt a heuristic, we could assume
that this probably suggests with high probability
that this is a lower reading level.
And in fact, the correct answer, at least according to an algorithm
you will explore in problem set 2 this week,
is actually before grade 1, so maybe kindergarten or the like.
But let's go ahead and do a second example here
if, Elizabeth, you could read one of your favorite texts.
STUDENT: "Congratulations.
Today is your day.
You're off to great places.
You're off and away."
DAVID J. MALAN: All right, so also Doctor Seuss.
And does someone want to conjecture at what level Elizabeth reads?
STUDENT: Advanced.
DAVID J. MALAN: Advanced.
OK, so give me a number, though.
A grade level, perhaps.
More advanced, for sure.
Someone else.
Yeah, in the middle.
STUDENT: Third grade.
DAVID J. MALAN: So third grade.
And why.
What's your instinct behind that?
STUDENT: Still shorter sentences but longer words.
DAVID J. MALAN: So still shorter sentences, but longer words.
And indeed, the right answer, at least according to one measure,
is indeed amazingly third grade.
So let's do one final one with Jesse here,
if you want to read your favorite text for us, turning
on your second pair of glasses.
STUDENT: "It was a bright, cold day in April and the clocks were striking 13.
Winston Smith, his chin nuzzled into his breast in an effort to escape the vile
wind, slipped quickly through the glass doors of Victory Mansions,
though not quickly enough to prevent a swirl of gritty dust from entering along
with him."
DAVID J. MALAN: All right, and one final query of the audience.
At what grade level does Jesse seem to read?
STUDENT: 10th.
STUDENT: Ninth.
DAVID J. MALAN: 10th, ninth.
STUDENT: 11th
DAVID J. MALAN: 11th,
STUDENT: 12th.
DAVID J. MALAN: 12th.
OK, so we're trying all numbers.
The correct answer, according to one measure, is indeed 10.
And why, you probably have an instinct for-- much longer words,
longer sentences, full paragraph.
And indeed that would seem to correlate with a higher reading level, indeed.
But if we go back for just a moment-- you can see this with your human eyes
at a glance.
But if this were actually digital, like in a Word document, a Google document,
or a very simple text file, how could you
actually go about writing code that applies the heuristics that
came intuitively to all of you here, and actually spit out with printf,
for instance, and see an actual number?
So that's going to be among the goals for this coming week's problem set.
In the meantime, maybe round of applause for our three volunteers.
[APPLAUSE]

So beyond reading levels, we thought we'd explore this week other problems as
well.
And in fact, very much current and omnipresent nowadays
is the art, the science of cryptography, the art of scrambling information,
so as to communicate securely.
Whether it's a private message you want to send, or maybe
credit card information, or a password or the like,
among the challenges for this week two after this week's introduction is going
to be to apply these lessons to actually building some form of cryptography
yourself.
And here, for instance, is an example of a message, so-called ciphertext,
that's been encrypted, that is scrambled somehow to make it harder to read.
Now, there is a bit of a hint baked into this.
It's not the most sophisticated algorithm,
but does anyone want to conjecture what this secret message would seem to say?
STUDENT: CS50.
DAVID J. MALAN: So it does happen to say, this is CS50.
And indeed, we're leaking information there.

========================================================
But why is it this is CS50?
Well, you might have guessed that it has the right number of letters and words.
But what comes before U?
T. What becomes before I?
H. What becomes what comes before J?
I, and so it's not just random.
It seems there's a pattern here.
And insofar as if we keep playing that game, each of the letters on the screen
is one away, rotated or shifted from the actual letter I claim it represents.
I bet using some very simple arithmetic, we could write code to do just that.
But what we don't yet have in our toolkit, so to speak,
is the ability to manipulate text in programs, the ability to manipulate
what we called last week strings.
We could print a string like "Hello, world."
We could get a string like David, but we didn't necessarily
have the ability to analyze it letter by letter
or do more interesting things with it.
And that, of course, is what the whole world
does when analyzing text, searching a database, searching the web itself,
is actually analyze some of the text on the screen.
We'll equip you with exactly that, so it will become clear,
among other things, why this indeed says this is CS50.
So how do we get there?
Well, first let's understand some of the magic that took place last week.
And recall that this was the process that
was distilled into a very simple command,
literally make-- make hello, make Mario, or whatever program
you're trying to make.
The input to that process was source code.
It might still look cryptic to you, but it's at least English-like.
The output of that process was machine code, zeros and ones,
that really makes no sense to humans unless you pull out a paper, pencil
and somehow convert it back to something else.
But the compiler is the algorithm, step-by-step instructions
for converting source code to machine code embodied in a program
that you can run.
So that was compilation, converting or translating source code to machine code.
And the code, of course, that we played with mostly last week was something like
this-- simplest program you can perhaps write in C, simply to print out "Hello,
world."
But the computer, of course, only understands the corresponding zeros
and ones.
So how do we actually get from source code to machine code?
That is to say, what's actually happening underneath the hood
when you run a command like make?
Well, up until now, you literally, after making a file,
like hello.c, you would type make hello, cross your fingers,
hope there's no syntax errors, no typos of any sort.
And then to run it, you would do ./hello.
It's a little weird that you have to do that, but dot means the current folder,
and dot slash means run the program called Hello in the current folder.
This is the command line interface equivalent
of double-clicking an icon on your Mac or PC, or tapping an icon on your phone.
It just runs it with the keyboard instead.
But I did reveal briefly last week that Make is not actually a compiler.
It is a program.
It is a useful program.
But it automates the process of running an actual compiler for you.

========================================================
What is that compiler?
Well, there's many different compilers in the world,
but the one we use in class that's free and open source
and therefore very popular in the world is actually
called Clang, for C language.
And so really what's happening when you run make hello,
or any other such command, is that make in turn
is running another program for you called Clang.
The catch, though, is that this program by default
is not nearly as user-friendly.
It doesn't say what it does, let alone give you a useful output,
because the output it gives you is actually a file by default called a.out
for "assembly output," whatever that means.
Which is to say, if you use Clang directly instead make
don't get a program called Hello, you weirdly get a program called a.out.
So let's actually see that.
But then let's fix that step backwards.
So here I am in VS Code.
I've hidden my activity bar in the file browser,
but I'm going to go ahead and run code hello.c.
And I'm going to very quickly recreate last week's program
with including stdio.h.
And then inside of int main void, I'm going to put printf, quote unquote,
"Hello, world," backslash n and a semicolon.
And now, instead of running make, I'm going to do clang hello.c, Enter.
So notice I did do clang hello.c the name of the file.
I didn't just say make hello the name of the program.
So that's one change here.
And now, what was actually made?
Well, what was the command for listing files in a folder?
STUDENT: ls.
DAVID J. MALAN: So ls for list.
And you'll see that not only do I have hello.c there, I also have a.out.
And in fact, if I open up my File Explorer at left,
there are those same two files-- hello.c and a.out.
So hereon after it's all the same--
dot a.out enter still works as exactly as I intend.
It's just a stupid default name for a file.
So how do we go about making this program just more user-friendly, more
aptly named.
Well, instead of running Clang, and then the name of the file,
we can actually provide more arguments to Clang.
And I haven't used this term in this context before,
but there's a new term of art we'll explore
today called command line arguments.
And all that means is that, when you run a command in your terminal window,
you can type not only the name of the command
or program you're running, like ls or Make or Clang.
You can give arguments that is input to that program.
And I didn't use that phrasing last week.
But when you run, for instance, make hello,
the command line argument you're passing to make is indeed hello.
And if there was a second word, that would
be another argument, a third word, that'd
be a third argument, and so forth.
So command line arguments are inputs provided
to commands at the so-called command line in your terminal window.
So that's it, just a term of art.
But instead of running make hello I just ran, of course, clang hello.c.
That gave me the wrong file name as output.
But there is a fix here.
We simply need to know from its documentation, from a class,
from a book, what other command line arguments Clang supports.
And indeed, if I look that up or pay attention here,
I can somewhat cryptically change my command
to be clang -o in lowercase hello, then hello.c.
And this is a very common technique in command line environments, whereby
when you want to modify the behavior of the program by providing more arguments,
you use things like flags or switches here,
called different things by different people.
But -o means output a file called hello when you compile hello.c.
Eventually you memorize these things.
But it's not intellectually interesting, other
than this is how you can provide not one,
but now three arguments to a program.
Then that gives you indeed ./hello, so let me go ahead and do that.
I'm going to go ahead now and clear my terminal window.
Run now clang -o hello, and then hello.c Enter.
Similarly, nothing seems to happen.
If I type ls now, though you'll see three files.
And in fact, /hello works exactly as it did last week.
In fact, I don't need a.out, so there's different ways to delete things.
I could go into my File Explorer.
I could right click or Control click and select Delete explicitly.
Or we didn't see this last week, but you might
have learned it since, you can actually do rm, for remove, a.out, Enter.
And even though this is a little verbose, remove regular file a.out,
it's just asking you now for y or n, for Yes or No.
And I can say Y, Enter.
And now if I run ls one more time, I'll see just those two files.
So that's how I might remove or delete a file.
Obviously, just be careful when doing that if the file is otherwise important.
So let me pause here and see if there's any questions on what we just did
or what a command line argument actually is.
Soon today, you'll have the ability to use and create these things yourself
in your own programs.
All right, so seeing none, that doesn't feel all that compelling.
So we've saved a few keystrokes.
Instead of typing make and instead of typing clang, I have to do -o hello.
But that's again one of the upsides make.
It's fine.
It's not that hard to do -o hello.
But why bother when you can use another program,
Make, to automate that process for you and just save you time?
And indeed, that's what these command line environments are all about,
just saving the programmer or the technical person time
as you get better and better with these things.
All right, but now let's consider another ramification
of what Make actually does for us by taking a look, for instance,
at this same program, but consider what's going on underneath the hood step
by step if we add a couple of more lines of code.
So recall that the second program we wrote using C last week
was this, whereby I added the CS50 library.
And then I used a function we wrote for you called get_string.
I stored the return value of get_string in a variable called name, for instance,
of type string.
And then we use this placeholder technique last time,
whereby I plugged in the value of the person's name
based on whatever they themselves typed in.
Now, there's a lot going on here.

========================================================
But today, we'll peel back the layers of what's happening line by line
and why we have to keep typing stuff like this at the top.
Well, recall that when you compiled that program last week, all you had to do
was run make hello.
But that's because whenever you use third-party libraries,
code that other people wrote, like CS50, then
these commands, when you use Clang directly,
just get slightly more annoying.
If you want to compile that program from last week with Clang directly,
you can do -o hello to specify the file name.
You have to specify hello.c to compile that file.
But now, somewhat annoyingly, you have to do -lcs50, no space in-between,
to specify that you want to use the library called CS50.
Why?
Because that's specific to us.
It's not globally available in the whole world,
so the system doesn't know about it, unless we've pre-installed it.
So this just tells it to support the CS50 library as well.
Now, as an aside, some of you for problem
set 1 probably used the math library, maybe to round
some values or something like that.
It turns out that you can also do -lm in order to use the math library.
But the math library is so darn popular, and it actually comes with C,
that you don't have to actually do -lm.
But it's the same idea.
It's just so common that they automate that process for you.
But for third-party libraries, you have to do this.
Now, at this point, this is really starting
to increase the tedium of compiling your code.
This is why we just say make hello last week, which
automates the process of generating hidden for you
this entire command underneath the hood.
But that is what's happening to get a file called ./hello.
So we're back to where we began.
But what does it actually mean now to be compiling this code in the first place?
So we keep saying, and I will keep saying, to compile your code,
to compile your code, to translate source code to machine code.
But that's actually an abstraction, so to speak.
It's like a simplification of a multi-step process
that the computer's actually doing for you.
And this too will be briefly a deeper dive
to look at this lower level of what's going on.
But then again, after today, we can take for granted that this just works.
But you'll understand hopefully better what's
really happening underneath the hood.
So again, there's no magic.
So it turns out that when you run Make, and in turn it runs Clang,
four separate things are happening, each of which
does something a little different for you-- preprocessing,
actual compiling, assembling, and linking.
It's just the world combines all four of these terms into "compiling"
by convention.
So let's consider the first of these.
========================================================
What does it mean to preprocess a file?
Well, even though we haven't used this word before,
here's one of the programs we wrote last week.
It was a little longer, but this was a program that three times,
called a meow function, which I had ultimately
implemented quite simply with this meow function of my own,
that just says printf meow.
And recall that I did a couple of things at the top of the file.
I included stdio.h because I need print access to printf.
But I also did this.
And what did we generally call this second line?
STUDENT: Prototype.
DAVID J. MALAN: Sorry?
STUDENT: Prototype.
DAVID J. MALAN: A prototype.
The prototype was just the first line of a function, semicolon.
So nothing in between the curly braces.
And recall that that's just a hint to the compiler
that this function doesn't exist as of line 2.
But I promise, it eventually will.
And that was to avoid having to move the whole function from the bottom
of the file to the top, because you can imagine,
once you have three, four, 30, 40 functions,
it's probably going to be hard to put all of them above the other.
So this is a way to just tell the compiler in advance
to expect that this thing will exist.
So what is now going on in the very first step of compiling?
Well, we called it preprocessing.
And anything that starts with a hash sign like this
is what's technically called a preprocessor directive.
Now, a big mouthful, but that just says that there's
something in that file that you want to get
essentially copy-pasted into this one.
So what's really happening now is--
and let's actually consider-- sorry, let me double back here.
Let's actually consider a simpler example for a moment,
namely the second program, again, whereby we used get_string to get
the human's name, and we just said "hello" to them.
This one had two preprocessor directives.
So let's consider what's actually happening here.
What did we say was inside of cs50.h last week.
STUDENT: Get_string.
DAVID J. MALAN: Get_string, but more specifically
the prototype for get_string, a little bit
of a hint that tells the compiler what it looks like,
what's its name, what's its input or arguments,
and what's its output or return values.
So this file, technically, when you run the pre-processing step,
compiler goes into that file, CS50--
finds the relevant code, and essentially copy-pastes it into this current file.
And in fact, it's not even that sophisticated.
It essentially copy-pastes the entirety of cs50.h at the top of your code,
so you don't have to manually copy-paste anything yourself.
Meanwhile, this second line, stdio.h, this of course,
is there for printf sake.
But printf has a prototype.
It's got a name, it's got inputs, it's got outputs.
So that you don't have to go and find that file and copy-paste it,
the pre-processing step goes into that file for you,
finds the relevant code and some other stuff, and effectively copies
and pastes it there as well.
That then is pre-processing.
It just saves you time so that you can reuse functions
that someone else, besides you, perhaps wrote,
and use and reuse them and automate the copy-paste process.
Anything starting with a hash sign therefore gets pre-processed.
OK, what happens next?
The compiling step, which is, again, the catch-all term for all of this.
But when we say your program is being compiled, what we mean now is this.
Here's that same code after it has been pre-processed.
And when you actually compile this code, this
means it gets translated from one language, C in this case,
to another language we haven't talked about.
And after today, we're not really going to talk about it,
but it gets translated from C into something crazy-looking called
assembly code.
And now if you take other courses in computer science--
lower-level courses, so to speak, you'll actually
learn a language that looks a little something like this, which at a glance
is even more cryptic than C, which is why we don't spend
all that much time on it in this class.
But there are some interesting terms that I can highlight here.
So even in this weird-looking language called assembly,
there's a mention of main, there's mention of get_string,
and there's mention of printf.
And there's some other things worth highlighting here.
They're a little more arcane.
But there's some mention of pushing, moving,
subtracting, calling, and so forth, even though there's some other letters like q
in there as well.
But it turns out that inside of your computer
is that CPU, the central processing unit, Intel m or M1
or M2 or M3 from Apple.
Those CPUs, the brains of your computer, at the end of the day,
they don't understand.
C, they don't understand Scratch.
They do understand zeros and ones, but what they really understand
are specifically these commands.
These commands have corresponding patterns of zeros and ones.
But if you're actually building a computer,
and you get the manual from Intel, there will
be documentation for all of the low-level commands, the instructions
that an individual CPU actually supports.
And this might differ between Macs and PCs and phones and other devices.
But this is what happens when you compile
your code from C into this lower-level language called assembly code.
All right, we'll never again see this, I think, for the most part.
So what's the third step?
The third step is to finally convert the assembly code to actual zeros and ones,
because that's indeed what the computer understands.
So here is that exact same assembly code.
Once it is assembled, that means the computer
outputs this, which most humans wouldn't understand,
unless again, they pull out that same manual.
But the computer will understand this.
And the very last step is what's called linking.
So what do we mean by linking?
Well, take a look at this code again.
And just from inference, how many files are presumably involved
in the process of compiling this whole thing?
And I mean compiling in the greater sense, like going from source code
to zeros and ones total.
How many files are implied by this screenshot?
STUDENT: Three.
DAVID J. MALAN: OK, three.
Why three.
I saw two here.
But why three?
STUDENT: Because the main program.
DAVID J. MALAN: The main program, like hello.c.
STUDENT: Yeah, and then cs50.h.
DAVID J. MALAN: cs50.h, and of course stdio.h.
So there's three different files involved in even compiling
the simplest of programs like this.
Now, I'll stipulate that somewhere on the server's hard drive,
there is not only a .h file, which has those prototypes.
There's also a cs50.c file.
There's also a stdio.c file as well, which contains all of the actual code
that we or other people wrote.
It's not necessarily called exactly that,
but there are C files containing all of those lines of C code.
So what really happens now in the fourth and final step of building your program,
compiling your program is this-- hello.c cs50.c, and stdio.c,
wherever the latter two are on the server.
We pre-installed all this stuff for you.
You only wrote in this story this file.
When you finally compile, and once you have pre-processed, compiled,
and assembled your files, you essentially
have three sets of zeros and ones, each of which
corresponds to each of those files.
This is the code you wrote, once it's compiled to zeros and ones.
This is the code that CS50 wrote.
This is the code that came with C stdio.c itself.
So the fourth and final step is literally linking.
What does it mean?
Well, you've got three sets of zeros and ones.
You've got to somehow mash them together, link them together.
And linking does exactly that.
So this is such a mouthful to say that you write C code,
and it ends up zeros and ones.
But each of the steps can be very cleanly
broken down like that, so you understand exactly
what's going on underneath the hood.
And now if you consider the command we talked about earlier,
-o just specifies what file the linker outputs at the end of the day.
Is it Hello?
Is it a.out?
Is it something else?
And -lcs50 more specifically, doesn't just mean -l library, it means -l link,
so link in CS50's library to ensure you have access to those zeros and ones.
You don't have to do it for math.
You don't have to do it for std I/O. But you
do have to do it for third-party code that other people altogether
wrote for you.
Whew, OK, done with that deep dive.
Questions, confusion, on any and all of that?
Yeah, in the front.
STUDENT: Are there ways to import art stuff like, let's say CS50?
Like, if I'm not going to use a lot of things that's written in the CS50 file,
but I only want one function, is there a way to just pull out just one thing?
DAVID J. MALAN: A really good question.
If you only want access to one function, and not all of them
in a library like CS50's, can you extract just a subset.
It depends.
The compiler ideally would do some of that for you,
and it would only dynamically link in what you actually need.
If, though, by default you statically link everything,
and you get all of the zeros and ones, this is actually now
a more sophisticated answer to a question someone asked here last week,
which was about the efficiency of all of this.
And unfortunately, by default, you would typically
get bigger and bigger files if you're linking in too much stuff unnecessarily.
So yes, that's absolutely an optimization that is possible,
but the compiler should be handling most of that for you,
not you, the programmer, generally worrying about it.
Yeah.
STUDENT: In your prototype for the printf function, why was there,
like, an int before that.
DAVID J. MALAN: Oh, really good question.
In the prototype for printf, why was there an int before?
Let me come back to that.
And we'll talk a little bit about something related in spirit today.
Main, actually, all this time also has the word int in front of it.
We'll explain that one first.
All right, so what can we take, then, away from this?
Well, if that is all compiling can we actually reverse the process?
Can you go about decompiling code?
That is to say, if you have a program installed
on your computer or your phone, and it therefore contains all these zeros
and ones, can you maybe reverse engineer it--
that is, convert it back to source code?
Well, is that possible-- well, sort of.
In fact, here's an example of a program written in C that's already
been compiled down into machine code.
And by compiled, I mean it's already been pre-processed, compiled, assembled,
and linked.
And these are the zeros and ones.
Well, it turns out that if you break these zeros and ones up
into chunks of, like, eight or maybe 32 or 64,
you could very tediously, or using some software to automate the process,
look up in Intel's manual what all of those patterns of zeros and ones
represent.
And you probably could reconstruct the fact that, you know what?
I bet this thing says "Hello, world."
Like there's enough pattern in there to figure out something like that.
And surely if it says "Hello, world," we could generate source code that does
the exact same thing.
But what if there's some kind of loop in there, and "Hello, world"
is actually getting printed two times or three times or four times,
or an arbitrary number of times?
I don't know if I could decompile the code quite as effectively.
Why?
Well, once I have it down to the levels of zeros and ones,
I don't know if the programmer used a while loop, a for loop, a do while loop.
There's ambiguity in that process ultimately.
So while you can reverse some processes, at some point,
it becomes harder or ambiguous to do so.
And this is a relatively short program, even though there's
some more zeros and ones not pictured.
When you're talking about something like Microsoft Word or Excel,
there are millions of zeros and ones inside of that.
And honestly, in the amount of time it would take you to figure out tediously
what those zeros and ones correspond to in C, or some other language,
you're probably smart enough to just start writing the program yourself
in the other direction.
And that's the supposition when it comes to intellectual property
and protecting your software's IP rights.
The reality is, like the people who are going
to be so good as to reverse engineer it probably could just
recreate the software itself.
So there's a bit of pushback there inherent.
But later in the term, we're going to talk about other languages--
HTML, CSS, and JavaScript.
That stuff is not compiled into zeros and ones in any way like this.
So that code is actually revealed to literally anyone on the internet.
We could go on Harvard or Yale's website right now, look at the JavaScript code
that powers parts of it, and actually see what's going on.
But more on that in just a few weeks' time.
So today is all about debugging ultimately, too--
like finding and fixing mistakes in your code.
And debugging actually does indeed mean removing mistakes from your code.
There is mythically a story behind that.
So this is Rear Admiral Grace Hopper from the United States
Navy, who had her PhD from Yale, and actually is known for many things,
but among them is for working on the Harvard Mark I
computer that looks a little something like this in black and white.
It's now housed across the river in the Science and Engineering Complex
at Harvard, which you can visit if you hop across the river someday.
But in the Harvard Mark II, another successor to this large mainframe
computer, Dr. Hopper was responsible for keeping the log book.
And pictured here is, if we zoom in here, the first actual case of a bug
being found.
Some kind of moth was physically found inside of the Harvard Mark II,
disrupting its operations.
And that's not literally what we mean, nowadays when
it comes to bugs in software.
And this really just popularized the term.
It wasn't the origin of the term itself.
But that's among the stories that gets tossed around typically
when talking about bugs and, of course, debugging.
So among the goals for today is to actually make your life easier
when it comes to solving problems this week and onward, because odds are
you were bit in the dark.
If you had some mistake in your code last week, you could have,
of course, asked the duck.
You could have asked a teaching fellow or teaching assistant.
You could have struggled through it.
But let's actually give you more tools in your toolkit to solve problems.
So here, for instance, was one of the simpler problems we did last week.
And we'll keep it simple so we can focus on the debugging techniques and not
the complexity of the code.
And recall that this example was all about just
printing, like, a column of bricks using hash symbols, otherwise known as ASCII
art.
Well, the first debugging technique we gave you, and encouraged you to use,
last week was, of course, this virtual rubber duck, or even
a physical rubber duck.
In fact, on the way out today after class,
we have not only these ducks, but hundreds of others,
if you'd like to walk home to your dorms with a rubber duck
and we'll bring them to those of you at Yale, you may at day's end.
But the virtual version of this is, of course,
powered by artificial intelligence.
And not only will the duck listen to your questions,
it will try as best as it can in English or some other human language to respond.
But the general idea of rubber duck debugging, or rubber ducking,
is to talk to an inanimate object like this, or nowadays an AI,
and again, per week zero.
In that process of sounding out your confusion and telling the duck,
like a teaching assistant, what your problems are,
odds are that proverbial light bulb will go off,
and you'll realize some illogic, some mistake you've made, at which point
you can actually solve it yourself.
But when the problems get harder, and when the material is especially new,
it's not going to necessarily come to you off the top of your head.
So let's give you some more techniques.
It turns out that one of the most common and useful ways to debug code
is literally with a function we've used since week one printf.
Because printf lets you print anything you
want, including the contents of what's inside of the computer's memory,
so to speak, inside of your variables and functions and the like.
So let's go ahead and do this.
========================================================
Let me switch over to VS Code here.
And let me go ahead and create a new file
that deliberately is called buggy.c.
So code buggy.c.
And this will be relatively simple.
Include stdio.h int main void.
And then inside this, let me aspire to print out
this column of bricks here-- of one, two, three bricks, top to bottom.
All right, back in my code, I'm going to do for int, i equals 0.
I want three of these, so I'm going to naively do i less than or equal to 3,
i++.
And then inside of a for loop, I'm going to do printf, quote unquote, hash sign
backslash n, closed quote, semicolon.
So if you're already pretty comfortable with C and for loops at this stage,
you can probably see the bug already.
But again, the focus here is on techniques, not the actual code.
It looks like I've done something stupid, though,
because when I do compile this code--
and I'm going to do make buggy, instead of bothering with Clang,
because we now can stipulate that we know there's more going on there,
but we don't need to care about it every time.
./buggy is not going to print 3.
It's going to print four of those hashes instead.
All right, so how do I go about wrapping my mind around what's wrong?
Well, I remember from class, I'm supposed to start counting from 0
if I want to go up to 3.
It's less than or equal to 3, so we could probably reason through this
without much effort.
But let's suppose that this is representative
of more sophisticated problems.
Well, printf here can be your friend.
If you want to see what's going on inside of this loop,
I would propose that you temporarily maybe add a second printf that
says something like this.
i is-- and then I'm going to use a placeholder,
i backslash n, close quote, i.
So if I just want to wrap my mind around what's
going on every iteration of this loop, let me just literally print out
the contents of that variable.
So let me remake this-- make buggy, ./buggy, Enter.
OK, now let me enlarge my screen.
What has happened? i is 0, I get a hash.
I is 1, I get a hash. i is 2, I get a hash Oh, i is 3, I get another hash.
So the solution here is one of a few things.
I could either regress and start counting from one.
But in general, I would propose do what programmers do start counting from 0.
So if I leave i at 0, what is the correct fix here?
STUDENT: [INAUDIBLE].
DAVID J. MALAN: So just change it to less than 3
instead, which again is the convention, even though it's
by no means the only way to do this.
If I go ahead and do that, let me clear my terminal window
and make it larger temporarily.
Make buggy again, ./buggy.
OK, now I got it. i is 0, i is 1, i is 2.
And I only get hash hash hash.
So printf is your friend, just remember, certainly
in the context of a class like homework and the context of the real world.
Once you're done using printf to debug your code, go in and delete it,
so it's not printing out a confusing message to the autograder,
the correctness tests, or the like there.
All right, so that's how you might use something like printf.
But what if I did something a little more sophisticated here?
Let me do this.
Let me change up this program and get rid of for loop.
And let me, for the sake of discussion, just make it a little more complicated.
Let me go ahead and create an integer called h for height.
Let me ask the human using get_int for the height of the column of bricks
that they want.
I immediately have to go in and add the CS50 library,
because if I want to use get_int, that comes with CS50, not with stdio.h.
Once I've done this, let me go ahead and call a function that doesn't yet exist,
but will--
print_column of height h.
And this is where we concluded roughly in week 1,
whereby I factored out some of the functionality
for printing a row of bricks.
Today, I'm flipping it around to say, print a column,
because now I'm going to do this--
void print_column.
And then the input that this will take is going to be the actual height.
But I could call that anything I want, so long as it's an int.
And here I'm going to recreate the correct code for int i equals 0.
I less than-- not 3, but height if I want to genericize it, i++.
And then inside of the loop, I'm going to go ahead and quite simply print
a single hash and a new line so that it gets hash, hash, hash, hash,
one per line.
But there's technically a bug here.
========================================================
Let me hide the terminal window and scroll back up.
What one mistake have I still made?
STUDENT: Prototype.
DAVID J. MALAN: I'm missing the prototype,
because if I compile this as is, the Clang, the compiler as we now know,
won't know what print_column is, because when
it sees it for the first time on line 7, it has never seen it before.
So the solution, of course, is to copy-paste--
and this is almost the only time copy-paste is acceptable and encouraged,
that first line of the function itself.
All right, let me open my terminal window.
Let me run make buggy.
It seems to work-- ./buggy, Enter.
And it's gone ahead and done--
let's see, 3.
This is the correct version.
So just a bit of a sanity check that it's working as intended.
Now let's break it.
Let me hide my terminal window.
Let me make the same mistake as before.
And let me say that printf, for now, is your friend.
But by week three, week four, week five, in the real world,
you're not going to want to just start printing everything out,
because you're going to be printing so many darn things,
you're going to have to then remember to delete the stuff.
It's going to mess up the output.
There are better tools.
And even though this week, it will take you more minutes to play with
and get comfy with what I'm about to show you,
this will pay off in hours over the course of the term
and in the real world.
Spend a few extra minutes this week playing with a proper debugger, which
is going to introduce you to more sophisticated techniques
for debugging your code.
We are going to run now a program called debug50, which sounds CS50-specific.
But that's only because it automates the process of starting
VS Code's built in debugger for you.
So this is not a CS50 thing.
This is representative of a debugging tool
you would have in the real world available to you.
And VS Code is among the most popular.
========================================================
So let me go back to my own code here.
Let me open my terminal window.
And let me confirm now, by recompiling buggy, Enter, and running ./buggy,
now we're back to the problem where if I type height of 3,
I'm getting four hashes.
So how can I wrap my mind around why that is the case without using printf?
Well, what I'm going to do now is this.
I'm going to run debug50.
And then I'm going to run the name of the program, ./buggy
So debug50 is a program that expects its own command line argument.
What program do you want me to help you debug?
I'm going to go ahead and hit Enter.
And I made my first mistake.
Looks like you haven't set any breakpoints.
Set at least one breakpoint by clicking to the left of a line number,
and then rerun debug50.
So what is a breakpoint?
Well, let me hide my terminal for just a moment.
A breakpoint is sort of a stop sign that you
can add to any one of your lines of code,
and tell the computer break execution at that point.
That is, run my code, but pause temporarily here so I can poke around.
So what I'm going to do is, because the first line of juicy code
is at line 8, notice if I hover in the so-called gutter of VS Code,
there's this little stop sign or red dot that appears.
I'm going to hover over line 8.
And as directed, I'm going to click, and it gets even redder.
That is a breakpoint.
It says, run my code, but stop at this point so I can poke around.
Let me reopen my terminal window, clear it, and do this again--
debug50 ./buggy, Enter.
All right, so a whole bunch of stuff seems to be happening automatically.
It's a little confusing at first glance.
I'm going to zoom out just so we can see more of it here.
I'm going to go back to the terminal window, because notice-- there we go.
In my terminal window I have a blank window now, because why?
Line 8 is about to prompt me for input.
So what has happened here?
Well, let me go over here to the code.
This is still my buggy file.
Notice that there's a Play icon here.
There's some arrows.
There's a Stop icon and some other stuff.
Notice that line 8, as hoped, is highlighted because execution
has been paused on line 8 before it executes.
Let's now actually see what's going on.
At the top, though, there's some curiosities.
All of my variables in this program that are currently in scope--
that is, accessible between these curly braces, are summarized here.
Where did 32,766 come from?
Any instinct for why h apparently has this weird value,
even though I haven't even typed in anything, let alone such a big number?
Yeah, how about over here?
STUDENT: The previous program had that number.
DAVID J. MALAN: Yeah, I think that's a reasonable way to think about it.
Maybe it's like a previous program used the same memory inside
of the computer for something else.
Maybe it was an integer.
Maybe it was a string or something else.
So what you're seeing is actually what we're
going to start calling a garbage value.
It's like remnants of what the memory was previously used for.
It has no significance to us.
It's not a big deal, because as soon as I let the debugger proceed one more
line, the value of h is going to be changed to whatever the human actually
types in.
But what you're seeing is what's really going on inside the computer.
You're certainly using and reusing the memory inside
of your computer all day long, because you don't want to run out,
so you need to reuse it.
So the debugger is letting us see that.
So now notice the arrows at the top of the screen.
I can either hit Play to say, like, just keep running the whole program.
Or I can do something like this--
Step Over.
So this second arrow here, Step Over, will actually run line 8,
but then pause on the next line for me.
And we'll see what else we can do in a moment.
So I'm going to click Step Over.
And now notice, in my terminal, I have been prompted for a height.
Let's go ahead and type 3, Enter.
Now I've typed in 3.
What happened at top left?
Now the local variable, so to speak--
local in the sense that it's inside of these curly braces, is, in fact,
what I would expect, which is 3.
Notice now that line 9 is highlighted.
It hasn't printed anything yet.
So let's step over line 9, too, and see what happens with this value of h.
Let me click Step Over again.
The highlighted line becomes 10, which is almost at the end of the program.
But unfortunately, I see 1, 2, 3, 4.
Damn, like, it's still buggy in this case.
And honestly, this wasn't really enlightening,
setting the breakpoint there.
I really have just slowed down the process of seeing my mistake.
But it's still, in fact, there.
So let's actually just run the program to completion.
I'm going to hit the Play button.
But I could just as soon hit the Stop button
because they're equivalent, because the program is essentially over.
All of that is going to close, but at my breakpoint is still at line 8.
I'm going to do this.
I'm going to leave that there.
And I'm going to run debug50 once more.
Let's actually step over this line as before to get
my input of a height of, say, 3.
But now on line 9, which is highlighted, let's not step over this,
because obviously, that's just going to print out
the same wrong thing instantly.
========================================================
Let's step into this function.
Why this one?
Because I wrote print_column.
Ironically, I also wrote get_int.
But I'm pretty sure get_int is not incorrect.
I'm pretty sure print_column is incorrect, so let's step into it.
The icon for that is the third icon here, the second arrow, Step Into,
click.
And now notice that execution has jumped into the print column function.
Nothing is printed yet, because I haven't even started for loop.
But now I can actually poke around here.
And notice this.
This is an even crazier value for i, but for the same reasons.
It's just some garbage value left over from whatever this memory was
being used for previously.
But the moment I click Step Over now, the second icon, now notice at top left,
i is 0, and we're about to print a single hash.
Let me click Step Over once more.
And watch the terminal window at the bottom.
I currently have no hashes, but now I have one hash.
Now the highlight's back on line 14.
Let's step over that, and watch as I do, at top left, i is value
is going to change from 0 to 1 because that value just changed.
Now I'm highlighting line 16.
Let's click Step Over and watch the terminal window.
There's my second hash.
Let's step over line 14.
Watch i at top left.
i equals 2.
Let's go ahead and step over line 16.
There's my third hash.
Let's now step over line 14 again.
Watch the i at top left.
Here's where you can see that, oh, i equals 3.
But wait a minute.
Line 16 is highlighted.
I'm about to execute the darn thing again.
Oh, that's why I'm getting the fourth hash.
And if I do this one more time, Step Over line 14, watch what happens to i.
i now disappears altogether.
Why?
Because I've jumped out of for loop, because i became 4.
4 is not less than 3, so we're done with that for loop.
And now if I go ahead and hit Play, it's just
going to run to the end of the program, which is essentially already
that because the curly brace was already there.
So it's tedious to walk through a program in this way.
But notice, it has given me the ability to step through my code,
line by line by line, at a normal person pace,
not at like a Mac or PC pace, which is over in the blink of an eye.
To get rid of a breakpoint, you just click on the little stop sign again.
It goes away, and your code will run as usual, even in the debugger.
Questions, then, on this technique of debugging?
========================================================
Questions?
OK, use debug50.
OK, use the rubber duck.
That, too, should be helpful over time.
But let's actually now take these ideas out for a spin
and actually see what's going on in the actual computer's memory
with these new techniques.
So recall from last time that when you write code, you can use strings,
like hello world.
You can use integers like the number 50, or 72, 73, 33.
That is because C, like a lot of languages,
supports different types of data.
And think back to week 0, when we stipulated
that everything is zeros and ones.
How does the computer know if that's a number, a letter, a color, an image,
a video, a sound?
Well, it's context-sensitive.
And I simplified it in week 0 and said, well,
if you open something in Photoshop, the zeros and ones
are going to be interpreted as colors.
But that was a bit of a white lie.
The better answer is, when you open in Photoshop a bunch of zeros and ones,
the programmers at Adobe, the people who wrote that software, specified
in the code that those zeros and ones should be treated as colors, and not
as numbers and text per se.
So in the world of C, there are these data types.
And we had this list up last week.
And we focused particularly on string and int.
We introduced briefly float for real numbers with decimal points.
Longs are even bigger than integers.
So you don't avoid, but you at least postpone integer overflow
by using more bits.
And here, for instance, is how big these data types in C typically are nowadays.
Technically, it varies by computer or device.
But typically, it's safe to assume these values here.
So a Boolean, a true or false, takes up one byte, even though that's overkill.
You technically just need one bit, but C uses a full byte.
An integer is typically four bytes.
Four bytes is 32 bits.
That means you can count from 0 to 2 to the 32nd power.
That's 0 to 4 billion, or if you want to support negative numbers, negative 2
billion to positive 2 billion.
A long is 8 bytes.
That's in the quintillions, depending on whether you want
negatives or positive values as well.
Float is 4.
Double is 8.
A char, a single character, is 1.
That's going to be germane today.
And a string, I'll propose, is unknown because it
depends on how long the word is.
If I type in D-A-V-I-D, it would seem to be of length 5 at first glance,
or hi or just 2.
A string is going to vary based on the actual contents of the memory.
And here, then, is a picture of memory.
So this isn't to scale at the moment, but this
is what might be inside of your laptop or phone or desktop.
And it would look similar in spirit, like a green circuit board or logic
board with tiny little silver or gold traces
that are essentially like tiny little wires that allow
zeros and ones to flow back and forth.
And there's these black chips that actually store the zeros
and ones as your computer's memory.
So if we actually zoom in on one of these black chips,
I'll propose that no matter how big this chip is,
I bet we could come up with addresses for all of the bytes therein.
So if this thing is like 1 gigabyte, 1 billion bytes,
doesn't matter how we number them.
But for the sake of discussion, maybe this is the first byte.
This is the second byte.
This is the third byte.
This is the billionth byte for gigabyte.
So you could imagine, if you got this many bytes,
you can slap some numbers on them.
Just like on a building in the real world,
you can slap a unique address on it.
Like 45 Quincy Street, Cambridge, Massachusetts, 02138,
USA is where we are now.
In the world of memory, let's keep it simple--
0, 1, 2, 3 and so forth.
So let's actually redraw this as a grid of sorts, whereby each of these squares
represents a chunk of memory.
So if you were to store a char in the computer's memory, that's one byte.
So maybe if the human were just to type in a single character,
maybe it would be stored up there in the top left corner, or who knows?
Somewhere else.
If you were to store an integer, which is 4 bytes,
typically, maybe it would be stored there.
But they are necessarily contiguous.
You can't use one byte here, one byte here, one byte here.
For data types like integers and strings and chars,
they're all going to be back to back to back.
So that's 4.
What about a long, or a double for that matter?
You might need 8 bytes.
Those are all going to be contiguous here.
Well, let's actually go ahead and abstract away the hardware,
because it's not really that interesting that there's a physical circuit board.
Let's think about memory more abstractly.
It's just like a canvas, like in Photoshop, where
every little dot can store some byte--
some set of 8 bits.
Let's zoom in here and consider what could go inside of those bytes.
So for instance, how about three lines of code like this?
Out of context, but suppose we whip up a program real quickly
that allows me to calculate my average on, like, three homework
assignments or three quizzes or three exams in this class or any other.
Suppose I did so-so on the first two.
Score one was 72, score two was 73, score three not so good--
33.
What's my average grade as of now?
Well, I think we could whip this up pretty easily.
For instance, let me go over to VS Code here.
And let me go ahead and create a new file called--
how about scores.c?
And in scores.c, I'm going to go ahead and do maybe a little something
like this.
Include stdio.h int main void.
And inside of main, let's do int score 1 equals 72, int score 2 equals 73,
int score 3 equals 33.
And now let's just print an average.
And I'm going to make a comment to myself Print average,
so I remember what's going on.
Comments are just for the reader not for the computer's sake.
Printf average colon-- just to format it nicely.
I want as many partial points as I can get,
so I'm going to use a float instead of an int, backslash n.
And then to compute the average, just like in the real world,
I think I do score 1 plus score 2 plus score 3 in parentheses,
all divided by 3, and then a semicolon.
So let's see if this works.
========================================================
I'm going to go down to my terminal window
and do make scores, which will run Clang for me.
But I screwed up already.
Let me make this bigger.
I'm not sure we've seen this error before.
Let me rerun it more simply.
What did I do wrong here, even though it's cryptic?
Yeah, in back.
Or just stretching?
Just stretching.
Yes, in there
STUDENT: You're missing a parenthesis.
DAVID J. MALAN: I'm missing a parenthesis.
I don't think so.
Not a bad instinct, but I'm not in this case, I think I'm balanced.
STUDENT: The format is wrong.
DAVID J. MALAN: The format is wrong.
So the format code is wrong.
I'm using %f, but it wants me to use %d, which technically means decimal,
which is a synonym for %i for integer.
But actually, no, I don't want it to be an integer.
If I get partial credit, I want to be rounding up, not down, so to speak.
So there's actually a more subtle error.
And remember the issue last week of truncation,
whereby if you've got int plus int plus int divided by int,
what do you get back?
You get an int.
So you don't even round properly.
It truncates everything after the decimal point.
So one way to solve this problem would be to say, all right, really,
I want to divide by 3.0.
So long as you get a floating number involved,
then the math will work correctly.
Or I could do what I did last week too.
I can cast the 3 to a float.
But frankly, it's pretty equivalent and few keystrokes fewer
to just say 3.0 as my denominator.
And again, to be clear, the reason for that--
I don't want integer division.
I want a floating point value.
So if I'm getting partial credit, it's point-something that's not thrown away.
All right, let's try again-- make scores, Enter.
It seems to work now-- ./scores, Enter.
And my average is indeed, thank to you, 59 and one third.
Still kind of failed, but at least it's not 59.0 truncated down.
All right, so that's one way of doing this.
But what's actually now going on inside of the computer's memory?
Well, here is the computer's memory, abstracted away as just squares.
When I create score 1 as a variable, that's
like asking the computer for four of these squares.
Call it score 1, and plop, the number 72 there.
When I ask for score 2, that's like getting
another 4 bytes of memory, probably next to it, but not necessarily.
And when I create score 3, that gives me another chunk of memory, also
4 bytes with the number 33.
Again, because there's no other variables as of yet in this program,
they probably will end up back to back to back.
But that's not necessarily a requirement,
depending on how you implement the code.
Well, what is the computer really doing in the memory there?
Well, it's really putting three patterns of bits--
three patterns of 32 bits, because again, by default integers
tend to use 4 bytes, or 4 times 8, 32 bits total.
So if that's what's going on inside of the computer's memory,
it would seem to be correct.
And indeed my math was correct.
But what is badly designed about this program?
It's super simple.
There can't possibly be too many shortcomings.
But what's bad?
Yeah.
STUDENT: You wanted to add more scores, you
would just keep writing new variable initializations
and you have to individually modify the averaging part.
DAVID J. MALAN: Yeah, really well said.
So if I wanted to add in more scores-- like next week, a fourth score, then
a fifth score, then a sixth score, well, I can just modify the code,
and add a line, line, line here.
But then, I have to add like variable, variable, variable here.
It's not very well maintained.
And honestly, if you let your mind extrapolate, what if I've got,
like, 10 scores or 100 scores over the course of years of college?
Does it really seem like good design to have int score45, int score46?
There's got to be a better way than coming up
with these stupidly named variables where I just manually add a number,
add a number, add a number.
Wouldn't it be nice to just call all of them collectively scores,
and not have to create individually all of these unique names?
And frankly, I don't have to call them score1, score2, score3.
I could have called it A, B, C, or something arbitrary like that,
but that's even less clear.
It would be nice to just call them all collectively one thing.
Well, it turns out that there is a way to address this.
And to do better than this in code, we're
going to introduce the first of our data structures
this week in class, whereby we can introduce the notion of an array.
An array is a sequence of values back to back to back in memory.
An array is a sequence of values back to back to back or contiguous in memory,
all of which are the same data type.
So int, int, int or char, char, char, or something else along those lines.
And the syntax for creating a single variable that contains not one,
but any number of values, is relatively simple in C.
You simply specify what type do you want the values to be-- int.
What do you want the name of the variable to be?
Scores plural, just for clarity.
And how many integers do you want to be associated
with this variable called scores?
You use square brackets, which is something new now.
But the square brackets indicate, hey compiler,
this is an array of three integers that will give me access to all three
back to back to back in memory.
So if I want to now initialize each of these values to numbers,
the syntax is pretty similar to before.
But I don't have to come up with new variable names for each of them.
I can instead keep using this square bracket technique as follows.
To initialize the first score, I can say scores bracket 0 equals 72, semicolon.
The second one is scores bracket 1.
The third is scores bracket 2.
They are zero indexed, so to speak.
========================================================
As before, we're almost always going to start counting from 0
in C and in most other languages.
So 0 is the first, 1 is the second, 2 is the third.
But notice these aren't separate variable names.
Now they're all called scores.
But I am indexing into the array by jumping to a specific location--
the first one, the second one or the third one,
or first, middle, last so to speak.
So if I want to use this technique now, let me actually go back to VS Code
here, and let me modify my version of scores as follows.
I'm not going to quite do what you recommended over there
a moment ago, which is to avoid repeating myself a few times.
But I am going to clean this up.
I'm going to say int scores bracket 3 to give me an array of three values.
Then I'm going to manually say scores bracket 0 equals
72, scores bracket 1 equals 73, scores bracket 2 equals 33, semicolon.
And then down here, I have to change my formula to be scores bracket 0,
scores bracket 1, scores bracket 3--
sorry, scores bracket 2, and then divided by 3.0 for the same reason
as before.
If I open my terminal now, clear it, make scores,
again seems to compile ./score.
It still gives me the same value, but it's a little better-designed.
I've got one variable now with three spots in it,
instead of three variables-- and God forbid,
even more if I want more and more of these values.
Well, what is now going on in the computer's memory.
Well, these three lines of code.
Now look fundamentally the same-- four bytes, four bytes, four bytes.
But the names that the computer is giving them is scores bracket 0,
scores bracket 1, scores bracket 2.
And to be clear, it's one variable.
But this is saying go to the first location, location 0.
Go to the second location, a.k.a., location 1.
Go to the third location, a.k.a., location 2.
It's a little confusing that everything's off by one,
but you get used to it over time.
So if that's what's going on inside of the computer's memory,
let's actually tinker with it further.
And toward this end of making it even better ultimately,
let me propose that we go back here and maybe modify this as follows.
Instead of hard-coding my three scores--
72, 73, 33, and then having to update this code next week,
and then update it in two weeks by adding more and more scores to it,
what would be the right programming technique here to just prompt me
again and again?
STUDENT: [INAUDIBLE]
DAVID J. MALAN: Like, loop again?
We don't have to write all of these lines of nearly identical code.
So let me do this.
========================================================
Let me get rid of these three lines, which look like copy-paste,
except for the changing number.
Let's do 4.
Int i is 0.
i less than 3, so I'm not going to screw up this time--
not less than or equal to but less than 3, i++.
Then inside of this for loop, let's go ahead and use this syntax--
scores bracket i equals--
let's actually ask the user now for their score, rather than hard
coded at all, using get_int like this.
So we're using the square brackets now in a few different ways,
even though the rest of the code is now the same.
In this line of code, I'm declaring the variable called scores
to be an array of size 3 integers.
It's a mouthful, but that's all that's going on there.
When I use the array later, I don't have to say int ever again.
That was just to tell the computer once what types of values
do I want to put in here.
Hereafter, I can just say scores bracket i.
Well, what is i?
Well, on the first iteration of this loop,
it's going to be 0, and then 1, and then 2.
Like magically, it's going to plug into those square brackets.
Exactly the number I want--
0, 1, 2, on up.
Get int is going to be called 1, 2, 3 or more times, based
on how many times I loop.
So I don't have to type 72, 73 or 33 in my code at all.
Now, the code is still imperfect.
I'm still cheating that I've got the 3 here.
I've got three of these here.
I've got the 3 here, the 3 here.
This is still poorly designed, but it's better.
It's poorly designed in the sense that I've
got this magic number 3 everywhere that I am going to mess up at some point.
If I change it to a 4, I bet you I'm going to miss one of those locations.
So we should probably improve that as well.
Well, let me go ahead and just confirm that I didn't make things worse--
make scores.
I did.
What did I do wrong here?
Error-- call to undeclared function get_int.
STUDENT: Yeah, include cs50.h.
DAVID J. MALAN: Yeah, I didn't include cs50.h That's why the compiler just
doesn't know what a get_int even is.
So that's an easy fix.
Let me go ahead and type that in here.
Clear my terminal, rerun make scores.
OK, now we're back in business-- ./scores.
Now I'll type them in when prompted by get_int.
72, 73, 33, and I'm still getting the math correctly.
But I can do a little better, so let me hide my terminal window.
Let's get rid of this magic number 3.
How can I do this?
Well, I could do something like this-- int and maybe capital N equals 3
for a number that's not changing.
But actually, there's a technique.
If you want to tell the computer, don't even let me change this number,
what can I write on line 6 before int?
STUDENT: Const.
DAVID J. MALAN: Const--
we haven't used it much.
But this is just a way of protecting you from yourself,
or protecting your code from some dumb colleague who
goes in and tries to change a number that they are not supposed to.
So const int N equals 3 means this variable shall be forever the value 3.
What can I then do with this?
Well, I'm going to change the 3 here to N, the 3 here to N.
And down here, it's a step backwards.
I don't want to do N just yet, but I can cast this
to a float to make sure that 3 is treated as though it's 3.0.
Now, I capitalized N just by convention.
Generally, when you use constants, humans tend to capitals.
Why?
Because it just jumps out to the reader.
Wait a minute, like, this is capitalized for some reason.
That usually means it's meant to be a constant, just
as a little visual heuristic.
This is still imperfect, because I'm still assuming
that n is always going to be 3.
But one problem at a time.
Let me open my terminal-- make scores ./scores 72, 73, 33.
Code still seems to be behaving correctly, except for notice this time,
we're seeing a bit of an artifact.
Now suddenly, I lost a 1, 10, 100, 1,000, 10,000 one millionth of a point.
So the rounding is a little different.
But that's because fundamentally, when dealing with floats,
they are going to be imprecise.
They're maybe not very imprecise, but slightly imprecise.
Thus far we were getting an additional 3 there, not a 2.
That's just a side effect per last week's discussion.
========================================================
Well, let me go ahead and do this.
Instead of typing this one out myself, let me go ahead
and grab from the oven already cooked a program
called scores version 5, which I wrote in advance, which now has everything.
So this is a lot on the screen all at once, but let's focus on what's similar.
I'm including cs50.h and stdio.h.
I'm declaring a const.
Notice, though, that I've put it at the top of my file instead inside of main.
And that's OK.
It is sometimes OK and a good idea to put your constants outside
of functions, so that if I do want to change it somewhere,
it's obvious where to change it.
It's not buried in some function.
It's at the very top of the file where it's more obvious to the reader.
Notice now, I've introduced a function called average-- more on that
in a moment, because the problem I still had,
was even though I had 3, 3, 3 in a variable,
I was still manually adding score0, score1, score2.
What about scores 3, 4, 5, 6 as the program grows?
Well, how am I solving this?
Well, notice this.
In main now, I'm giving myself access to N score.
So whatever N is, make the array big enough.
And this is a cool technique with arrays.
If you don't know when you write the code what the size is,
just use a variable.
And the computer will give you an array of that many spots.
The for loop is exactly the same here, exactly the same here.
I'm just prompting the user again and again for each of their scores.
The only thing I've changed now is fix the final problem.
Instead of just printing out the average of score0
plus score1 plus score2 divided by 3, I'm actually asking a helper function,
so to speak-- another function that I wrote
called average that takes two values.
One is N because it's got to know how many values
to average-- what's the denominator, and then the array itself.
And this is the only new piece of syntax now with respect to arrays
is how I'm passing this in.
Let's focus on just the math for a moment.
How do I calculate an average when I know don't in advance
how many values there are, so I can't just do this plus this plus this
all divided by 3?
Well, let's create a variable called sum.
========================================================
Let's then iterate over the length of that array.
Let's use some of last week's syntax to add to that sum
the value at location i, location i, location i as i goes from 0 to 1 to 2
on up.
And then lastly, how do you calculate the average?
Well, whatever that sum is divided by the length of the array.
Cast it again to a floating point value.
So the only thing here is a recollection from grade school
that, to calculate the average, you just add, add, add
all of the numbers in the numerator, and divide once by the denominator.
So I've used some C code with a variable and a for loop to do just that.
The only weird thing I'll call out here is this.
Notice how I wrote the average function.
It's called average.
It returns a float, which we haven't seen before.
But it stands to reason, if we can return INTs
and if we return nothing like void, I could probably return a float.
And that's correct.
This is the output of this function.
That is why I can return a value.
But this is weird.
Not only does average take two arguments.
One of those arguments as of today is now an array.
So I could call these arguments anything I want-- a, b, x, y.
But I'm calling them more usefully the length of the array, and then the name
I want to give this array.
But I could call it anything.
I could call it numbers.
But I called it array for the sake in class of making super-explicit
what an array is.
But this is the weirdness.
When a function takes as input someone else's array,
you don't have to know in advance what the size is.
So you just say open bracket, close bracket, and leave it at that.
But you need to make sure that caller, the function who created the array,
also tells you with a second argument how big it is.
This is not true in Python.
This is not true in JavaScript and certain other languages that some of you
might be familiar with.
But in C, if you pass an array as input, the function
doesn't have to know how big it is.
But you have to tell it how big it is by giving it a second argument.
And that's it for this use of square brackets.
We've used it to create the array, to access or index into the array,
and now to pass the array.
So square brackets almost always are going
to hint there's an array going on here.
I suppose we should run this to be sure that I didn't screw it up.
So make, let's do this.
Copy .src/scores5.
So we haven't shown you this yet, but if I have a file secretly called scores5.c,
and I want to rename it to scores.c, I can use the cp command,
for copy for short.
It's going to prompt me to overwrite scores.c Yes.
And so now, if I open what was always called ./scores,
I now have exactly the same file as we walked through a moment ago.
So let's run this now--
make scores ./scores 72, 73, 33.
And we still get the same correct average.
But now the code is arguably not only correct, it's better designed.
Even though things escalated quickly, because to make this code better
designed, I needed to generalize it to handle not 3, but ultimately,
any number of exams or scores by changing the 3 to a 4 or a 5 or 100
or anything else.
And heck, if we really want, we could ask
the user, how many scores do you have already by calling get in one more time,
and then avoid the constant itself.
Whew!
OK, that was a lot just to calculate a very bad score.
Questions?
Yes?
STUDENT: What happens if I try to access a point in the array?
DAVID J. MALAN: A really good question.
What happens if you try to access a point in the array that
hasn't been given a value yet?
We will see that actually soon.
You can go there, but you don't know what you're going to expect.
So just to be a little dramatic, why don't we
go ahead and have some delicious animal crackers?
Take a 10-minute break.
========================================================
========================================================
