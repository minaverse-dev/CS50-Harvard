[MUSIC PLAYING]

DAVID MALAN: All right, this is CS50.
And this week, we begin to introduce web programming.
That is still writing code ultimately, but whereby the user interface
is now going to be a browser, or even a mobile device ultimately.
To do that, we're going to introduce you to, first, some fundamentals of how
the internet works itself.
Then we'll transition to a language, but not technically a programming language,
called HTML-- hypertext markup language, followed
by another language, though also not a programming language quite yet, called
Cascading Style Sheets.
And ultimately, we'll reintroduce some proper programming,
so as to automate much of what we'll be now discussing.
But first, let's begin with what underlies the World Wide
Web, or web for short, which is the internet itself.
And it's perhaps simplest to think of the internet
as the underlying plumbing that allows us to get data from point A to point B.
So there's lots of computers in the world nowadays.
They are all physically connected somehow or virtually connected,
with wires or wirelessly.
And if you can imagine, each of those computers somehow
being able to talk to one another, that then
is our internet, an internetworked set of computers
that can somehow intercommunicate.
But it wasn't always that way, even though you and I
take for granted the fact that we can all talk electronically nowadays online.
Indeed, early on, there were only a few points
of presence on this here internet.
So, for instance, here is the United States in 1969,
when ARPANET was developing what we now know as the internet.
And there were only a few locations here, primarily on the West Coast.
And those universities initially were indeed able to intercommunicate,
sending the first emails, for instance, even before there was a worldwide web.
Eventually, some other universities came online--
Harvard, for instance, among them on the East Coast of the United States.
And then East Coast and West Coast were suddenly
able to intercommunicate, as well as with emails and the like.
But in order to get data from point A to point B,
so to speak-- in this case, West Coast to East Coast, not to mention
the rest of the world, once more and more servers were
introduced to this mix, we needed to somehow route the information.
And so one of our first terms of art today will be that of "routers."
Routers are simply computers, or technically servers,
whose purpose in life is to route information from one point to another.
Now, these servers might look a little different from your laptops and phones
certainly.
They might look different from your desktop PCs.
But they're still just PCs, computers that maybe have a different form
factor, a different shape, but that typically
live in what are called data centers, like big warehouses that
store lots and lots of computers.
Those computers have lots of cables that interconnect them
with other computers there, as well as other warehouses and data centers,
much like the dots you just saw on the screen.
But the software that those servers are running
give them the ability to route information
from one location to another.
So if I here am representing the server, essentially, these devices
need to decide when they receive some information-- an email, a web
page, or the like, does it go this way or this way,
or this way or this other way.
And they use software to figure all of that out.
Now, here, we have a visualization, in the spirit of using Zoom,
from some of our former teaching fellows who acted this out.
So if you can imagine a teaching fellow named
Phyllis wanting to send, say, an email to a teaching fellow
whom you might know, in fact named Brian,
well, Phyllis might put that message in some kind of envelope-- here, physical.
But think of it as virtual as well.
And she's going to hand that envelope off to the next router near her.
And maybe it's above, below, to the left, or the right.
But generally, this envelope is going to take some path from point A,
Phyllis, to point B-- no pun intended, Brian.
Let's take a look.
[GIUSEPPE VERDI, "BRINDISI FROM LA TRAVIATA"]

Wonderful.
So many thanks to CS50's team for making that visualization possible,
and how well it worked, getting the data up,
down, left, right from Phyllis to Brian ultimately.
But how were those teaching fellows-- how were those routers making decisions?
Well, in this case, we actually practiced quite a bit.
But in the real world, it's all dynamically
figured out via software in some form.
And the language that routers typically talk,
in order to figure out how to get from point A to point B,
is a language, or really a protocol, called
TCP/IP, which is technically two protocols
together that each do a little something different.
And in fact, let's focus on the one that's probably generally
familiar to many of you, namely IP.
So even if you're not a computer person, odds are at some point,
you've heard of IP, perhaps in the context of an IP address.
IP stands for Internet protocol.
And you can think of this as a language, or a protocol
to be more proper, that computers speak when trying
to send information between each other.
And a protocol is really just a set of conventions.
And so, for instance, in the human world,
much of it, if I were to extend my hand to you upon greeting you
for the first time, most likely, depending on where you're from
would know instinctively to reach out with your hand and shake my hand,
completing a human protocol.
So it's not so much a language that we're speaking,
but a set of conventions.
And indeed, that's what TCP and IP are.
But IP is very specifically focused on addressing servers in the world.
So what do I mean by that?
Well, it turns out that every computer in the world that's
connected to the internet has what's called, indeed,
an IP address, a unique identifier that typically is of this format--
something dot something dot something dot
something, where each of those somethings
is a number, a simple integer.
Those integers are typically 0 through 255,
which is to say that you have four values in a typical IP address that's
between 0 and 255.
If you're doing some mental math now, you might recognize those numbers.
Any time you're counting from 0 to 255, you're using 8 bits, or 1 byte,
which is to say that an IP address, as represented here
with these hash symbols, is 32 bits in total, or 4 bytes.
So your mind can immediately start to wander if you do some of that mental
math to conclude that, oh, it would seem that you can have no more than,
per past discussions, 4 billion IP addresses,
because 2 to the 32nd power gives us four billion,
especially if we don't have to worry about negative numbers,
which is to imply that there can only be 4 billion devices on the internet
in total.
Now that's a lot.
But there's also a lot of humans in the world.
And there's a lot of humans with multiple devices, laptops,
desktops, not to mention all of those servers and Internet of Things devices.
So the world not only uses this format nowadays,
which is technically called IP version 4.
There's also a new and improved version of IP addresses known
as IP version 6, which the world is starting to use,
especially some of the bigger companies and internet service providers
out there.
But odds are, your computer and my computer
still tend to use IPv4 for this format.
So we'll focus on this one, if only because you're
likely to see it in the near term in the real world as such.
So how does this all work?
Well, this is perhaps the most cryptic-looking diagram
I could find that represents exactly how IP works.
Now, this is ASCII art, and this is actually
a diagram from the specification, or RFC-- request for comments,
that defines how IP, the internet protocol, is supposed to work.
And what this diagram is implying is that, any time you
want to send a message over the internet, using this protocol called IP,
you first have to make sure that you write an address on the envelope.
And you write another address on the envelope that is your sender address
or source address.
And the way you do this, of course, is not something physical in an envelope.
But rather, you use a sequence of bits that
indicates what the source IP address should be
and what the destination IP address should be.
And then let me wave my hand.
There's a whole bunch of other bits being used any time you send information
on the internet, in addition to that source address and destination address.
So this, though, is essentially written on the outside of this envelope,
in this here way.
Now, what does that really mean?
Well, let me make this a little more concrete.
And just for the sake of discussion, suppose that Phyllis, in our example,
was sending indeed an envelope virtually to Brian, from point A to point B.
Then let's suppose for the sake of discussion that Brian's IP address is
a number like 1.2.3.4.
So metaphorically, what Phyllis would do--
or really Phyllis's computer would do is write
that IP address right in the middle of the envelope, just
like a human would when addressing a letter in the real world.
But so that Brian could potentially reply
to her, either with new information, or at least
to acknowledge receipt of this same envelope,
she's also going to put her IP address in the top left corner.
And maybe her IP address is 5.6.7.8.
Suffice it to say, I'm making up these numbers to keep them simple.
But they could be actual IP addresses because they
fall into that format of something dot something dot something dot something.
So now when Phyllis hands this envelope off to the person,
or the router next to her, that router can look at the same envelope
and realize, oh, this is going to address 1.2.3.4.
I might not be physically next to Brian, that IP address.
But I can at least hand it off to some other router
that might be closer to Brian, and therefore
know how to get it to him eventually.
And so what routing is all about is exactly that-- these servers passing off
metaphorically these envelopes back and forth, back and forth,
ideally getting them closer to their destination.
Now, unlike the real world, where the shortest distance between two points
is a straight line, you might recall that Phyllis didn't actually
hand that envelope up and to the right diagonally to Brian.
Rather, it went up and down, and it didn't necessarily
follow the shortest path.
But in the real world, routers might, at least ideally,
route data in the fastest way possible.
So even though they might traverse geographically disparate routes,
sometimes, because the servers are faster or less busy,
it might make more sense to spend a little more distance
to get the data there based on how the servers are configured.
And also, finances might be involved.
There's a lot of big internet service providers in the world.
The Comcasts, the Verizons of the world in the United States,
for instance, they might have relationships
with other internet service providers such
that they want to ideally keep data on their network,
so as to not have to pay fees to route the data on someone else's network,
so to speak.
So there's lots of ingredients that go into deciding
how to get the data from point A to point
B. But in general, it doesn't really take more than 30 hops, so to speak--
30 passings of the envelope from router to router, because at that point,
it's probably stuck in a loop if it's going
on for more than, say, 30 such hops.
So what's really written on the envelope is more arcane information like this,
but it's just patterns of bits.
So it's as though Phyllis was just writing patterns of zeros and ones
on this envelope that adhere to this pattern.
And then inside of the envelope is what Phyllis might actually
want to send Brian.
Now, what might that be?
Well, as you know, the internet is filled with cats.
And for instance, here is one such picture of a very happy cat.
Unfortunately, it's a pretty big picture.
And if you can imagine this being maybe a video instead,
it would be even bigger in terms of its file size, even more bytes.
And so what computers typically do is additionally
fragment information when they're sending it on the internet.
So rather than try to shove this big cat inside of that envelope, what
a computer would do-- even though this feels a little sacrilegious,
would be to tear happy cat in two, maybe even into four parts,
and then put each of these fragments inside of an envelope, followed
by another fragment inside of another envelope.
At that point, to be fair, Phyllis had better
address the second envelope as well, probably
with the same amount of information.
So she would probably put 1.2.3.4 on the middle of the envelope,
and 5.6.7.8 in the top of the envelope to indicate that this one too is
destined for Brian's IP address as well.
Unfortunately, once we start chopping things up into fragments like this,
it's no longer sufficient for the outside of the envelope
to indicate only the destination.
Because what if they arrive in this order or maybe this order,
or some other order altogether?
After all, there's nothing stopping Phyllis
from handing one envelope here and another envelope here,
so long as they eventually make their way to Brian.
So he's going to need a little more information in order
to reassemble this data at its destination,
and know ultimately just how many total envelopes were sent to him.
So how can we go about doing that?
Well, let me propose that we introduce another protocol
as well that will help us guarantee delivery of this information.
So there's this other protocol, TCP/IP.
And it's typically written or said in the same breath as IP,
such that we talk about TCP/IP.
But it's a separate protocol.
And TCP's perfect purpose in life is to solve a few problems.
For instance, among the problems that TCP does for us is,
it ensures that we acknowledge exactly how many envelopes were sent.
So, for instance, on the outside of this envelope,
we might write not only the destination and the source address.
But I'm also going to say something like 1 of 4
in the memo field of the envelope.
We don't often use this in the real world.
But if you were to, you could put it down there.
And then in the other envelope, I might write 2 of 4.
And so now, Brian, upon receipt of that, can see that, oh,
this is the second such envelope and.
I could keep doing this for number 3 and number 4.
And what this allows Brian to do ultimately,
is not only confirm that, OK, I got pieces 1 and 2 and 3 and 4.
He can also infer if he's missing any pieces,
lest he have a very unhappy cat that's missing an entire quadrant of that there
picture.
So TCP accordingly can help Phyllis guarantee delivery
by establishing an additional protocol on these virtual envelopes that
dictates that we also keep track of the sequence numbers of these here
envelopes, so that Brian can infer if anything has been missed.
Otherwise, he can acknowledge, thank you, Phyllis, I got all four of these.
But there's another problem that TCP solves
for us, which is that the internet itself
does so many different things nowadays.
We've got email.
We've got the World Wide Web-- more on that soon.
We've got video conferencing.
We've got streaming media, and so many other applications
that run on top of the physical infrastructure that is the internet.
So what else does TCP do?
It also defines a convention for what we're going to call ports.
A port is simply a unique numeric identifier
for a specific internet service.
And years ago, a bunch of humans decided to standardize
what these port numbers are.
So, for instance, a bunch of humans in a room decided that, you know what?
To uniquely identify worldwide web traffic, let's use port 80--
so the number, the integer 80.
But if it's securely sent, using not HTTP but HTTPS-- more on those also
a bit later, then it's going to use port 443.
And there's other numbers as well.
25, for instance, is commonly used for email.
53 is commonly used for DNS.
And there's other integers as well-- much longer list than the two
here on the screen.
What Phyllis can then do is, if she specifically
wants to request a web page of Brian, whereby
Brian is now not only the recipient, but a web server that has pages of content--
what Phyllis can do on the outside of this envelope is add essentially
a colon, and then a port number, such that now the destination is still
1.2.3.4:80.
And this indicates that when Brian receives this envelope, he as a server
knows that this envelope is destined for not the email server, not
the video conferencing server, not the streaming media server,
but rather for the web server that happens
to be running at Brian's location.
And in fact, this is because, as an aside, when we talk about a server,
a server, singular, can actually do multiple things.
A single server can handle email and web and video conferencing and more.
And so what these port numbers ultimately allow servers to do
is to multiplex, so to speak, or distinguish which server
or which type of service should be handling this inbound request.
So Brian replies with a web page, and not, for instance, an email or something
that's inappropriate like that.
Meanwhile, if we want to get our hands a little dirtier with the underlying
format of these things, even though I wrote it on the outside of the envelope
as just colon 80, what's really happening underneath the hood
is a little something more complicated like this,
whereby Phyllis would write not only a destination port,
but also a source port.
So it turns out, even Phyllis uses a unique identifier,
so that Brian knows how to address his response to her specifically.
And there's that sequence number and the acknowledgment number
that I alluded to earlier, whereby TCP ensures
that we can keep track of 1 of 4, 2 of 4, 3 of 4, 4 of 4.
So long story short, what TCP/IP together allow us to do
is uniquely address computers on the internet
as by using IP addresses in a standard way,
and to guarantee delivery of data between two points
by using the sequence numbers, as well as these port numbers, to make sure
that the data gets where it needs to go.
Now, I'm using "guarantee" a little bit generously.
If the internet goes down, the power goes out,
TCP is not going to get data from point A to point B.
But assuming the internet itself is working,
that is what these protocols together do.
But to recap then, with TCP/IP, we have this mechanism
for addressing computers uniquely, much like we do already in the real world.
And in fact, Sanders Theatre, for instance, is 45 Quincy Street,
Cambridge, Massachusetts, 02138 USA.
That is exactly what you could write on the outside of an envelope
to mail it physically to Sanders Theatre.
What we're talking about, then, with these virtual envelopes
is exactly the same idea, but in a way that
supports servers sending the same data.
And it turns out that just dealing with numbers, like IP addresses,
is much easier than full text, like things
on the outside of our own envelopes.
Indeed, imagine how much happier the mail service, the postal workers,
would be if all we were writing were very clean numbers
on the outside of the envelopes And they wouldn't
have to read messy handwriting with much more complicated strings of text.
All right, so it stands to reason, then, that this seems
to work, at least as I've told it here.
But of course, none of us probably use IP addresses explicitly every day.
In fact, when you go to a website, you probably
type google.com or CS50.ai or other such domain names.
And yet, here I am telling this story that, underneath the hood, a la Phyllis
communicating with Brian, everything uses IP addresses,
not to mention port numbers and sequence numbers,
on the outside of these envelopes.
Well, suffice it to say, your Mac, your PC, your phone
is somehow figuring out how to write those numbers on the envelope,
even though you and as the humans, are only
typing in actual domain names, like google.com, CS50.ai, and the like.
So how does that all work?
Well, in the world of the internet, there's other types of servers
out there as well, not just routers that route data from point A
to point B. There's also DNS servers as well-- domain name system servers.
And these typically live inside of your internet service provider's network
or on your university's campus or in your company's office,
or somewhere in-between you and the rest in the world.
And what a DNS server does, in short, is translate domain names to IP addresses,
so that you and I as humans can type the more user-friendly version of google.com
and CS50.ai And you and I don't have to worry about or figure out
what the underlying IP addresses are.
Now, it turns out the implementation of a DNS server
follows a familiar paradigm.
We've long talked about dictionaries now,
an abstract data type that allows us to associate keys with values.
Well, in the case of a DNS server, they essentially
have, inside of their memory, a two-column sheet or table,
the first of which is the domain name, the second of which is an IP address.
Technically, those domain names are called fully qualified domain names
because it might be something like google.com or www.google.com,
or some other subdomain therein.
So what you type would be in the left-hand column here.
And what gets written on the envelope would be in the right-hand column here
instead.
So now this table, you could imagine it being very, very big.
I mean, there's thousands, hundreds of thousands, millions
of domain names out there nowadays.
And surely, your phone in your pocket doesn't know about all of them.
But that's OK because the design of DNS is actually
to be very hierarchical, so that your internet service provider probably
has its own DNS server that can translate many domain
names to IP addresses, especially if they're popular ones.
And therefore, they have looked up the IP address
already in the past for their customers.
But if you visit a random website that's not very popular,
and no one has visited at all or recently,
your internet service provider can recursively
ask another DNS server for the answer to the question, what
is the IP address of that domain name.
And in fact, around the world, there are what are called root servers,
a small number of servers that, for instance,
know about all of the .coms and all of the .orgs and all of the .govs,
and similarly for other countries as well, whereby those servers--
even if they don't know the exact IP address,
they might know the IP address of another DNS server
who does have the answer.
And so long story short, if you've ever bought, or really
rented, your own domain name before, or if that's
something you choose to do in the future, essentially what you're doing,
when you pay someone some number of dollars per year to buy a domain name,
is asking them to add an entry to their DNS server,
or someone's DNS server, that associates that domain name henceforth
with a specific IP address of your server or servers.
So someone somewhere is doing that for you.
But the whole process is indeed recursive,
because if your ISP doesn't know the answer,
it can maybe ask another DNS server, or maybe these root DNS servers as well.
Your own Mac, your PC, your phone might itself
cache or remember these answers though, too,
because it's a little silly in terms of design
if your phone or your laptop or desktop has to constantly ask that same question
every time you visit google.com.
Odds are the IP address is not going to change,
or at least it's not going to change that frequently.
However, again, if you've ever set up your own domain name,
if you've ever moved it around or something has changed about it,
sometimes you can break a website by changing its IP address,
because there's lots of servers in the world that have cached--
C-A-C-H-E-D, or remembered the old IP address.
But thankfully, the other feature that DNS provides is expiration dates.
So essentially, the answer to the question,
what is the IP address for this domain name,
typically expires after a few seconds, a few minutes, a few hours, a few days.
Unless you really mess things up and say, don't expire this for a year,
then your website could, in fact, be a dead end somehow.
So this is worth knowing for future web developers doing
things in the real world.
So DNS, to recap then, simply converts domain names to IP addresses.
And technically, it can go in the other direction as well.
And so when you as a human go to a browser on a laptop, desktop,
or phone and type in google.com, Enter, or CS50, Enter, what essentially happens
is your device checks its local cache to see if it's already
been asked that question before.
And if it has, it just immediately knows the IP address,
writes it on the outside of the envelope, so to speak,
and sends out your data.
If it doesn't know the answer, your computer
is going to ask the local DNS server, which
might ask another DNS server, which might ask another DNS server.
But recursively, you will eventually get your answer
if that domain name actually exists.
And at that point, your computer can indeed
write the correct IP address on the outside of the envelope,
add any sequence numbers, add any port numbers.
And voila, it's on its way from point A to point B. So that, then, is DNS.
How about one other acronym that's a bit related here adhere too-- that of DHCP?
And let me assure that it's not really that important to memorize
what all of these acronyms stand for.
But rather, it is useful, I think, to generally know what they in fact do.
So DHCP is Dynamic Host Configuration Protocol.
So there we have it-- another protocol, a set of conventions.
And the purpose of DHCP is to actually give your computer
an IP address when it boots up.
This wasn't always the case back in the day.
If you've had internet connectivity for a while,
some technician probably would come to your house when you or your family
signed up for internet service.
They would probably have a sheet of paper
on which was your personal IP address.
And if you wanted to connect your PC to the internet,
they would type that IP address manually into your computer,
so that your computer knows what IP address
to use when talking to other servers.
That's not particularly scalable.
That's not particularly maintainable.
You don't want the technician to have to come out just
to make a change or something like that.
And you probably want to be able to use multiple devices as well.
And so nowadays, what most computers use is DHCP to dynamically figure out
what is their IP address.
And so nowadays, when you first open your laptop in the morning
or boot up your PC or take out your phone--
if you haven't used it in a while, and therefore it
no longer has an IP address, because these two expire
after some amount of time, your phone, your device
will broadcast a message like, what is my IP address?
And hopefully, on the nearby network in your home, in your company,
at your university, or in your internet service provider more generally,
you will hear an answer, oh, use the IP address 5.6.7.8, for instance,
in the case of Phyllis, or 1.2.3.4 in the case of Brian's recipient address
as well.
So the people who run these servers, the internet service providers of the world,
the system administrators at your company or campus,
they can come up with the rules via which these IP addresses are assigned
or who gets what number.
But ultimately, DHCP is just another protocol
that governs how your device gets its IP address.
But that's not quite everything.
It's actually neat.
DHCP servers also tell your computer what DNS server to use.
They give you the IP address of one or more DNS servers to ask questions of.
DHCP servers also tell you the IP address
of your default gateway, the router that you should use by default
to hand one of those envelopes to.
And this is indeed why Phyllis probably knew
to whom to hand that envelope in the first place,
because when she booted up, so to speak, she was assigned an IP address.
She was told what default gateway to use and the default gateway, a.k.a.,
router--
these are just synonyms, is the device to which she
should hand off data by default in order to get it from point A to point B.
So why do we focus on all of these acronyms, all of these technologies?
Well, on the one hand, they're omnipresent.
And even though you might not need to say these acronyms verbally
all that often, you're going to see them on occasion.
When something goes wrong, you're going to need
to troubleshoot things like this.
But more importantly, they're representative of very real-world
engineering problems that the world has had and encountered over the years.
But they're relatively simple solutions there too.
I don't necessarily know how I could write code
to implement a DNS server or DHCP server, and perhaps neither you.
But it sounds like a pretty simple idea.
If I have the ability in code to hear requests,
I can respond to those requests by maybe using
a dictionary in memory in the case of a DNS server,
and responding to those answers.
So this is to say all of the fundamentals,
all of the ideas we've been talking about throughout CS50
really are used as building blocks to solve
these very real-world, very omnipresent technologies that you and I now
take for granted every day.
Let's now consider one other protocol that's with us every day nowadays,
that of HTTP-- hypertext transfer protocol, which is indeed itself
a protocol, a set of conventions, that governs in this case how web browsers
and web servers intercommunicate.
It is very much related to HTTPS, which is literally the secure version
thereof that somehow uses encryption, somehow scrambles the data,
to ensure that when you're visiting a web page, you and only
you can see that web page.
And no one in-between you on the internet
actually knows what it is you're looking at
or the specific URL that you are visiting, beyond the name or the IP
address of the website itself.
So even though you and I probably don't even bother typing http:// or https://.
Odds are nowadays, you and I just type google.com, Enter, CS50.ai, Enter.
Or you click on a bookmark.
Underneath the hood, this protocol is everywhere.
And those prefixes, http:// and https:// are required when using a browser,
even though your browser automatically tends to insert those prefixes
automatically if you, the human, don't bother typing them yourself.
So they're used, of course, in URLs--
Uniform Resource Locators, which specifically
are the addresses that we use to get to useful information
on the World Wide Web, or web for short.
Here, for instance, is one of the simplest URLs we can talk about.
I'm going to use HTTPS deliberately to imply
that you really do want to try to use secure sites alone nowadays.
But this domain name would seem to be www.example.com, or that's
the fully qualified domain name itself.
But let's tease apart what's going on here.
Typically, in your browser, you might see a trailing slash, so a forward slash
at the end of it, which just indicates, albeit non-obviously,
that you want the default web page at that domain name.
In particular, you want to be able to access whatever the default content is
for that website.
Nowadays, though, browsers like Safari and Chrome, and even others,
tend to hide these details, just to simplify what
you're actually seeing in your browser.
But typically, if you click or double-click on the URL bar
in your own browser, you'll see more information,
including this trailing slash.
So if you only type in google.com, Enter, probably your browser
is automatically appending to indicate you want the default home page.
But sometimes there's more to the URL.
Sometimes it's /path, whereby path, I just mean a folder or a file name,
or something along those lines.
And that's more specifically referring to probably a directory on the server
containing some web page specifically.
Sometimes, it's more explicit.
Sometimes the URL might literally end in .html,
which is going to stand for hypertext markup language,
one of the first languages we'll soon look at in detail.
And that's the language in which web pages are written.
So this URL indicates that, at the server called www.example.com,
there is a file called file.html that this user wants to see in their browser.
Sometimes, though-- and it's not often the case
any more that you see these file extensions.
The world decided years ago that these are just ugly and not strictly
necessary technically.
So sometimes, you'll just see /folder/, which just means there's a folder,
a.k.a., directory somewhere in the server,
whose web page contents you want to see.
Sometimes, it's nested.
Sometimes, it's a folder, and then a file inside of which
is the web page contents that you want to see.
So in short, URLs generally follow this kind of format.
And there might be zero or more of these folders, and maybe
a file name explicitly or not.
But what else is going on here?
Well, here we have the fully qualified domain name.
And just to toss out a bit more jargon, technically, when you say "domain name,"
typically you mean something like this-- just the example.com.
Because the www in this context is generally referred to as a host name.
It's like the name of a specific server at a company,
at a university that is providing some service like this-- the world wide web,
a.k.a., a web server.
It is not strictly necessary for a server to have a name of www just
to be a web server.
For many years, MIT'S website was web.mit.edu,
whereas everyone else in the world was using www.
But odds are many of you are probably not
even the habit of typing www.something.something.
Rather you type in google.com and hit Enter.
And the browser somehow automatically brings you to www.google.com.
So the host name is the name of a specific server.
The domain name is typically just something like the example.com.
And let me disclaim, that's a bit of a white lie,
because if you're Google, if you're Meta,
if you're any of these big companies, you don't just have one web server.
So technically, the www refers to a collection of servers.
Maybe it's two, maybe it's 20, maybe it's 20,000 servers.
There are technologies that allow you to support that as well.
But lastly, there's one other piece of jargon that's worth knowing.
The last part of these fully qualified domain names
is known as the TLD, or top level domain.
And that is what generally historically indicated what type of domain it is.
In the US, .com means commercial, .gov means government,
.org means organization.
However, there are so many more top-level domains nowadays.
And in fact they're not US-centric.
And in fact, just because you have .com does not mean you are in the US.
It just means that you paid someone to use that there domain name.
In fact, there's other TLDs too.
Every country has its own-- .us for the United States, .uk for the UK,
.jp for Japan, and so forth.
Anytime the TLD is just two characters, that's a country code.
And yet that's curious, because we're in the habit of using cs50.ai.
There are websites that use .tv There are websites that use .io,
CS50 included.
And if you'd like to go down that rabbit hole,
feel free to Google "top level domain" or TLD and any of those.
And you'll actually see that, even though we are using cs50.ai to imply
artificial intelligence, .ai has nothing to do with artificial intelligence,
except that is how you can abbreviate it in English as an acronym.
It actually is a two-character country code.
And that country and others have decided to actually monetize
the TLD by selling it to, really, anyone who's
willing to pay per year to use that there TLD.
So lastly, within these here URLs, we of course, have the actual http or https.
And that dictates the protocol that is going
to be used when a web browser requests a web page at that there address.
Now, what does this protocol do.
It's similar in spirit, again, to a handshake, whereby a web browser,
when it wants a web page, it's like extending a hand,
hoping that the web server will respond and know what to do.
Of course, there's no such handshake physically here.
But rather metaphorically, the web server
should know how to respond, so long as the web browser standardizes
the message that it sends.
So what do I mean by that?
Well, let me propose that inside of this envelope can be one of two messages,
and this is a bit of a simplification.
But the first of those messages is GET.
And what GET means is literally, get me a specific web page.
By contrast, you can use POST inside of these envelopes.
And POST generally means to send information somewhere else.
And this too is an oversimplification.
But generally the word GET is used by a browser
when it just wants to get information.
The word POST is used when it wants to send information--
often sensitive information like a credit card, an email address,
a password, or any time you're filling out a form,
it's generally sent via the POST keyword instead.
And these are indeed verbs.
Like, GET and POST are both verbs in English,
implying that this is some here action.
Now dot dot dot means that there's other verbs that can be used inside
of these envelopes as well.
But let's be more specific.
Inside of the envelope that's being sent from browser to server
is more specifically a message like this.
So if I, with my browser, visit www.harvard.edu,
the message that goes inside of that virtual envelope,
as we discussed earlier, is literally text that looks quite like this.
So the cat is gone.
There's no more pictures of cats just yet if you're just
requesting Harvard's own home page.
But inside of that envelope is indeed GET / HTTP/2, for instance,
then HOST, then the actual host name or fully qualified domain
name that you are seeking, and dot, dot, dot.
There's some other stuff there.
But that's what's inside of that envelope.
Hopefully, what's going to come back from the server
is another envelope inside of which is a response.
So whereas the first message is a request to get something,
the response is indeed a response that hopefully contains the actual web
page that you requested.
And you'll see that the response might look like HTTP/2 200,
and then Content-Type text/html which just means that the web page is written,
indeed, in this language we're about to spend time with today,
HTML, below, which is the actual content.
So how can I actually go about seeing some of this?
Well, let me actually go over to VS Code.
And up until now, we've been using VS Code for the purposes of writing code.
But we do have this terminal window, and the terminal window gives me access
to an underlying operating system.
That operating system, recall, is called Linux.
And I have a command line interface here.
And up until now, I've been using this command line interface
for commands like cd and ls, make, debug50, Python, sqlite, 3,
and the like.
But there's other commands that typically come on a system,
including this one, that allows me to make internet requests as well-- not
even with a browser, but textually.
Moreover, there's always been-- even though I generally
hide it during class, a second tab, namely ports.
And if you yourself look at cs50.dev after logging in,
odds are you will see a ports tab, among others.
And what you'll see here is that, all this time, CS50's own development
environment has been using by default a TCP port number, namely 1337, which
is a very elite number for us to use.
And that is the port number that's used by CS50's customizations of VS Code.
Our so-called extension uses that TCP port number,
so that when our extension is talking to VS Code,
it uses a standard port number on the outside of its own virtual envelopes,
if you will.
You, as users, don't need to care about that.
But that's why that tab all this time, if you've seen it,
has had numbers in there.
And soon, we're going to see some additional numbers as well.
But if I go back to my terminal window here, I of course could type commands.
And one of the commands I could type is actually this.
Let me increase the size of my terminal window.
Let me go ahead and type curl, which means connect URL, dash capital I.
And now let me go ahead and type in https://www.harvard.edu/.
So I'm going to manually type this into my terminal window's command line
interface and see what comes back.
I'm going to hit Enter, and I get a bunch of stuff back.
That's why I used a dot dot dot on my slide a moment ago.
But in this output is some familiar text now.
One, we saw this line earlier on my slide--
HTTP/2 and then some number 200.
And then there are other lines here that I waved my hands at earlier
because they weren't strictly necessary, including the host line.
If this server is only doing one thing, we
don't even need to clarify that this is www.harvard.edu.
But what, then, is this HTTP/2 and this 200?
Well, it turns out that the 2 is just the version of HTTP
that my browser or my keystrokes were using a moment ago.
1.1 is a common version number.
2 is a common number.
3 is catching on over time.
But this just indicates what version of the protocol
the browser and server are speaking, even though this browser has
no graphical user interface.
It's just a command simulating an HTTP request to get back these headers.
And that's in fact what dash I means.
Show me just the headers.
I don't want to see any cats or Harvard News.
I just want to see the headers inside of the envelope.
But it turns out all this time, for as many years as you've
been using a browser, you could actually do this in your own browser as well.
Let me open up another tab here.
And let me manually go to https://www.harvard.edu/enter.
And what I'll see here is Harvard's home page as of right now today.
It all worked, as you might expect.
But it turns out all this time, you've had access
to some powerful tools underneath the hood.
Let me actually right-click anywhere on this web page and select Inspect.
And that's going to open what are called developer tools in the context
of my browser, which is Chrome.
Most every browser nowadays--
Safari, Edge, and others, have similar-looking tools,
though you might have to access them via different menus.
And in fact, in Chrome, you can also go up to the dot dot dot menu
and find your way to developer tools.
There's a lot going on here.
But what I'm going to do is go to the Network tab here for a moment.
And I'm going to zoom in, just for the sake of legibility.
And notice here that, when I clear this Network tab,
this is giving me access essentially to a log of everything that you're
about to see on the screen.
And notice, it just undeleted itself.
Apparently, Harvard is doing something behind the scenes every few seconds,
which is why that row reappeared, because indeed, I'm
trying to record my network activity.
But let's go ahead and do this.
Let me clear that one more time and reload the page.
And so many rows just flashed across the screen.
In fact, in the bottom left-hand corner, you'll
see that my browser, unbeknownst to me, made not one, but 67, HTTP requests.
That's how many envelopes essentially went back and forth between my browser
and harvard.edu a moment ago.
Here comes another.
And if we just keep this open, it's going to come again and again.
Harvard is keeping the page alive.
But let me zoom out and scroll back to the very top of this,
and focus on just the first page I requested and click on www.harvard.edu.
And let me click on Headers here.
What I'm seeing is diagnostic information, if you will,
about what I just did.
And you'll see that the URL I requested was indeed this thing here.
I used a request method of GET.
Unbeknownst to me, GET is what is used by default.
When you just type a URL and hit Enter.
Then the status code that came back, ah, there's that 200.
So it turns out that what web servers and browsers have done over the years,
thanks to HTTP, is they have standardized what these numeric codes
are to indicate success or failure.
In the world of programs that you and I have been writing,
we typically use 0 to indicate success, and maybe 1 or 2 or some other integer
to indicate failure.
In the context of the web, it's the same idea.
But the web uses 200 to indicate success and other numbers to indicate failure,
or something else happening as well.
Well, what else can those status codes represent?
Well, let's take a look here.
Notice that when I'm in my browser, and I
go to simply harvard.edu with no https, no colon slash slash,
no www, no trailing slash, Enter.
It all just works, and brings me to the intended place.
Now, why is that?
Well, at the lowest level, we can actually
see this in our command line interface.
Let me go back to my terminal window, which I've still full screened.
And let me type this time curl, dash capital I,
and then simply http://harvard.edu.
So I'm going to help the program a little bit
and provide it with the protocol.
But I'm not going to provide it with the secure version.
I'm not even going to mention www.
Let's see what comes back.
Ideally, it's a 200 OK because that's what means success.
But what I see here is, weirdly, that harvard.edu has moved permanently.
And this time, the status code-- coming back from an older version of HTTP
in this case, 1.1 instead of 2, apparently has a status code of 301.
So it turns out that different types of responses
indeed have different numbers associated with them.
And 301 means moved permanently, a sort of redirection, if you will.
And where is Harvard's new location?
Well, if we scroll down among these headers,
you'll see that, oh, the server is additionally telling me
that the location to which Harvard has moved permanently
is https://harvard.edu.
OK, so what this seems to indicate is that Harvard server really
wants me to stay on the secure version of the website.
All right, so let me go ahead and highlight and copy that.
Let me go ahead and do curl, dash I, and that URL, so almost the same,
except for the https this time and the trailing slash, and hit Enter.
But this time too notice--
and this time, the server is using a newer version of the protocol.
We're back to version 2.
It's still telling me 301.
It's not berating me by saying, move permanently again.
But 301 is enough for, me, the browser to know, oh,
Harvard's website is now at this location, www.harvard.edu, again using
HTTPS.
And so OK, let's do this one more time.
Let me go ahead and copy that URL, and do curl, dash I, and that full URL.
And now we're back to getting a 200 OK.
So among the reasons that your browser is able to figure out what you want
is because, one, the server might be telling it, no, go here.
No, go here.
OK, now you're in the right place.
And frankly, browsers nowadays, in cooperation
with servers that are configured in a certain way,
will tolerate you typing in only harvard.edu,
and just know proactively, no, no, no, no, no.
You don't want that.
You want HTTPS and you want the www because the browser, for instance,
has seen that response before from the server.
But at the end of the day, it's really just these status codes
that are enabling us to actually forge these responses.
So we've seen a couple now.
We've seen 200 for OK.
We've seen 301 for moved permanently.
There's bunches of others as well, including, for instance, this one here.
Odds are, most everyone here has seen 404 at some point in their lives.
I mean, it's in the human vernacular.
We all know that 404 means file not found.
Like, the URL is wrong, the file was deleted, something is missing.
That's a little weird that we as humans have been acclimated
to a fairly esoteric HTTP status code.
But that's all it is.
If you visit a web page that simply does not exist,
you will get back not 200, not even 301.
You'll get back a similar header like this saying 404, file not found.
Now, you might see a web page, and it might be a cute web page
or it might be a black and white text only web page.
It depends how the web server has been configured to show you that information.
But 404 indeed means file not found.
And here is a non-exhaustive list of other status codes.
We've seen 200 OK, 301 OK.
There's other 300-level status codes that generally refer to redirecting
the user from one URL to another.
The 400s generally indicate user error, like your fault, my fault.
So 401 is unauthorized.
403 is forbidden, like you haven't logged in properly.
404 is not found.
418 is actually an April Fool's joke from years ago.
"I'm a Teapot."
It was a funny joke among engineers.
More on that if you Google it, if you'd like.
500 range errors mean server error.
So someone screwed up, maybe not you.
But frankly, in a couple of weeks time, when
you're writing web-based applications yourself, any time you see a 500,
it is your fault also.
So you are both the user and the server in that there case.
But long story short, the way these things work
are simply underneath the hood via these status
codes, which really are being sent virtually inside of envelopes
like these.
Your browser is generally hiding that detail
because normal users don't need to care about this level of detail.
But you've always had the power of opening your own browser's developer
tools and poking around and seeing these things.
And all I'm doing in my black and white window
here with curl, which connects me to a URL using a command line interface,
is showing you even more in detail what's inside of those envelopes.
But it's just another way of viewing the same kind of information.
Now, we can actually have a little bit of fun
with this, with a smile and a wink to our students at Yale
who are perhaps watching this now.
It turns out-- has anyone ever been to this URL here, safetyschool.org?
I'll zoom in here in a new tab.
Has anyone applied to safetyschool.org or visited safetyschool.org?
Well, we love them equally.
But it turns out, if you go to safetyschool.org,
you end up at this here website, which if I zoom back in,
is apparently https://www.yale.edu.
So what is going on there?
Well, I could open my developer tools.
But let me use my newfound command line skills and do it here-- curl, dash I,
http://safetyschool.org, Enter.
And you'll see that, oh, safetyschool.org has moved permanently
to yale.edu's own website.
So this is a practical joke that has lived on the internet for years.
There is someone out there--
I don't know who they are.
They have been paying an annual fee, for years now,
simply to have this esoteric joke for us computer scientists.
There are ones for Harvard as well, in all fairness.
But this is one that's perhaps been around the longest.
So somewhere, there's a Harvard alum who's getting older and older
but is still paying this bill year over year since the web was invented.
All right, we're back.
And we now focus on HTML-- hypertext markup
language, which is the language in which web pages are written.
It is not a programming language.
And as such, we won't need to spend all that much time on it,
because the basics of HTML are fairly straightforward, even though it
has a decently large vocabulary, different features that you'll
pick up invariably over time.
What HTML does have fundamentally are what are called tags and attributes.
These are the basic building blocks of the language.
And what the language looks like is this.
So here is perhaps the simplest web page that I could come up with, a "hello,
world" web page, if you will.
And it's just text.
It is text that's typically stored in a file like index.html for short.
And in that file would just be these lines of code.
And these lines here are going to indicate
to the browser what it should do upon receipt
of an envelope containing this message.
Now how are we going to go about serving up this content?
Ultimately, we just need to put this content on an actual web server.
Well, it turns out you already have a web server, even though you
haven't been using it as such.
In other words, when you visit cs50.dev, and use VS Code in the cloud,
you're obviously using a browser.
But you're less obviously using a web server
that is serving up a copy of VS code to you in that browser.
But the caveat there is that by default, you've
probably been in the habit of typing cs50.dev, Enter.
And you've probably noticed, if not prior to today, then after today,
that the full URL ends up being https: //cs50.dev/ and then maybe some other
stuff after that.
But implicit in that URL is one of those port numbers
that we saw in TCP, either 80 or 443.
Because it's HTTPS, it's actually the latter, 443,
which indicates implicitly that there must be a server on cs50.dev that
is listening for requests, and is serving up that version of VS Code.
In fact, we eventually redirect you to GitHub's version
of VS Code, a.k.a., Codespaces.
But the idea is the same.
And in that URL, you have a web page that's being served up to you.
But it's already running on port 443, and perhaps 80, which is to say,
if we want to come up with our own web server,
we could start up our own server, connect it to the internet,
give it an IP address, and then communicate
with it using port 80 or 443.
But it's actually a lot simpler to embrace the reality
that any server can have multiple services,
be it web or email or video conferencing or the like-- or heck,
two different web servers.
And so even though VS Code in the cloud is already
running a web server, because that's indeed how it works,
there's nothing stopping you and me from, inside of VS Code,
starting a second web server, so long as we choose a different port number--
a different TCP port that's not already being used by the server itself.
So how are we going to do that?
Well, we're going to introduce you to a new command today,
called quite appropriately HTTP server.
This is a command that you can run in your terminal
window that will start your very own web server by default on port 8080.
8080 isn't that special, but it tends to be a convention.
Whenever you want to run a web server on a port other than 80 by default,
you would just use 8080 as a go-to.
But it could really be any number within a large range.
Now, this HTTP server command is going to allow
me to serve up some actual content.
What might that content be?
Well, let me go ahead and do this.
Let me go ahead and run code, index.html.
And let me go ahead and whip up a very simple web page here in.
And I'll explain in just a moment what these lines are.
But let me go ahead and just transcribe it in this here file.
So angle bracket exclamation point DOCTYPE HTML close bracket.
Then I had HTML lang equals, quote unquote, "en."
Then I had head.
Then I had title.
And inside of that title, I had "hello, title."
Below that head, I had open tag body, inside of which I had "hello, body."
So there's a lot of weird stuff going on here if you've never seen this before.
But I think I have recreated the file you just saw in slide form a moment ago.
What I'm now going to do is try to view this file inside of my browser.
But to do that, I need to do this.
I'm going to go ahead and run http-server, Enter.
And a whole bunch of stuff is going to appear in my terminal window--
some diagnostic output, a URL, and the like.
But in particular, I'm going to get this little pop-up that's
telling me, oh, my application running on port 8080 is now available.
This is just a user-friendly feature of VS Code, specifically
CS50's own extension therein, that allows me to click Open in browser.
I immediately get a second tab inside of which
I see the contents of my code space at this moment in time.
Now notice, to save myself some time today,
I've downloaded in advance a src8 folder inside
of which are a lot of today's examples, if I so need them.
And there's a file I literally just created called index.html.
What you're seeing here is a directory index of my current folder.
So this is a dynamically automatically generated
web page that's simply showing me in a web browser what
is inside of my code space.
Now, what's my URL?
Well, it turns out it's going to be something
that ends in GitHub.dev, which is a domain that GitHub itself controls.
So that's going to be generated for me automatically.
It's not a domain name I had to buy or sign up for.
And it's really meant to be temporary, because I'm
going to use my code space as a development environment
to develop web pages.
But most important for now is that, indeed, this server program
is running on localhost, which is a nickname
for the local computer, no matter what its actual name is, specifically
on port 8080.
And this is why I'm now seeing my folder instead of VS Code.
This tab has port 8080.
This tab would appear to have port 443, which is GitHub's own web
server running at this domain.
Now I'm going to go ahead and click my index.html.
And we will see what the simplest web page in the world might look like.
And voila, there is my "hello, body," which is the only thing in this
otherwise big white rectangular region, otherwise known as the viewport
of my browser.
And if I zoom in at the top here, you'll see that my title of my tab
is indeed what we saw earlier--
"hello, title."
So long story short, even if you're completely new to developing web pages,
clearly we have the ability, with this language called HTML,
to indicate what the title of a page should be in its tab
and what the contents of its body should be,
as underwhelming and as black and white as all of this might be.
Well, let me go back to my sample code here, and let's
now actually introduce some building blocks here in.
So what is actually going on?
The first line of code that I type that you see highlighted here
is the page's so-called document type declaration.
That's a silly mouthful.
But it's really just a standardized line of text that says,
hey, browser, here comes a web page written in HTML--
specifically version 5 of HTML, which is what most of the world is now using.
Odds are this line of code will change over time,
but for now, this is what we have.
Below that, things get a little more interesting and a little more symmetric,
if you will, and no more exclamation points like you see in this first line.
That's a bit of an anomaly.
Down here, you'll see what I'll describe as open bracket html, then the space,
then lang equals, quote unquote, "en," then close bracket.
And by open and close bracket, I mean a less than sign
and a greater than sign, respectively, which you can type on your keyboard.
What this is doing is the following.
This is the beginning of an HTML element, as we might call it.
And the tag here for this element is called HTML.
So anything immediately after a less than sign is the name of the tag.
And the way that browsers work is by relying on these tags to know what to do
and where within the confines of the browser.
So you can think of this first tag as saying, hey, browser,
here comes some HTML.
Now, what is that HTML all about?
Well, this thing here highlighted lang, short for language,
indicates what human language is presumably
going to be used throughout the rest of the page.
All of the tags, all of the attributes, for better or for worse,
are going to be in English, because the language HTML itself was standardized
by English-speaking people.
You can write web pages with your own content in any human language.
In this case, I have opted to write my page, as simple as it is,
in English as well-- "hello, title" and "hello, body."
And the "en" attribute value here, so to speak,
is just a clue to the browser that, in case you've got Google Translate or any
kind of automatic translation, this is a little hint as to what the human
language is to facilitate automatic translation or search engine
optimization--
SEO, or the like.
But that whole thing started the HTML page.
Now we have a sequence of other tags.
Hey, browser, here comes the head of the page, which metaphorically
is like the very top of the page here, a.k.a.,
the tab that we looked at a moment ago.
Hey browser, here comes the title of my page.
What's the title?
The title is "hello, title."
Now things are a little weird.
The next line of text here is open bracket, title, close bracket.
And whereas therefore, I might call the previous tag the open tag or the start
tag, this one here now would be the close tag or the end tag.
So there's a symmetry here that effectively
is conveying to the browser, hey, browser, that's it for the title.
The title is now complete.
What comes next?
Hey browser, that's it for the head of the web page.
Nothing left in there.
What comes next?
Hey browser, here comes the body of the web page--
everything else.
The big contents of that white rectangular region
is the so-called body of the page.
Hey browser, here's the contents of the body.
Hey browser, that's it for the body.
Hey browser, that's it for the HTML itself.
Now notice, the indicates the end tag or the close tag.
And you don't need to be super verbose.
Even though my HTML tag started with a language attribute, lang equals,
quote unquote, "en," you don't need to repeat the lang.
You don't need to repeat the quotes or the en.
It's obvious to the browser that this is closing the previously opened HTML tag.
Now, in general, the tags you're seeing should exist in one and only one place.
You must use these tags in certain locations.
We will soon see bunches of other tags that you
can use zero or more times to structure the actual contents of your own page.
So how do we get into that?
And what are we ultimately doing?
Well, what we really have is, in this HTML code,
a textual representation of a tree, one of our now-familiar data structures,
whereby there's a root of this tree that has
some number of children that might have some number of grandchildren
and so forth.
And so depicted here at right is what you might call a document object
model, or DOM for short, which is actually what the browser is probably
doing in its own memory, or RAM, when it accesses a web page.
In other words, if you type in google.com and hit Enter,
you immediately see the contents of Google's website in your browser.
What Google has probably done is sent text that looks like this,
but more complicated than this simple example.
That text is read top to bottom, left to right by your browser,
and loaded somehow into memory, using malloc or other techniques like that,
to create bunches of nodes in memory with a lot of pointers that somehow
represent this tree structure in the computer's memory
so that it actually knows what to display on the screen.
So with that said, let me go back here to VS Code.
And I'm going to go do a sequence of examples now.
And I'm going to go back to the code, and then back to my browser
to show you exactly what's going on.
Recall that at this moment in time, the only two things I have are
a source 8 folder, which I came with by default today
in advance, in case I need to copy-paste anything,
and index.html, which I just created for the first time.
So let me go back to my VS Code tab here.
And you'll notice that, in my terminal window,
there's actually a bunch of logging information, diagnostic information.
Long story short, anytime anyone visits a web server with a browser,
odds are the server is logging that visit.
In fact, this is how companies know.
This is how internet service providers know.
This is how parental controls know what websites
you are visiting, because all of this information
is going back and forth between browser and server.
Here, because I am running the server via that HTTP server command,
I now get access to all of this juicy information,
including the browser that the user is using,
what day and time they visited my page, and so forth.
But for the sake of discussion, I'm not going to really care
about this diagnostic information.
I'm going to hide this for the most part.
But notice 2 under ports now, whereas previously
I only had one TCP port in use--
1337, which is CS50-specific, now notice that VS Code
has detected that I'm running something else on port 8080.
So you see a second port there.
And you might over time, if you open more and more tabs,
see even additional ports as well.
That all happened for you automatically.
So for now, I'm going to go ahead and hide my terminal window because I don't
really care what's going on there.
But that's still going to keep HTTP server for me running in the background.
Let's go ahead and introduce some new tags.
So for instance, let me go ahead and create a new file.
Actually, let me retract that.
Let me open my terminal window.
And instead of showing the log, let me create a second terminal window
with the plus icon.
So I'm still running the other one with the command,
but I still have the ability to run commands now in my here prompt.
For instance, I want to run a command--
code paragraphs.html.
Let's go ahead and create a more interesting web page
with actual paragraphs of English or other type of text.
To save myself some keystrokes, I'm going to be in the habit today
of copying the "hello, world" example as a starting point perhaps,
and then just changing it as needed.
For instance, I'm going to change the title of this here page to "paragraphs."
And then in here, I'm going to type out some paragraphs of text.
Now, what are those paragraphs.
Well, I wanted to save some time.
So in advance, I generated some Latin-like text here.
So I can copy paste three long paragraphs of Latin text, some lorem
ipsum text here.
Now, it doesn't matter what this means.
It's nonsensical words.
But this is a web page that is going to have ultimately
some paragraphs of text--
not English but fake Latin.
So let's go ahead and open this.
Let me go back to my other tab.
I do need to reload this tab because I've
created a new file that this browser didn't know about before.
There it is, Paragraphs.html.
Let me go ahead and click now paragraphs.html.
And there are my three paragraphs.
Well, wait a minute.
This is just like one big blob of a paragraph instead of the three
paragraphs that I was promised.
Well, why is that?
Well, let me go back to my editor here.
And you'll see that even if I hide my terminal here,
even though I've got these blank lines, clearly the browser is just ignoring me.
And this is because HTML is pretty pedantic.
It is designed to only do what you tell it to do.
And so if you don't tell it explicitly, give me a new paragraph,
it's just going to combine adjacent texts, as we've seen already.
So how do I do this?
It's actually pretty simple.
Let me go into my body tag, and let me actually open a paragraph tag,
or p for short.
Now notice, VS Code is trying to be helpful by automatically
completing the rest of this thought by giving me both a start tag and an end
tag.
In this case, that's not really helpful because I already
have the text that I want to put inside of this paragraph.
So I'm going to go ahead and delete the close tag manually.
And I'm going to move over here and close this myself.
And just to be stylistically nice, I'm going to go ahead and indent that.
Now down here, I'm going to do one more paragraph tag, p for short.
I'm going to cut that out.
And I'm going to paste this in here.
And again, I'm fighting with the autoformatting
because it is trying to understand what I intend,
even though I'm going back and fixing this now.
Let me fix that.
Let me go down here.
Let me go ahead and fix this now, indent here.
And voila, now we've got three paragraph elements.
And to clear, an HTML element is generally
everything between a start tag and an end tag.
So I have three paragraph elements-- p for short.
Why is it only p?
Well, the designers of the HTML language years
ago decided, why write out paragraphs, when open bracket, p, close
bracket suffices?
So let's now go back to my other tab.
Now, I see nothing changed.
But again, that's because I already received
the virtual envelope in my browser that contained
the previous version of that page.
If I want to get a new copy of paragraphs.html,
I need to reload this tab.
And now I see the same text, but broken down into three separate paragraphs.
So this is just to demonstrate the point that, if you want something to happen,
you really need to tell the browser to do exactly that.
Well, let's introduce some other tags too.
Let me go back to my editor here.
Let me go ahead and open my terminal window,
and let's create something called headings.html.
Much like a book, much like an academic paper,
you might have section headings, like the chapter and the section
and the subsection and so forth.
We can actually implement this with some HTML, too.
So let me cut a corner here, and copy and paste paragraphs.html
into headings.html.
Let me hide my terminal window.
Let me change the title here just to be "headings,"
to be super-explicit as to what's going on.
And let me go ahead now and say H1 One.
And down here, let me say H2 Two.
And down here, let me say H3 Three.
Now, these are three new P tags--
H1, H2 and H3.
By definition, H1 is typically big and bold.
H2 is typically not quite as big, but still bold.
H3 is not quite as big still, but still bold.
And these are the default stylizations of these here tags that come with HTML.
Let me go back to my other tab.
Let me click back.
So I now see my new file, headings.html.
Let me click on headings.html.
And now, even though it's still nonsensical Latin-like text,
at least it's starting to look pretty.
It looks like a chapter of a book with some sections and subsections
and so forth.
That's because the browser now understands what it is I want of it.
Now, you could simulate this by just literally typing
the word One in its own paragraph, the word Two in its own paragraph,
the word Three in its own paragraph.
But it wouldn't be bigger and it wouldn't be bolder.
And when it comes to the semantics of web pages,
it's probably useful to use tags, in this case, like H1, H2, H3,
because it indicates the relative importance of the text.
Like, this is the beginning of the text, this is maybe some finer detail,
and then this is the finest detail.
It might actually help search engines-- or heck, even AI nowadays,
understand that these are different sections in your text.
And we'll soon see, there's even other tags
you can do to be even more helpful to the browser and search engines and AI.
Well, how about something else?
Let's move away from big blobs of nonsensical text,
and let's do something with a chunk of nonsensical lists.
Let me go into my terminal window.
Create a new file called list.html.
And let me copy-paste my Hello code from earlier, just to save some steps.
And let me go ahead and rename the title to "list" in this case.
And let's just have a list of three things-- foo bar and baz.
If you've never heard these words before,
they're go-to computer science words when you just
want some random placeholders.
They mean nothing per se.
But foo, bar, and baz are go to default words like x, y,
and z for mathematicians.
All right, this looks like a nice, pretty list.
I've indented it, which looks great.
But if I go back to my other tab, hit Back, and I click on list.html,
I think you probably know where this is going.
Just like the paragraphs, we just get one big paragraph of "foo bar baz."
We don't get "foo" on one line, "bar on the next line, "baz" on the third.
Well, why is that?
Well, just as before, the browser seems to be ignoring whitespace,
beyond single white spaces.
In fact, I can try to be really explicit, like, please give me
some breaks between these lines.
But if I go back to my other tab, click Reload,
it just canonicalizes multiple spaces into a single space,
for better or for worse.
So if I really want a list, I need to tell the browser that I want a list.
And one way I can do that is as follows.
Let me delete that temporarily, and let me
do UL for unordered list, which means I'm
going to get a bulleted list with little circles next to each word.
Let me then use an li tag for list item and type "foo" inside of the first.
Let me type another li tag and "bar" for the next one,
and then a third with "baz."
And again VS Code is autocompleting, which
is why I'm able to type the close tag so quickly.
But I've got now foo, bar, and baz inside of li tags,
which in turn are inside of.
A UL tag.
Now let me go back to my other tab.
Click Reload.
And now we have a bulleted list of items, one at a time.
Well, what if I want to number this list?
Well, I could certainly just go in here and start manually
writing 1 and 2 and 3.
But you could imagine that getting a little annoying over time,
because if you need to reorder the list or add things to it,
it's just minorly annoying to have to maintain numbers for lists of things.
Like, this is what software is good at.
This is an easy fix.
And you might guess where I'm going with this.
If I want to move from an unordered list, which is just bullets
by default, to an ordered list, which is numbered,
I can change the ul to an ol in both places,
so that my start tag and end tag still match.
I can go back to my other tab, click Reload.
And what's going to happen by default now is, ah, I get 1 and 2 and 3.
And long story short, there are actually techniques
whereby you can change this behavior using attributes
to not just be these Arabic numerals.
But you can use Roman numerals or other symbols
that browsers are designed to support.
And it all just happens for you, which is great,
because if you're writing something like an outline for a paper or the like,
you don't really want to have to think about all of those numbers.
Just like Google Docs and Microsoft Word,
the software should figure that out for you.
And indeed, HTML can do just that.
All right, how about one other here this time.
Let me go ahead and cut a corner and open a file I created in advance, just
to save a few keystrokes.
Let me close most of those files for now.
Let me go ahead and copy from my src8 directory
a file I brought with me called table.html.
And let me open this up in its own tab.
And you'll see this file here that demonstrates a table.
And indeed, I know that, because I have atop this file
that I wrote in advance something called a comment.
We've seen comments in C with slash slash.
We've seen comments in Python with hash symbols.
In HTML, a little weirdly, you can write comments
with open bracket, exclamation point, dash dash.
Then you write your comment, and you finish your thought
with another dash dash, close bracket, but no additional exclamation point.
Why these keystrokes?
Well, the humans who designed this probably
figured, who is ever going to type that sequence of keystrokes?
Like that's what we'll use for our comments tag.
As an aside, if you ever actually want to write those patterns of characters,
there's a way to escape those things, as we've seen in other languages as well.
But let's focus on the juicy part here.
What's inside the body of this here page.
Apparently, something called a table.
And a table, by that we mean tabular data, like in a spreadsheet
or in a database table.
TR, I'll tell you, is short for table row--
tr.
TD is a little less obvious, but it's short for table data.
So it's like the cell in that row.
And the fact that there are three table data elements inside of this one table
row element means that there's going to be three cells, or really three columns,
from left to right inside of this row.
Below that is going to be another table row, inside of which
are three more cells, 4, 5, 6, as their contents, then 7, 8, 9, then curiously,
an asterisk, a 0, and a pound symbol.
So where are we going with this?
Well, if you're imagining in your mind's eye, a telephone that
has buttons and labels, it seems like I've just
been laying out rows and columns of numbers
you'd see on your cell phone or an old-time landline phone.
Well, let's open this.
Let me go back to my other tab.
Click Back.
Now you see table.html.
And this isn't going to be all that pretty, but it is tabular data.
And if I zoom in with command-plus here in my browser,
you can see that this is laid out rather like a phone pad.
Now, this is not a super-compelling use.
But you can imagine actual tabular data--
maybe data that came from a database, or maybe Google
in fact, when they implemented Google Sheets, or Microsoft when they
implemented office 365 in the cloud for Excel, maybe
that's how they're laying out all of your data in your browser
as it is underneath the hood.
They are using, of course, HTML, but specifically table tags like this.
Now, as an aside, they're probably doing even fancier things than that nowadays,
but they certainly could use TR tags, TD tags, and these table tags as well.
All right, enough about text.
Let me actually go back to VS Code here.
Let's close table.html, and let's do something with an image.
In fact, let me go ahead and grab a file called maybe bridge.png,
which is a Portable Network Graphic version of the bridge, with which you're
now familiar, that we ran a number of filters on in the past.
And this is now in PNG format, because BMP format, which
we used in a previous problem set, tends not to be used on the web
or supported necessarily by browsers.
But PNGs are, GIFs are, JPEGs are, and potentially a few other formats as well.
So I'm pretty good going with Portable Network Graphics.
We're good to go.
So let's create a web page that actually includes
this image, because at the moment I'm just showing you the image.
I'm not actually embedding this image in a web page,
like Google or other websites would.
So let's do this.
Let's close that tab.
Let's open a new file called image.html.
Just to save some keystrokes, let me copy-paste my "hello, world"
example again, changing the title to "image."
And in the body of this page, instead of any text,
let's actually put an image from Harvard University.
Let me go ahead and use open bracket IMG for short, source equals, quote unquote,
"bridge.png."
So in this case, we have a couple of new things going on here.
We've got a new tag, of course, IMG, which is short for image.
Why?
It was just faster to type for humans than "image."
So they called it three letters instead of five.
Source is representative of another attribute.
We saw an attribute earlier, lang equals en.
Well, it turns out that the image tag, if you read its documentation,
or listen to me now, has an attribute called source--
src for short, that allows you to specify the source of an image
that you want to display in the page.
But somewhat differently here, the image tag that I've written
has no close tag, no end tag.
I could do this--
open bracket slash image.
But frankly, this seems a little unnecessary, if not confusing.
And it is technologically unnecessary.
It turns out that some tags can be empty in the sense
that they don't need a close tag.
And an image makes sense.
Unlike a head of the page, the title of a page,
the body of a page that start over here, and maybe
end down here, an image is either there or it's not.
You can't start showing the image and eventually stop showing the image.
it's either there or it's not.
So you don't really need an end tag for certain start tags.
An image is among the examples.
If now I go back to my table here and click Back to see my directory index,
there is not only my PNG, but also my image.html page.
And if I click on this, it's not all that
different from looking at the image itself.
But apparently, this is a pretty high-resolution photograph that we took.
I haven't done anything to resize it.
And so what I'm seeing is a web page inside of which is this entire image.
So that's OK, but I'm going to need eventually
some techniques for shrinking this down.
And we'll come back to that in a little bit.
CSS, another language, is going to be one of our solutions
to that there problem.
But of course, things can go wrong.
For instance, suppose that I mistyped this and I wrote "bridge" without the E.
And I go back to this page and reload, that's, of course,
a typographical error.
And I see this broken icon.
And you might have seen this on the real web.
Sometimes, images are broken because it's essentially
a 404 happening underneath the hood.
And in fact, the image just cannot be found.
So if I want to help the user with this, for a number of reasons,
I can actually do this.
Let me add an Alt attribute for alternative,
and say something like "Harvard University."
In other words, in the event this image can't be displayed, go ahead
and at least show the user some explanatory text.
Better still, if someone is blind, or they
are using a screen reader to help them hear what is on a web page
that they otherwise can't see, the Alt attributes value
can be spoken aloud to someone with a screen reader,
so they know exactly what the image is that everyone else can see,
so they can still appreciate what the contents of this web page are.
If I go back to my tab here, in this case, it's still a typographical error.
But at least now, people with and without screen readers
can see what this image is supposed to be.
And even if I fix the typographical error and reload the page,
if someone can see the image, they now will.
But if someone's using screen reader software, which for those unfamiliar,
is software that looks at a web page and tries to describe in English,
or some other human language, what is on the web page,
now we have helped that device be all the more accessible as well.
So you might have zero or one, or now it seems two, attributes on a given tag.
All right, well, what else can we do in terms of media?
Well, there's something else we can do here.
And I'll just show you this one and let you play around
with it online if you'd like.
In my src8 directory, I've actually got a video file called video.html,
as well as video.mp4.
And if I open the former of those, you'll
see a page I wrote in advance that shows another technique about HTML.
At the end of the day, we still only have tags and attributes.
So fundamentally, we've not really pushed ourselves too far here.
But notice that there's a video tag in HTML that does come with two
attributes at least-- one called controls, one called muted.
The controls attribute just means please show the user a Play button
and a Pause button and maybe some other things.
The muted attribute means literally that-- mute the audio by default.
And that tends to be a good thing, because nowadays, browsers
are pretty defensive against advertisements,
and annoying advertisements like videos autoplaying on websites.
So you can ensure that your video will still autoplay,
but without bothering the user.
So you can mute the volume at least by default.
But what's worth noting for our purposes is that some attributes apparently
don't even need values.
There's no equal sign.
There's no quotes, which in some cases are
necessary to specify the language of this page is in English.
But some attributes indeed do not need values.
And even if they do, you can use, as in Python, single quotes or double quotes,
and sometimes no quotes at all.
But I would get into the habit still stylistically
of using double quotes for consistency as I have.
But as for the rest of this, a source tag
exists, which you can put inside of the video tag.
It itself has, confusingly, a source attribute-- src for short,
as well as a type attribute, which indicates what type of video
are you trying to play for the user.
So I'll wave my hands at some of that media.
But you're welcome to play that page and open it on your own,
and even unmute it to see what I've otherwise shown.
But let's now make the web all the more interactive.
Let me close that example.
Let me go ahead and open a new file called link.html,
and start making the hyperlinks with which
we're all familiar-- clickable links in web pages, which
is what makes the web the web itself.
Let me cut some corners here and copy-paste my "hello, world"
example into link.html.
Let me change the title to "link," just so we know what's what.
And let's actually make a page that has a genuine link to maybe that image
of Harvard called image.html.
I could say something like this--
visit Harvard, period.
Now, this of course, is just text.
So this is not that interesting.
But just to make sure we're on the same page, let me click back.
Let me go to link.html.
And you'll see that I've called it link.html, but there's no link there.
I can click Harvard all I want, but nothing actually happens.
So let's make it a link.
What do I want to link to?
Well, I could link to Harvard's website, but I already have a picture of Harvard.
Let's try linking to a page relative to this one.
Let me go ahead and open a new tag called the anchor tag--
a for short.
Let me use its attribute called href, which is a little arcane.
But it stands for hyperreference, the destination of this link.
Let me add some quotes and say image.html, close quote, close tag.
And then notice, VS Code is trying to be helpful.
But sometimes, it doesn't know what I intend.
So I'm going to delete the end tag, move my cursor over, and paste it at the end
and finish my period there, just because I want everything to be balanced.
And now, even though this one looks a little more cryptic,
this is now the beginning of hyperlinking pages on websites.
If I go back to my other tab, click Reload, ah,
now I see the familiar underline text, which of course signals in many web
pages that this here is a link.
If I hover over it, it's going to be a little small.
But in the bottom left-hand corner of my browser, which is Chrome,
I can actually see that this will lead me to a page called image.html.
And indeed, if I click on Harvard for real, I get back to image.html.
And the URL in my browser has changed from link.html to image.html.
So this is what's known as a relative link, whereby I'm linking from one
of my own pages to another of my pages.
They're in the same folder, so I don't need to mention any folder names.
The server just knows what I want.
So that's then a link.
But what if I want to link to an actual URL, and not just a relative page,
like Harvard's own website?
Well, that I can do too.
I can change the value of this href attribute.
And I could just do harvard.edu.
Unfortunately, this is not going to work.
The values of HREFs in a web page, if they're going to be full fledged URLs,
have to be actual URLs, protocol and all in this case.
And so I'm going to do https://www.harvard.edu.
And heck, I'm going to include the trailing slash,
even though I don't strictly need it.
And technically speaking, I could omit the protocol
if I want the same protocol to be used.
But in general, I'm going to link to the full-fledged URL of harvard.edu here.
I'm going to go over to my Image tab.
I'm going to click Back to go back to my Link tab.
I'm going to reload to make sure I get the latest HTML in my browser.
And if I hover over this now-- super-subtle.
But in the bottom corner of my browser now, ah, this indeed
leads me to harvard.edu.
And if I click that, we should see the familiar forests
that we saw a little bit ago.
And now this is an external link, not a relative link,
that I've now implemented in this web page.
All right, let me click back.
And let me reveal one other feature now of those so-called developer tools.
Previously, I opened up developer tools when
I wanted to play around with HTTP, the protocol that just gets the web
pages from browser to server and back.
But now it turns out I'm going to use another feature of my developer tools
by right-clicking or Control-clicking anywhere on my page
or going through the main menu.
I'm going to click Inspect.
And now Inspect makes a little more sense,
because now, I'm literally inspecting the web page itself.
Notice at left here is a visualization of the underlying HTML of this web page.
And some of it's hidden, but I'm going to click the little triangles to reveal
the rest of it.
And you will see essentially, at left here,
under the Elements tab in Chrome, a list of all of the elements
that compose this web page.
And again, an element is everything between an open tag and a close tag.
So in this case.
I'm seeing a very pretty printed version of my own source code.
And some things are broken out onto different lines,
just to make clear that here's some text.
Here's a link.
Here's some other text, both of which are inside of this body tag.
And notice too, as I hover over things, Chrome--
just to be helpful, because if I'm a developer, I want some help here,
I can see in light blue what I am hovering over in my HTML
being mirrored in the actual body of the page.
If I hover over the body, I see everything to the body as well.
Now, what I can take away from this is the following.
This here is my web page and it's very pretty printed.
If I close this tab, I can see my same code in another way.
If I right-click or Control-click, I can also go to View Page Source.
View Page Source is a feature that's been in browsers for years.
And you can see the same code, but exactly as it came from the server.
I happen to be pretty nitpicky, so it's all nicely indented as well.
But this is a static version of the page,
whereas the developer tools allows me to actually poke around with things.
In fact, let me close this tab.
Let me re-click again on Inspect.
And watch this.
If I want to poke around here, I could actually go into the developer tools
and temporarily, without even going back to my terminal window,
I can click on or double-click on anything in this page.
And I can actually change it in real time.
Like, I can change Harvard to Harvard University, and then hit Command Enter.
And in this case, I can change the contents of the web page.
But curiously, that has not changed anything on the server
because this makes clear the point that, once the browser has requested a web
page from the server, and downloaded that virtual envelope
inside of which is the original version of link.html, that's what the browser is
going to keep in its memory.
You can change your copy of that page all you want,
but it doesn't affect the server at all.
The browser gets a copy of what's on the server.
In fact, we can take this feature out for a spin, seemingly maliciously,
but not in a way that has any effect.
In fact, let me pull up not just harvard.edu,
but specifically the admissions page for Harvard College and scroll down here.
And you'll see this advertisement toward the end, "Why Harvard?"
Well, notice that if I want to see the underlying HTML of this page,
I can see it in a couple of ways.
I can right-click and choose View Page Source.
And it's going to look like way more code than we've written to date.
This is me scrolling through all of the HTML
that composes the admissions website's HTML at Harvard.
There's a lot there, but it's going to follow that same pattern of tags
and attributes.
Or I can pretty print it by going to Inspect, going to the Elements tab.
And there, notice, is the exact same content,
even though I was scrolling through it super fast.
But it shows you everything pretty printed, so you can poke around.
More importantly, I can click on any part of the page
with my Control key or two fingers and select Inspect.
And what's nice is that Chrome, and really any browser,
will jump to the specific HTML in the browser's memory
that corresponds to that part of the page.
The upside of this is, I can actually infer
how did Harvard make this web page?
How did they structure their HTML?
Now, we haven't talked about all of these tags yet,
but notice that there's all of these div tags--
D-I-V. There's a section tag, but there are some familiar ones.
Here's an H2.
Harvard is using an H2 tag for "Why Harvard?"
Here's a ul down below for some kind of unordered list.
But notice here, I can be a little playful here,
and maybe we should nudge people to go to Yale instead.
Let me change, in the Elements tab, Harvard to Yale.
Hit Enter, and now I seem to have hacked Harvard's website,
and it suddenly says "Why Yale" instead.
But of course, this changes nothing on the server, because this too is a copy.
And the moment I reload Harvard's website,
I get a fresh copy of what's actually on the server.
So what's the value here.
Well, one, pedagogically, it's just a useful mechanism, these developer tools,
for understanding and learning how a website is structured.
If you want to do something similar yourself, as a developer tool,
frankly, sometimes it's a lot faster to just mock things
up in the developer tools.
Decide, OK, I like how this looks.
And then go over to your actual HTML and make the changes for real.
It's a faster way of iterating, and it's also
a helpful way of diagnosing certain problems that we might otherwise
run into.
All right, but there's still a danger here.
Speaking of Harvard and speaking of Yale,
let me go ahead and close that tab there,
and return to the HTML of link.html.
It turns out that the attacks with which you're
familiar in the real world, namely phishing attacks,
are all too easily waged via HTML alone.
To be phished typically means to receive some kind of spam email
that's trying to trick you into clicking on a link that
purports to be legitimate, but is really taking you to some adversary--
some bad guy's website that's trying to steal your credit card
information, your username, your password, or something like that.
And those emails in Gmail, in Outlook, and other tools,
they themselves are using HTML.
Any time you get an email that's not just black and white text,
but has colors, and maybe images and formatting, it's using HTML.
So HTML is used not only for web pages, not only for mobile apps,
but also for emails as well.
And here's how easy it is to, unfortunately, deceive users.
Suppose that I still have a link here to Harvard,
but I actually changed the actual href to be yale.edu.
If I go back to my actual browser here and close my developer tools and click
Reload, the page still says, like the HTML, "Visit Harvard."
And this is super-subtle, but if I hover over this link,
in the bottom corner of my browser now I'm
actually going to be led to yale.edu if I click this link.
In fact, if I actually do that, voila, now I'm actually at yale.edu.
So not a big deal in this case.
I'm just sending one student from one place to another.
But you could imagine making a website that
looks like a bank's website, that looks like Paypal's website, that
looks like something legitimate, such that when I click on a link--
no one's really looking in the bottom left-hand corner of their browser
all the time.
You could all too easily trick a user into visiting a page,
and maybe filling out a form on a page that they didn't actually intend.
And we say this not to empower you to do such things,
but the opposite-- to detect when such behavior is happening.
And frankly, getting into the habit of hovering
over links that you're a little suspicious about
is probably a good practice.
But for today, know just how easily these threats can be waged,
and why there are so many of these threats to us online.
It boils down to these basic fundamentals.
Now, all that said, we haven't even done anything dynamically.
Every web page we've made thus far has still been very static,
like content I have made in advance.
And you can reload, reload all you want.
It's always going to look the same from the server again and again.
But how about we revisit how URLs work, not just to serve up static content,
but dynamic content as well?
It turns out that, besides having folder names and file names at the end of URLs,
you can also have a question mark in URLs,
and then key value pairs literally with an equal sign in-between them.
We've seen key value pairs all over the place, most recently
in things like dictionaries, for instance.
But in this case here, we have a canonical format
for how you can actually provide input from a browser to a server.
Typically, that's typed in via form.
So for instance, let me actually open up a brand-new tab here.
Let me go to google.com, just the main page that doesn't come with my browser.
And I'm going to go ahead and type in something like cats--
C-A-T.
Now, ignoring the fact that there's a whole lot of autocomplete going on here,
let me hit Enter.
And let me emphasize what my URL--
we can be distracted for a moment by the cute cats on the top of the page.
But let's then zoom in on the top of the page
here, where we'll see a very long URL, most of which,
frankly, I don't understand.
And probably only Google employees want to understand
what everything is in this URL.
But let me delete most everything, except the essence of this URL.
And what I've left at the top of my browser
is only https://www.google.com/search, which is the path, question mark,
q equals cats.
It turns out, way back in 1999, when Larry and Sergey founded Google
and created their very first search page,
they had a text box, just like this one, but more simple in design.
And if you filled out that text box with one or more words and hit Enter,
you submitted a query to the server for which you want to search, Q for short.
And so all that form needs to do, when you hit Enter, is change the URL,
it would seem, to take that user input in a standard format.
Q equals cats, something equals something, something equals something.
In fact, if there's multiple such parameters
as these are called, just like in functions,
you can separate them with ampersands.
But the question mark just means to the server, hey, server, here come
some key value pairs, otherwise known as HTTP parameters.
When I hit Enter, the search results are actually going to be exactly the same.
Most of the other stuff in the URL is probably for tracking purposes,
so Google can keep track of what I'm searching for and what I'm clicking on.
But in essence, if we distill the URL to just question
mark q equals cats after search, we have provided user input to this here page.
And what's cool about that is the following.
Normally the canonical URL might be as simple as this.
Or it might actually have two key values in pairs, which indeed can
be separated by these here ampersands.
I think I can take advantage of this here feature and implement
my own version of Google.
Let me do this.
That's it for HTML.
Like, there's bunches of other tags and attributes out there.
But those are really for an online tutorial or book or reference,
or some other source, to just pick up what more vocabulary there is.
At the end of the day, it's just more tags and more attributes
following this shared structure.
So for now, I want to make things more dynamic,
leveraging my knowledge of just that.
Let me go back into my VS Code.
Let me create my own page called search.html, Enter.
Let me save a few keystrokes by copying and pasting my "hello, world"
code and changing the title to "search."
Let me get rid of the body here.
And let me begin to create my very own form, using literally a form tag--
F-O-R-M space, and then here I'm going to close the tag immediately.
Inside of this form element now, let me go ahead and create an input whose name
equals "q."
And inside of this form element, let me additionally
add an input whose type equals submit.
And we'll see what this gets us first.
Let me go back to my other tab.
Click back to see my directory listing of files.
Click on search.html.
And this is super-simple, but I seem to have
the beginnings of an interactive web form-- a big text box,
and a Submit button by default that seems to be a form.
Unfortunately, if I type in anything to this "cats," and then click Submit,
nothing actually happens.
But if I go to my own URL here at the top,
notice that I'm still on search.html.
But "cats" was automatically added for me by the browser as soon as I click
Submit.
So let me go back and add a little more detail in my editable file.
Let me specifically specify that the type of this text box is text,
but that, it turns out, is the default. So I'm actually
going to enhance that and make this a search box specifically.
Let me go back to my browser and reload.
And this is subtle, but if I now type in "cats,"
notice that I get this little X here, which is just a user-friendly feature,
which means now I can click on the X to clear that box.
That is simply because I changed the type of this box from generic text
to a search box for which that feature is useful.
I don't really like the idea of Submit.
I'd like my button to say something about Google.
So let me go back to my submit tag here and change the value of that input
to be, quote unquote, "Google search."
Then let me go back to the page, Reload.
And now things are getting a little more interesting,
whereby I have a Google search button.
It still doesn't do anything.
But let me be more specific.
When I submit this form, I want the method to be used, the verb to be,
quote unquote, "get."
Somewhat confusingly, the convention is to use lowercase here,
even though inside of the envelope, I've demonstrated
with curl that it tends to be capitalized in the actual HTTP protocol.
But so be it.
But get is actually the default.
So I don't strictly need that.
But what I do want to add here is an action.
What action do I want this form to take when submitted?
Well, I don't have a back end.
I don't have a database.
I have not searched the web ever with this here code space, but Google has.
So let me use Google's back end, their servers and database,
to search for whatever q is.
Let me change the action value here to be https://www.google.com/search,
so just the beginning of that URL without the question mark.
Now let me go back to my Search tab, reload.
And now nothing visually seems to have happened.
But if I type in "cats" now, and click on this new and improved Google search
button, watch what happens not only to my URL, but the contents of the page.
I have just searched from my own web page for cats on google.com.
In other words, by nature of how HTML forms work, specifically
using the get method and the action of Google's own URL,
my browser knows how to assemble all of those ingredients
into a brand-new URL that contains as the value of q whatever
I typed into that box.
And heck, I can do this manually now, even though no one searches like this,
I could just search for q equals dogs.
And now I get some adorable dogs as my search results here.
But that's just because I now understand what these URLs are doing for me
and how they are structured.
If I zoom out, and I go back to search.html,
I can actually make some improvements here to that same form.
You might have noticed that when I typed "cats" the second time,
I actually saw it autocompleting as "cats."
There was a little pop over there.
If I don't want any autocomplete, there's an attribute for that--
autocomplete equals, quote unquote "off."
This will now disable the browser from remembering things
that I've searched for before.
I can also do this.
Notice if I go back here to my search page and click Reload, notice that,
with no hands on the keyboard, the box is there, the button is there,
but my cursor isn't.
I have to manually focus my cursor on that box.
And then it gets highlighted in blue and I see the blinking cursor.
That's not the best user experience, or UX, so to speak.
Why are you going to make the user move their cursor
and put the cursor where you want it to be anyway?
So I can fix that.
Let me go back to this same search box.
And let me add autofocus.
And I don't actually need to give it a value.
But if I now go back to the page and reload--
watch.
Even without clicking on that text box, it's
already highlighted and blinking, because I've given focus,
so to speak, to that there text box.
Now, what is this text box?
It's just a big white box.
Well, if you read the documentation for--
or listen to what I'm here saying about, the input tag,
you can also have a placeholder attribute that can contain any text you
want, like "query," for instance, quote unquote.
If I now go back to this page, reload once more,
now you see in gray text inside of the box
explanatory instructions as to what I'm looking for.
And as soon as I start typing, C-A-T-S query goes away.
So that, too, is a feature you've probably seen in browsers.
That's just the result of someone having used the right HTML tags and attributes.
Now, I've been a little deliberate here.
I have alphabetized all of my attributes,
if only because it helps me personally skim things from left to right,
and know if I've missed something that I intended.
But strictly speaking, there is no official
ordering to any of these attributes.
You can put them left to right, right to left.
They don't need to be alphabetically sorted.
But stylistically, this is indeed what I myself tend to do here.
Let's take a look at one more use of forms
that will allow us to introduce another feature that's present
not only in HTML, but in other programming languages
as well, including, in fact, Python.
So let me go ahead and create a new file here called register.html.
And let's just imagine that we're trying to create
a web page via which someone can register for something--
a website, a sport, or anything else.
And what I'm going to do in register.html is save a few keystrokes
and copy my search code into register.html.
And I'm going to change the title to "register."
And I'm going to get rid of the form as a starting point here.
Let me close my terminal.
And inside of this form, let's just create
the beginnings of a registration form.
But unlike the Google example, I'm not going
to bother trying to submit this anywhere.
That will be a goal for another time.
But let me go ahead and, in this form, create
an input for which autocomplete is off, like before,
for which the field is autofocus.
And you should only have one autofocus field.
Otherwise, the cursor doesn't know where to go.
Let me specify that I want this input to be someone's email address,
because after all, I want this to be a registration page.
So the placeholder text I'm going to be using is "email,"
so they know what to type.
And then the type of this field for now is just going to be text.
And then I'm going to go ahead and have a Submit button.
But it turns out you can have different types of buttons.
And one other way to express a Submit button is literally with an HTML element
called "button," for which the label here will be Register.
So long story short, there's different ways to implement buttons.
Here is now a second way.
Let me now go back to my other tabs.
Let's close the tabs.
Let's hit Back to get to my directory index.
And let's now click on register.html.
So it's very similar in spirit to my search form,
but now I'm clearly asking for an email with the registration button.
However, I could try to register with anything here.
In fact, if I'm not paying attention, maybe I'll
just type my name like I always do in these examples and click Register.
And even though nothing technically happened, notice my URL did change.
So the form was submitted because question mark
email equals David is appearing there.
But that was not an email address.
And it would be nice if the browser says no, no, no, no, no, that's
not an email address.
You cannot submit that form yet.
But if this is just a text box, it's going to tolerate any kind of text.
But as you might know from Microsoft Office and Google Forms,
you can certainly validate forms in those kinds of software.
Certainly, we could do so in HTML.
Well, we can in a couple of ways.
Let me go back to my HTML.
And let me change the type of this input to be not text, not search, but email.
And it turns out that this is one of the officially supported types of inputs
nowadays, where the browser will now know that, OK,
before I can let the human submit this form,
I'd better check that they typed in an email.
So let me reload this page.
Let me again foolishly try to type in just my name, not my email, and click
Register.
And now notice, I'm getting admonished by the browser.
This is a default pop-up that's saying, please
include an @ in the email address.
David is missing an @.
So obviously, I've not typed an email address.
So let me fix this-- malan@harvard.edu.
Now the error has gone away.
I can click Register.
And even though nothing useful happens, again, the URL
changed, indicating that I did submit the form, just to know we're useful.
All right, so that's all fine and good.
But it turns out that email is one of the relatively few types of fields
that you can check for, in addition to search and text more generally,
and a few others as well.
But it turns out that browsers nowadays, in the context
of HTML, support what are called regular expressions to help solve this problem,
a regular expression is a pattern, otherwise known as a regex for short,
that allows you to validate input from users,
and make sure that input matches some pattern.
And this is a bit of a mouthful how you can do these.
There's a whole bunch of documentation online, not only at this URL,
but in Python's own documentation and in other locations as well.
But I just wanted to give you a taste of the possibilities
because these are really everywhere in high-level programming nowadays, as well
as in this context of HTML.
Here is the symbology of regular expressions.
We're not in a language.
It's just a way of representing patterns, if you will.
If you have a dot in a string of text, that's
a regular expression, that just means any character.
It's like a wildcard.
Any one character can be there.
A star actually means zero or more times.
So you can say, give me character zero or more times.
So there's either nothing there or there's one or there's two
or there's more.
You can use a plus, which means give me one or more characters.
So not zero, but one or more.
You can use a question mark, which means zero or one character, but that's it.
You can use curly braces unrelated to Python and say,
I want this many occurrences of a character.
And you can have a range inside of curly braces
give me minimally this many characters, maximally this one.
And you can do other things too.
In square brackets, you can say, give me any one of these digits--
0 through 9 in this case.
But you could type anything in there that you want.
You could say 0-9 to specify a whole range without having to type them all
out.
You can type backslash D to indicate any digits,
so you don't have to type any of that out.
Or you can do the opposite, backslash capital
D, which means anything except a digit.
So long story short-- and I'm very much waving my hands at some of the details
here.
There's this whole symbology that humans have come up
with in different languages via which you can represent patterns.
So this is all to say that I could come up
with my own pattern for an email address,
even though it's not going to be as good as the browser's own.
Let me go back to VS Code here.
Instead of saying email type equals email, let me go back to type
equals text.
Or heck, I can go to the default and get rid of this altogether.
But I'm going to use one other attribute we haven't yet seen,
which is literally pattern equals, quote unquote.
Inside of this patterns value.
I can use a regular expression, a pattern that represents
what kinds of values I want to accept.
Now, I'm going to keep this simple, and therefore not very good.
But remember, that dot means any character.
Plus means one or more of any character.
An @ sign means literally an sign.
Another dot means any character.
Another plus means one or more of any character, then backslash .edu.
What's going on here?
Well, we haven't seen this yet.
But curiously, if I want to literally have a period in the user's input,
well, I can't use dot because that means any character.
It was a wild card.
So just like in C, just like in Python, I have to escape certain characters.
So in regular expressions, if I do backslash dot, that means,
give me a literal dot in the user's input, an actual period.
And then edu means make sure that the user's email address in this case ends
with .edu.
Now, this is a bit of a simplification because it is not the case in email
addresses that you can allow for any one or more characters than an @ sign,
and then any one or more characters, and then a .edu,
it's actually more formally defined than that.
So this is a very quick and dirty regular expression for an email address.
However, if I now go back to my register page and reload,
and I again try to type in David, and not an invalid email address,
that pattern will be checked.
And the browser will prevent the form from submitting at all.
So I can express different patterns of things.
Now, for email, that's not the best thing,
because in fact, if I actually look at the official definition of an email
address' regular expression, according to browsers,
it's actually this crazy, long sequence of text, using the symbols I showed you,
as well as some others.
But this just speaks to how complicated the definition of an email addresses
pattern is.
So using type equals, quote unquote, "email" is definitely the better bet.
But let me do something a little more reasonable.
If I go back to VS Code here, and let's suppose
that we want to ask the user not for an email address, but their phone number.
So let me change the placeholder to be Phone, for instance,
and then let me change the pattern to be that of a US phone number.
So here, I can do this in a bunch of ways.
But I'm going to use backslash D, which means any digit,
and then curly braces three times, then a hyphen, then a backslash D,
curly braces 3, then a hyphen, then backslash D, curly braces 4.
And this here represents a standard format for a US-based phone number--
three digits dash three digits dash four digits.
So this is how I can now ensure that the human types in not an email address,
and definitely not their name, but a phone number that at least
follows a certain pattern.
Maybe it's not very user friendly because do you really want
to require the user to type in dashes?
Wouldn't it be nice if they can skip those?
Maybe they want to use parentheses.
So there's better ways arguably still to do this.
The point here, though, is that web pages, and other programming languages
more broadly, do support these things called regular expressions, which are
wonderfully useful in the real world.
But there is a danger here.
Suppose that, even though this catches invalid phone numbers now-- register,
it's telling me to match the requested format.
Unfortunately, as great as all these features are-- these patterns
are that I just introduced you as web developers now
should never trust user's input.
Why?
The only thing stopping the user from typing in invalid data,
like their name instead of their email, or their name instead of a phone number,
or something else invalid, is the code that they've
downloaded to their browser.
But recall that, even though when they View Page Source,
they see exactly what came from your website.
They can open their own browser's developer tools via Inspect here.
They can go to those elements, and for instance,
expand the form by clicking this triangle.
And if they don't like the pattern you're imposing on them,
well, let me just go ahead in there.
Delete that.
Hit Enter.
OK, watch what happens now.
I have modified in memory version of the web page.
I can click Register now all I want.
And I have just submitted D-A-V-I-D instead of a phone number.
So this is to say, unfortunately, that to this week
alone we do not yet have enough skills or enough knowledge
to correctly validate user input.
We can make the experience more user-friendly.
We can tell them right away in the browser,
you're doing something wrong, please don't submit this form yet.
But we're also going to need, before long, a server side mechanism
for defending against that kind of attack, too.
So through phishing, and in this case through modification
of the actual DOM in memory, we've seen all too readily
how adversaries can try to infiltrate our sites in some way.
Now, in addition to the developer tools that come with your own browser,
it's worth noting that there is at least one official source via which
you can validate your actual HTML.
That is to say, make sure that it is well formed,
and that it actually adheres to the HTML spec.
validator.w3.org is a web-based tool that you
can use to copy-paste your HTML, even paste the URLs of web pages into.
And this is actually a tool that it will provide you with some feedback as to
whether or not you've made syntactic errors with your actual code.
All right, with that said, let's go ahead and take a five-minute break.
And when we come back, we'll introduce stylization of these pages, namely
through CSS.
All right, we are back.
And it's time now to start stylizing these web pages.
So that they're not just these boring black and white pages that have
structure to them, but really no style.
And so for this, what we're going to do is introduce another language
called CSS, or Cascading Style Sheets, which is another language,
but not a programming language, via which
you can specify how certain tags should be appearing on the screen.
For instance, we've already seen tags like H1, H2, H3.
And I described those as big and bold, and not quite as big and bold,
and not quite as big and bold.
But what do we mean by bold and big?
It would be nice if we could actually use font sizes or pixel sizes.
It would be nice if we could introduce colors and other aesthetics.
And indeed, CSS allows you to adorn the structure of your page
with the last mile of detail, so to speak--
the colors, the sizing, the spacing, the positioning, and so much more.
Now, in order to do this, we're going to need to introduce one other term of art,
namely "properties."
And frankly, at this point, we're just coming up
with different words for the same ideas in all of these various languages.
But properties are sets of, not surprisingly, key value pairs.
A property allows you to specify the color of something is this value,
or the margin for this something is this value, or the height of something
is this value.
So "properties" is just the term of art used in the CSS world to describe key
value pairs, just like "attributes" is the word used in the world of HTML
to describe their key value pairs-- same idea for as far back as the dictionaries
with which we introduced this here topic.
Now, where can you go about using properties?
And how can you go about using them?
Well, it turns out there's going to be different ways of applying properties
to elements inside of a web page.
And you're going to have to specify, as the developer,
how to select those there elements.
And with the wave of a hand, let me describe there
as being type selectors, class selectors, ID selectors, and attribute
selectors, some of which we will see over time.
And all this means is that we're going to use slightly different syntax when
we want to refer to different parts of a web page.
To do that, though, we're going to need to tell the browser that we
want to include some CSS in our page.
So here again is that sample HTML that represents really
the simplest canonical web page that we can create.
This one is just saying "hello, title" and "hello, body."
And if we make room in the head now, it turns out
that there can be more than just a title inside of the head of a web page.
In particular, you can have a tag called style,
which is wonderfully named, because inside of that tag,
you can put some of those CSS properties,
key value pairs targeting specific elements inside of a web page.
Alternatively, we're going to see that, instead of using a style tag,
you can actually use another tag up here,
namely a link tag, which unfortunately is poorly named,
insofar as it doesn't refer to a hyperlink in the way
that the anchor tag and the href attribute
does that we described earlier.
This one allows you to link in the contents of a .css file which contains
all of those same properties, the key value pairs.
But instead of typing them out in your actual web page,
you can actually put them in a separate file and include them more readily.
But it turns out there's yet another way to stylize web pages,
and that's with style attributes.
And we'll begin our story there, if only because it's the simplest way to begin.
But then, as we often do, we'll try to improve, improve, improve
the design thereof.
So let me go back to VS Code here.
Let me create a new file called home.html.
And pretend like we're creating a home page for someone,
like John Harvard here on campus.
Let me go ahead and save a few keystrokes, as often,
by copying and pasting my "hello, world" code into home.html.
I'll change the title of the page.
I'll get rid of "hello, body."
And I'll hide my terminal window so we can now
build a home page for John Harvard.
Let me imagine this home page as having three big sections,
like a sort of header for the page with John's name,
maybe a middle of the page that just welcomes people to his web page,
and then a footer with copyright information or things like that.
Pretty common format for a web page--
something up here, something down here, something down here.
We just need a generic structure with which to play with some HTML, and then
some CSS.
So let me do this.
Let me create a paragraph tag at the top of the page that
just has John Harvard's name.
Let me create a second paragraph below that says, "Welcome to my home page!"
And then below that, let me have a footer of sorts that's just "Copyright
John Harvard" in this way.
Now let's go about improving this in a few ways.
Well, one, this is a very quick and dirty copyright symbol.
It turns out, as an aside, that there's other ways
to express characters in HTML, one of which
is through what are called HTML entities.
Because it turns out, for some symbols that
aren't easily typed on your keyboard, you
can actually use some special syntax.
# And I'm going to use this-- & # 169 semicolon.
And here, VS Code is actually colorizing it
so I can see what's going on differently.
This is an HTML entity using code number 169, which
if you look it up in a book or a manual online,
you'll see that this means an actual copyright symbol, so a little C
with a circle around it.
It's useful and commonly used here in the US.
It's not as easy to type on the keyboard.
You could alternatively go Google it, highlight, copy it elsewhere,
and paste it in using Unicode.
But HTML entities are commonly used still
to represent certain symbols like these.
Now let's look at what this web page resembles.
Let me go back to VS Code in my directory index.
Let me click on home.html.
And here, we have John Harvard's web page.
But notice that there are indeed three paragraphs of text,
although it's not really appropriate to call these paragraphs because they're
really just different parts of the page or divisions of the page.
So we'll come back to that.
But all of the font sizes are the same.
Like, there's no making John Harvard big and bold here.
I don't really need to see the copyright as big as it is.
So you might want to start stylizing content like this.
But we have, with HTML alone, structured this web page.
So how can I add some style?
Well, first, I'm going to introduce a style
attribute before then taking it away.
I'm going to go to my paragraphs start tag here.
I'm going to add a style attribute.
And I'm going to change, for instance, the font size here.
So font-size: large, semicolon, close quotes.
Then on this tag here, I'm going to add another style attribute equals,
quote unquote, "font-size: medium," semi colon, close quote.
And then lastly, just to keep this going, style equals, quote unquote,
"font-size: small," semi colon, close quote.
Now, strictly speaking, I don't need the semicolons in this particular case.
I'm doing it just for uniformity, as we'll soon see.
But they're back, just as they were back when we introduced SQL
in the end of those statements.
But here now, I seem to have added some attributes,
the style attribute to each of these tags that's stylizing
the aesthetics of this here page.
So the structure is the same, but now the aesthetics are different.
In fact, let me go back to my other tab.
Let me reload the page, and I should see now these new styles.
And indeed-- it's a little subtle, but the top line is bigger,
the middle line is medium, and the bottom line is indeed smaller.
Well, it'd be nice to center everything.
So what else can we do with this page?
Well, let me go back to VS Code here.
And let me, after the semicolon, do something like this--
text-align: center, semicolon.
And just to save some time, let me go ahead and highlight everything
I just added, and paste it inside of those same quotes.
So now notice I have more properties.
And indeed, that's what we're looking at here.
This key, font size, has a value of large.
The whole thing therefore is a property.
And I've used it in three different ways with three different values-- large,
medium, and small.
This is another property over here-- text-align, whose value is center.
And I'm using that again and again and again,
separating them both again by semi colons.
Let me go back to my page here.
And you might imagine, as soon as I click Reload,
now everything is nicely centered.
So I've taken some baby steps toward improving the aesthetics of this page.
But I dare say I haven't really done this in the best way.
Let's chip away at this further.
So paragraph tags are fine.
But semantically, they're really meant to describe paragraphs.
And I'm hard-pressed to say that "John Harvard" is a paragraph and "copyright"
is a paragraph.
But these are different regions or areas of my page.
So I think what I'd like to do here is just be semantically
a little more appropriate.
So I'm going to change my p tag to be a little more generically div tags, which
stands for division, which is a generic rectangular region of the page, which
in some sense is adding less information.
But we're going to improve upon this further.
This is a very common way to structure pages.
In fact, when we glimpsed Harvard's HTML earlier,
there were lots of divs, divs, divs, divs in the page,
because someone who designed that page was laying things out
in rectangular regions.
And even though there's no visible rectangles, that's what's going on here.
It's one rectangular region on top of another, three of them in total.
But I don't think this is the best design still.
Why?
Well, let me go back to VS Code here.
And even if you're brand new to CSS, let alone HTML as well,
you might have noticed that I copied and pasted.
And that generally has not been a good practice.
It's just that I'm just doing something redundantly.
But what if I did this?
What if I factored out that redundancy, that commonality, the text-align:
center as follows?
Let me go ahead and delete it here, let me delete it here,
and let me delete it here.
And let me propose that all three of these divs
actually have a common parent from which they descend, so to speak,
namely the body tag.
So technically, I could go up here and do a style attribute
on the body tag equals, quote unquote, and then put
text-align: center, semicolon.
And the idea of, again, the document object model with CSS
is that text alignment, centering it, will cascade down
to the child elements which are div div, div-- three of them in this case,
so that all of them are still centered.
Let me go back to my other tab here and reload.
And even though nothing has changed visually underneath the hood,
I have factored out that commonality and applied text-align: center to all three
of those same elements.
Now, technically there's other ways to do this.
If I didn't want to stylize the whole body,
especially if this is a bigger page that has other elements inside of it,
I could actually introduce a parent of my own.
It is perfectly reasonable to create a parent div, which after all is
just a generic container there.
Let me close it all the way at the bottom here and indent it accordingly.
And then let me go ahead and indent all of these three divs inside
of that new div to make the point that, if I
don't want to apply a style to an entire body of the page, that's fine.
I can similarly just do text-align: center right here.
And that, too, would achieve the same result. And indeed, in Harvard's page,
you might have noticed, there were lots of divs, not only side by side,
but nested inside of each other, perhaps it would seem for similar reasons
as well.
Now, strictly speaking, I don't have to do it this way.
Let me go back to the body approach, just to keep it simple.
But let me propose that, as useful as these divs are,
as these containers, whereby each of them
describes a different region of the page,
I could probably help the internet, I could help search engines,
I could help AI, I could help screen readers, for accessibility's sake,
understand a bit more about what I mean for each of these divisions of the page
to be.
So instead of just generically saying div,
what I'm actually going to do instead is use three semantic tags.
And by semantic tags, I just mean HTML tags
that are not as generic as div or paragraph, or p for short.
I'm going to specify that "John Harvard" is actually in the header of this page,
and I'm going to close that tag accordingly.
That "Welcome to my home page" is in the main part of the page.
And I'm going to close that accordingly.
And the footer is actually in a tag called footer itself,
and I'll close that one as well.
Now, these are not tags I'm just making up.
These are officially in the HTML specification,
but they mean exactly what they say.
The header for the page is probably useful.
It's informational-- where you are, whose web page this is.
But the main part of the page is generally
the juicy part that has actual information that isn't
just logos and headings like that.
The footer, though, typically tends to be less important.
It's got useful stuff.
But it's probably not as important as the header
and/or the main part of the page.
So these tags capture those semantics.
And the upside is, when Google or Bing show you sample search results,
or when ChatGPT or some future technology
is learning about what this page is saying,
it could logically give a little more weight to the header and the main part,
and less weight to the footer.
So you don't see excerpts from the footer, which might not generally
be nearly as useful.
But what else can we do, now that we've introduced these tags?
Let's actually take a step toward improving the design of this page too.
Generally speaking, it's not the best practice
to combine the structure of your page with the aesthetics thereof.
In other words, it's not the best idea to combine HTML with CSS
all in the same place, because when I glance at this page,
it would be nice if my HTML really did just structure the page.
And then somewhere else-- maybe in a different file
altogether all of aesthetics are.
Why?
Because this way, maybe I could use different CSS properties for dark mode
and for light mode, so that depending on the time of day,
the colors of the website might be a little bit different.
I could maybe use different style sheets for different devices
or different types of browsers or the like.
So it would be nice to factor out the stylization from the web page itself.
That said, this is a swinging pendulum in industry.
There are technologies that actually do combine CSS with HTML, the argument
being that the closer they are, the easier it is to maintain the code
and understand what is affecting what.
So you'll find arguments in both directions
when it comes to the separation of HTML and CSS.
But let's take a step towards separating them,
at least for our desktop and laptop-based purposes here.
Let me do this.
I'm going to go ahead and delete all of these style attributes, which
is unfortunately going to ruin the aesthetics of the site
and make it very generic as before.
However, I'm going to reintroduce those properties in a different place.
As I proposed earlier, we can make room in the head for not just the title,
but a proper style tag--
so not an attribute, but a tag.
And inside of that style element, what I'm going to put
is a few different properties.
But the way I'm going to do this is by selecting parts of the web page
that I want these properties to apply to.
So when I said earlier, there's these different selectors in the world of CSS,
this is a fancy way of saying there's different syntax you
can use to apply automatically certain properties to certain tags
or certain types of tags.
So let me go back to VS Code here.
And what I'm going to do inside of my style element is this.
I'm going to specify that any tag called body,
which happens to be one and only one, should have all of its text-align
in the center, semicolon.
Unfortunately, curly braces are back when using CSS in this way,
not unlike C. But again, we're not programming.
We're really just defining key value pairs.
Any tag called header, I want to have some slightly different properties--
font-size: large.
Any tag that's called main, I want to have font-size: medium.
And then any tag that's called footer, I want to have font-size: small.
Now, even though this is taking up way more lines of code,
it is a step toward keeping my styles separate from the content of the page.
And eventually, if you are on the same page as me
here where this might be leading, we can probably
copy and paste all of those styles into a separate file.
Then two people can work on the same website at once.
One person can do structure.
One person can do style.
We can do the whole light mode, dark mode
thing by having different files for different times of day.
It feels like a design opportunity.
And all we've done, though, is select tags by way of their names
here in this particular case.
If I again go back to my other tab and reload the page,
it's actually not going to look any different.
But underneath the hood, it's indeed been structured and styled
slightly differently.
And here's where we have an opportunity to actually reintroduce those developer
tools for yet another reason.
Let me right-click or Control-click on the page.
Let me click Inspect.
And as before, you can see all of your HTML at left under elements.
But notice at right, all this time, even though I didn't mention it before,
you can also see styles for things as well.
So for instance, if I click on the body, watch what happens at right.
I will then see a summary from my browser of all of the CSS properties
that are being applied to the body of the page.
One of them is apparently text align center.
And then there's two others, even though I didn't type these
out-- display: block, margin: 8 pixels.
And that's the user agent stylesheet.
Long story short, there are certain default properties
that browsers have, be it Chrome or Edge or Safari or Firefox or the like.
And what I'm seeing in italics there for the body
are some of the default stylizations.
And this is why, therefore, some browsers will render the exact same HTML
slightly differently, unless you try to standardize it somehow
with your own CSS.
But what's nice about Chrome's developer tools, and any of these browsers
is here too, instead of going back and forth
and back and forth between VS Code and my browser tab,
and reloading each time I want to see a change,
I can change things in real time-- not permanently,
but in the browser's memory.
So if I'm just curious, and I want to see what this text would look like when
aligned to the left, I can type in "left."
And notice, it immediately jumps there.
If I delete that altogether, notice that Chrome actually
shows me a dropdown menu, a la autocomplete,
of all of the possible valid values for the CSS property.
So it's a great learning technique too.
I don't have to constantly look things up or watch a video online.
I can let the browser tell me what are the possible values, if I'm learning
or I just forget, I can possibly type there.
I can go ahead and undo that, go back to having things centered.
But I can actually play around a bit further here.
Suppose I want to change the font sizes.
Well, let me go down to header here and.
And notice what we meant was font-size: large for header.
Well, honestly, reasonable people are going
to disagree what small, medium, and large mean-- certainly
across Google and Microsoft and Apple and other companies.
So what does large actually mean?
Well, I could be more specific.
If I really want this to mean something, I
can say something like 18 point, with which you
might be familiar in the desktop publishing world.
I can change this to maybe 24 point to make it even bigger.
Or I can even deal in pixels.
I can say something like 36px for pixels.
And I can get really crazy, like 360.
And you see that now, it doesn't even fit on the screen.
But look how nice it looks because it's being dynamically sized.
So I can just play around with these various styles in the inspector itself.
So in short, within Google's developer tools--
and again, almost every browser has this nowadays,
the Network tab showed us the underlying HTTP stuff.
The Elements tab shows us the underlying HTML.
And now the Styles tab shows us the underlying CSS.
And there's so much more, but so wonderfully useful
when trying to modify or learn this here stuff.
Let me go back now to VS Code.
And let me propose to introduce another way of selecting elements.
Previously, I mentioned there was this whole list.
And what we've just done is select things by way of their type.
The type of the tag was body or header or main or footer.
But there's these things called classes in CSS too.
It's not really the same thing as classes in Python or Java
or other languages, if you're familiar.
But classes in CSS are our own keywords that we can invent, and associate
our own properties with those keywords.
So for instance, if I wanted to reuse styles,
like text-align: center and font-size: large and font-size: medium and small,
I don't have to associate them with specific tags.
I can create my own nicknames for these, if you will.
Let me say that any time I want to center something, no matter what
tag it is, I'm going to use a class called centered.
Any time I want to make something large, I'm going to use a class called large.
Any time medium, I'm going to make a class called medium.
And any time small, I'm going to make a class called small.
Now, why the dots?
The humans who invented CSS needed to come up
with some way to distinguish the types of tags or the names of tags
from classes.
And so you simply use a dot to indicate, hey, browser,
here comes a class whose name I'm making up on my own.
So anything with a dot represents the start of a class name.
How do I use these?
Well, let me scroll down to the bottom of the page.
And now there's no association yet with any of those class names with this HTML.
But what I can introduce now is a class attribute where I can specify, OK,
I want "John Harvard" to be large.
And I want the main part of my page to be medium.
And I want the footer of my page to be small.
And by the way, I want all of this to be centered.
So you can create these reusable words, and you
can invent the word subject to a few constraints on what characters
you can use.
But now you have a set of classes, so to speak,
that you can use on these tags, and maybe bunches of others.
They're not that useful at the moment because this web page
is so darn simplistic.
But you could certainly imagine, in Harvard's web page, in Yale's web page,
in Google's web page, where they have so many darn tags,
it might be very useful to use these classes,
and reuse them so you don't have to copy and paste any of that text
as we saw before.
And in fact, let's take this one step further.
It's a little silly that I keep scrolling up and down.
Let's just move all of this CSS to its own file.
So let me highlight that and cut it.
Let me get rid of my style tags altogether.
Let me create from my terminal window a file
called styles.css, though I could call it anything I want.
Let me paste those lines in there.
And VS Code nicely left aligned everything for me.
That's it, out of sight, out of mind.
Let me close that file.
And then inside of the head of this page, instead of a style tag,
let me do in link href equals styles.css.
And the rel tag for the relationship here is that of stylesheet.
It's generally the only one you'll use, and this
is the kind of thing you might have to look up or copy-paste.
But href refers to the file that you want
to link in-- essentially copy-paste, but automatically,
like an include in C or an import in Python.
And the relationship of that file to this one
is that of what's called a style sheet, a sheet or a page of properties.
So let's now perhaps use these techniques
to make things that are a little prettier now and a little more
visually interesting.
Let me go ahead and do this.
Let me close out this home page here.
Let me go ahead and open up our old file called
link.html, which previously looked like this when we left it at Yale.
Let's actually undo that phishing attack and change it back to harvard.edu
for consistency with before.
And let's try to bring this link to life in a slightly different, more colorful
way.
If I open this page, recall we did see the link if.
I close my developer tools, go back to link.html.
Notice it was underlined by default, which
is great, because it made it very visually clear that it
is a link, and not just text.
And it was purple, which is the default color in most browsers
to indicate, yes, it's a link, but it's one you've already visited.
So purple means you've visited it before.
And blue typically means it's a link, but you have not visited it before.
So that's a default. But suppose I want to override that and make
things more crimson or red in nature.
Well, let me go back to VS Code here.
And in VS Code, let me go ahead and, just for the sake of discussion,
let me take one step backward, just because it's easier and more efficient
during class, to reintroduce our style tag.
But if you're convinced, you could, and probably should,
move this stuff to a separate file.
That's indeed the best practice.
But I'm going to keep it simple in this same file.
Let's go ahead and start to stylize this anchor tag
as follows My anchor tag, abbreviated a, is
going to have the following property associated with it, a color of--
how about red, semicolon.
And now let me go back to the tag here.
Reload the page.
And indeed it's now red and underlined here.
If you want to get rid of the underlying, you can.
I could additionally, inside of these curly braces,
say text-decoration, which is another property we haven't yet seen,
whose value is now going to be none.
If I go back to my Browser tab, reload the page,
it's still red but not underlined.
And that's fine, and that's pretty common nowadays.
But here too, for accessibility sake, you should be mindful of the fact
that, depending on the quality of someone's vision,
they might not be able to distinguish red from black or red
from some other color.
So in terms of accessibility, you should make
sure that if you're removing telltale signs of links like underlines,
make sure they're sufficient contrast between the colors
that you're indeed using.
So, in fact, let me go ahead and leave that alone for now.
But let me propose that I'd like to at least show,
when a user on a laptop or desktop hovers over the link,
let me at least underline it then.
This is less useful on mobile, because on mobile, you don't really
hover as much as you do tap or not tap.
But just so you could see how in CSS this is done, I can do this too.
I can have a selector that says a:hover, which is a special keyword that
the browser knows about, which means when I'm hovering over with my cursor
an anchor tag, change the text decoration temporarily to actually being
underlined.
And if I go back to my browser tab, reload,
notice that I get now some interactive behavior.
Any time I hover, you can see the line appearing.
For better or for worse, this is how you can implement a bit more dynamism
then with your here content.
And the fact that it's an anchor tag means
that it's going to apply to any of the anchors, any
of the links in this here page.
If I don't want that to be the case, let me propose this.
Let me propose that, instead of doing this,
I want to define some properties as follows.
Let's go ahead and undo this.
And in this page, let's suppose that we have a visit to Harvard or a visit
to href equals https://www.yale.edu, close bracket, Yale.
So the page is a little longer now, but the sentence now reads.
"Visit Harvard or Yale," with two different links.
How can I now stylize these a bit differently?
Well, let me go ahead and do this.
Inside of my style attribute, let me specify
that I want the Harvard link to be red.
How do I do that?
I'm actually not sure I can just yet.
But what if I do this?
If I know I want to stylize this tag, let me actually
give it a unique identifier.
There's different ways to do this, but perhaps the most deliberate
would be to give this anchor tag a unique identifier called Harvard,
or whatever you might want to call it.
And let's do the same over here.
Let's add an ID to the second anchor tag that calls this tag Yale.
And I'm using lowercase by convention.
What this allows me to use is yet another type of CSS
selector-- not type or name, not class, but ID.
I can create a unique identifier that allows
me to say target the Harvard element.
How do I express that?
Well, instead of using a dot, I actually use a hash symbol here.
And I say #harvard.
And then inside of those curly braces, I can say color red.
And I can do #yale.
And then inside of those curly braces, I can say color blue.
And actually, just to bring back memories, for better or for worse,
of hexadecimal notation and Photoshop, as we discussed
when we discussed multimedia and representation thereof,
I can actually use hexadecimal codes.
So instead of saying red or blue or any other color,
I could say hash symbol here unrelated to the hash symbol
next to the class name.
Now we are combining color codes with CSS.
I can do this--
FF0000, which is a lot of red, no green, no blue.
Down here, I can say hash symbol, no red, no green, lots of blue.
And those represent essentially the same colors.
Down here, I still want to do--
I'm going to not bother actually with the text decoration anymore.
Let me go back to my page here.
Let me reload.
And now it's getting a little prettier-- a red Harvard,
a blue Yale with those two links targeted specifically.
Now, there's yet other ways too.
A third way would be to target a element based
on the value or presence of one of its attributes, a.k.a., an attribute
selector.
But I'll wave my hand at that, since surely, you'll
see eventually in documentation elsewhere,
if you go down this road with web design,
how you might target those as well.
But we don't have to do even these selectors.
IDs are meant to be unique.
So maybe it would be better to say anytime
I have something related to Harvard, let's use a class called Harvard.
Any time I have something Yale-related, let's use a class called Yale.
So here then, instead of saying ID, I can
say class equals Harvard and class equals Yale.
And now, even though it's not relevant for this simple example,
I can use that class on a different element again and again.
An ID is meant to be unique.
And it is a mistake on your part or my part if you use it in multiple places.
All right, so much like with HTML, which really
only had tags and attributes as its basic, similarly as CSS,
relatively simple in design with just these properties.
And it too has a much larger vocabulary of things and features
that you can use throughout your web page.
But we'll wave our hand at that, so that you pick up that vocabulary over time
via online references or the like.
But for now, let's just focus on how you can really
leverage CSS to take up a notch the aesthetics of your page,
and make things much prettier than I myself have been doing thus far.
Let me go back to VS Code.
And let me copy from the code I brought with me today,
phone book example, that gives us the simple form of a phone
book with three people.
Let me go ahead and open this file, as it's already been made.
And in this file here, after I close my terminal window, is this--
a phone book that is apparently made up of an HTML table.
Inside of that table is a couple of new tags
that I'm introducing for formality's sake here.
One is called thead for table head, inside
of which is the heading of the table with a table row,
tr, with two th tags-- table heading for short.
Long story short-- even though the table I made earlier
to mock up the visual of a phone keypad is perfectly correct structurally,
it turns out if you want to distinguish the header of your HTML table
from the rest of your HTML table, you can do so
by introducing thead up here and tbody down here.
So implicitly, what I was doing earlier was treating everything as the table
body with no fancy header up top.
But what is different here is that, by using th for the table heading here
instead of td, it's a clue to the browser
that this actually has some semantic meaning.
This is the heading of the table.
And maybe it, for instance, should be boldfaced by default.
But we've seen already, we can start to override that.
As for the body of this table, it seems like it's
a phone book with three people--
Yulia, David, and John with our now familiar numbers,
each implemented in a table row.
If I go back over to my directory index and reload, I'll now see phonebook.html.
And even though the data is there, honestly, it's
not particularly if you will.
In other words, within this file here, I've
got all of the data I care about, but certainly no CSS.
And while I could go in and start using some selectors
and adding some CSS, some key value pairs for properties
to make this prettier-- maybe with some borders and the like,
I bet I can do better by standing on the shoulders of someone else who's made
a third-party library, who's thought about what would be the prettiest way
to display an HTML table.
And this gives us an opportunity to discuss
what are called frameworks in the world of web development in particular.
A framework is really a library, written by some third party, that
just makes it easier to frame your own project, to structure your own project,
so that you don't have to implement a lot of basics, particularly aesthetic,
that so many other people have had to deal with as well.
Better to focus on the problem you actually care about,
the business you're building, the product you're creating,
rather than worry too much about the aesthetics thereof.
And among the more popular frameworks in the world of HTML and CSS
is something called bootstrap, which is a library that anyone
can use and incorporate into their websites,
really by just including one or more HTML tags.
And suddenly, everything would seem to look prettier.
And in fact, let me go ahead and do this.
Let me copy an example I brought with me as well--
this one, a second phone book example.
If we open this new and improved version of phonebook.html, notice a few things.
In the head of my page, I've included a link tag this time.
But it's not referring to a file of my own, like styles.css from before.
But rather, it's referring to an absolute URL
that ultimately, per the end of this URL, points to a file
somewhere in the cloud called bootstrap.min.css, where min is just
saying that this is a minified file, which means a lot of the whitespace
has been deleted from it, just to shrink the file's ultimate size.
But it is, in fact, a CSS file.
Meanwhile, lower down in this file, if I close my terminal window here,
we'll see in the table tag that I've used a class
attribute, the value of which is table.
Why is this?
Well, according to Bootstrap's own documentation,
they just told me, if I want to use their stylization, their stylesheet,
be sure to add a class of table to your own HTML table,
so that they don't presume to change the aesthetics of all of your tables--
just the one to which you've added this class.
Meanwhile, the documentation also advised
me to add scope equals column and scope equals column to two of these table
headings up here.
But otherwise, the data itself is exactly the same.
So let me go back to my browser tab here,
which previously looked like this with no CSS whatsoever.
And honestly, even if I'd added my own CSS,
you'd have probably been underwhelmed as to how pretty
my own pages look, and probably would not have looked much better.
But simply by including Bootstrap CSS file
and adding those attributes that I pointed out,
notice what happens when I now click Reload on this newly stylized phone
book.
Suddenly, it looks much better.
Still black and white, so if you were expecting even fancier,
you're not going to get it.
It's still black and white.
But notice, the font is no longer the default. It's no longer some serif font,
but it's some sans serif font with less decoration.
Notice that Name and Number have been automatically boldfaced.
Notice that clearly, there's more padding
or spacing among all of these values.
So arguably it's easier to read.
Notice that there's the gray line separating each of the rows
from each other.
And long story short, it's just prettier.
It's nicer to look at.
But you and I don't have to figure out how to adjust the white space,
how to adjust the boldfacing, how to adjust the font size, and all of that.
The library takes care of that for you.
Moreover, there's other features you can include here.
If I read the documentation, it turns out
that I can also add table-striped to the class attribute.
So we haven't seen this yet.
But it turns out that the class attribute's value
can be one word or two or three, so long as they're separated by spaces.
So if I read the documentation, it turns out
I can apply two classes to this table, the second one now being table-striped.
And watch what happens when I now reload the page.
I now see that every other row is very beautifully striped, slightly more
usable, slightly prettier to look at, and maybe more helpful
than to discern what data is on what row.
And let me wave my hands at the rest of this.
But suffice it to say that, by way of frameworks like bootstrap,
you can actually make your website faster and better and prettier
without having to reinvent lots of wheels yourself.
That said, if you're particularly artistically inclined
and want to fine tune things, you can create some, or even all, of the CSS
that you're using.
But for more on bootstrap, all of its documentation is at this URL here.
And in fact, in many of CS50's own projects do we
ourselves use bootstrap and its classes.
So we don't have to figure out all of the aesthetics thereof.
Now, with all that said, just one language
remains, this one a proper programming language, that for better or for worse
is going to bring back functions and arguments and loops and conditionals.
But before we get there, let's take a five-minute break.
And when we return for the final time, we'll dive into JavaScript.
All right, we are back.
And we now take a look at the third of our three languages today,
that of JavaScript, but specifically one that's a programming language.
And by programming language, I indeed mean
that we'll get functions and arguments and loops and conditionals and more
back.
But let's take a quick tour through JavaScript, just as we did Python--
much more quickly, because what's ultimately important to us today
is that you have a sense of what JavaScript can do.
But we will really only scratch the surface of this here language.
Not only can JavaScript be used in some of the ways we'll see today.
But it's also increasingly being used on the server as well
to generate entire websites and applications and more.
So we'll give you a sense, really, of some
of the basic syntax and basic capabilities.
But ultimately defer to your future endeavors,
your own final project perhaps, to apply JavaScript and explore it all the more.
So just as we did earlier, let's consider the simplest of web pages
here in HTML alongside its own DOM, or document
object model, which represents again how that HTML might be structured
in the computer's memory once the page has been downloaded and loaded
by the browser.
Unfortunately, what you're looking at here is a very static web page one that
simply says "hello title" and "hello body."
But wouldn't it be nice if that DOM could evolve over time?
After all, in C, and then in Python, we experimented
with data structures via which we can add and remove data dynamically based
on user input and more.
In fact, most any web page you've used nowadays
has some form of dynamism involved, such that it's rare for it
to be a static website.
Odds are something is changing.
Case in point-- if you open up your Gmail inbox or Outlook inbox,
and just sit there staring at it, odds are, for better or for worse, more email
will appear.
More email will appear.
And previously, we described those kinds of inboxes
as stacks, which they rather are underneath the hood.
But visually, how are those stacks of emails being implemented in HTML?
Well, we've seen already that it's probably some form of tabular data--
a bunch of tr's, tr's, tr's, one for each email that you might receive.
But if it's coming from the server once, how can you possibly get more emails.
So long story short, thanks to server-side technologies,
Python among them, and client-side languages like JavaScript among them,
can you actually, behind the scenes, get more and more data from the server
in order to update the web page, and in turn the underlying DOM?
So how can we go about doing this.
Well, let's see what some of the things are that JavaScript can do.
We have conditionals in JavaScript, whereby
such as in Scratch, when we had x less than y
is a Boolean expression, in JavaScript here at right, that kind of code
is now going to look like this.
Unfortunately, the parentheses are back.
The curly braces are sometimes back.
But this is perhaps the simplest way to think
about the structure of a JavaScript version of a conditional.
It actually looks, at a glance, exactly C.
If we consider an if else in Scratch here, right now in JavaScript
would be exactly the same, just as we saw, in fact, in C.
And similarly, if we have an if else if else
if that too might look exactly like this.
But unlike Python which rather abbreviated
else if in JavaScript and in C, it is else if with a space in-between.
All right, what about variables in JavaScript
if you actually want to be able to store something in your own variables?
Well, in Scratch, recall that we might have
set a counter equal to an initial value of 0 like this.
In JavaScript, there's a few ways to do it.
But the simplest way to describe this is by using a new keyword, "let,"
which is like a very polite way of asking the browser to give you
a variable.
"Let me have a variable called counter and initialize it to a value of 0."
Semicolons though, are now back.
Now, that's a bit of an overstatement because JavaScript can actually
tolerate the absence of semicolons, at least in many cases.
However, for consistency, we and I will continue to use them here.
How about if you want to increment that counter by a value of 1?
Well, in JavaScript, you can do this by setting
counter equals to counter plus 1, the equal sign being,
of course, our assignment operator from right to left.
You could also do counter plus equals 1, just as in C and in Python.
And if you like this in C, plus plus and minus minus are now back.
So in JavaScript, you can do that to increment
or decrement a variable, respectively.
What about loops?
Well, in Scratch we might have had something like this to repeat
three times.
In JavaScript, it similarly is going to be very similar to C.
But instead of saying something like int for integer in C,
we indeed say let in JavaScript to create a variable
like i do this say three times while incrementing
with plus plus i along the way.
What else might we now do?
Well, we might have a forever block here in Scratch that
does something, of course, forever.
In JavaScript, you can also say "while true,"
where true is back to being lowercase here.
And that will ensure that whatever is between those curly braces
will happen again and again.
Meanwhile, if we revisit the canonical form of this HTML, where can
we actually put JavaScript code?
It turns out there's a few different places,
and there's a few different reasons to use one place or another.
But just so that you see the range of possibilities, especially when you then
see suggestions in online documentation for JavaScript libraries,
you can put a script tag in the head of your page,
just like we put a style tag or a link tag up there, as well as the title.
And inside of that can go some raw JavaScript code typed out by you.
Of course, I've proposed that it tends not
to be ideal to co-mingle one language with another.
And so there's other ways to do this too.
You can actually have a script tag, this one with a source element
that will allow you to specify another file name,
or even another URL, from which you want the JavaScript itself to come.
What's a little weird, though, about the script tag here,
even when used with a source attribute, is that you'll see that I've closed
the tag nonetheless with an open bracket /script closed bracket tag at the end
of this line to make clear that there's no JavaScript inside of this element.
Indeed, it's only coming from that same source.
As an aside, you will also see-- and there are also reasons to,
sometimes put a script tag in the body of the page that
is below most everything else in the page,
or a script tag with a file reference therein, even at the bottom of the page,
just because order of operations can indeed matter.
But these are subtleties that we'll try to avoid for now,
simply focusing on really what JavaScript itself can do.
And in fact what's perhaps most powerful about JavaScript,
and what nicely brings us rather full circle back to where
we started the class in Scratch, JavaScript in the context of browsers
can be very much event-driven.
So just like in Scratch, when we actually had actual events-- and even
a block, if you discovered it, called broadcast,
where you could have one sprite somehow signal to another.
In JavaScript, and specifically in the context of browsers,
there's just so many events or things that can happen.
For instance, you might change the value of a field in a form.
You might give something focus by clicking on a text box.
You might drag something from one place to another.
You might put your mouse down or mouse over something.
On a mobile device, you might put a finger down, thereby
touching down on the device.
So long story short, all of these keywords that you see here
represent events that happen inside of a browser that JavaScript, as a language,
can be used to listen for and respond to.
And as such, you can use JavaScript to make very interactive and responsive web
pages, whether that's to go get more emails from the server,
or to grab more of a map if you're clicking and dragging
while using Google Maps or the like.
So let's begin to scratch the surface today only of what JavaScript can do.
Let me go back to VS Code here.
Let me create a new file here called hello.html.
And in that file, I'm going to go ahead and save a few steps by first copying,
as a starting point, some of my earlier code.
Let me close my terminal window, change my title as always to just "hello,"
and get rid of now that default body.
And let's go ahead and whip up a very simple interactive page that just says
"hello" to someone more interactively, ideally letting them type in their own
name, just as we've done in so many languages prior.
Let me go ahead and create a form tag in here.
And inside of that form, let's give myself an input.
And just to practice what I've been preaching,
let's turn autocomplete off as before.
Let's turn on autofocus, so I don't have to click in it manually.
Let's give this input a unique identifier for reasons that we'll soon
see, like "name," although I could call this thing anything I want.
But I do want the person's name.
Let me use the placeholder text of "name,"
so it's clear to the user what I'm prompting them for.
And the type of this text box, even though this is the default,
shall indeed be text.
What else do I want to do?
Well, let's keep it simple, and just have an input type
equals submit so that I get a button, which you've
seen in a couple of different ways.
Let me go back to my other tab.
Reload the page.
And I see now hello.html.
Inside of this file, I see a very simple form.
If I type in my name, though, and click Submit,
notice that my URL has changed if I zoom in up here.
And there's indeed a question mark, which
suggests that something was submitted from the browser to the server.
But there's nothing after that.
There's no something equals something.
And why is that?
Well, even though I gave the text box an ID of name,
I didn't give the text field a name itself.
In other words, I did not say, if confusingly, name equals, quote unquote,
"name," just as I did name equals, quote unquote, "q," or name equals,
quote unquote, "email."
And that's fine because we've certainly seen inputs before that don't actually
send anything to the server.
They just result, for instance, in the case of a button,
in the form itself being submitted.
So this is to say that, if an input in a form does not have a name,
it's simply not going to be submitted to the server.
But that's OK, because my goal at hand today, at least for this example,
is to say "hello" to the user, but not server-side.
We don't yet have the means yet until we reintroduce some Python to generate
content server-side.
I want to do everything client side.
And so just to be clear, just as HTML is downloaded from the server
to the browser, CSS is downloaded from the server to the browser,
JavaScript as we are currently using, it will also be downloaded from the server
to the browser, and executed client-side in your own Mac, your PC or your phone.
Which is to say that any of the data we get from the server
has to come all at the get-go.
Until then, it gets executed client-side.
So if I want to greet the user, based on what they type in their name
as I need my client-side JavaScript code to go grab that name from the form
and display it on the screen for me.
So how can I do this?
Well, it turns out that the form element can take another attribute
that we've not yet used that's actually reminiscent of those keywords
on this list here.
Indeed, notice on this list is a submit event.
And indeed in HTML, I can use an onsubmit attribute
in my code to do most anything I want.
For instance, suppose I want to call a function.
I'm going to call a function called greet.
However, I don't want this actual form to be submitted.
I actually want to return false here as well after a semicolon, just
to make clear that what I want this form to do
is no longer to submit to the server, but rather greet
the user by calling some function called greet, and then return false.
And returned false, per the documentation
for how browsers and JavaScript works, just means
that the form never goes to the server.
So how can I go about using this here code?
Now, this greet function doesn't actually come with JavaScript.
But I can create it myself, just as I could create functions
in Scratch, in C, and in Python.
In fact, let me go up to the head of the page and keep things simple.
Create a script tag in there above my title.
And then inside of that script tag, let's go
about defining a function in JavaScript.
It's a little different from C. It's a little different from Python.
But the end result is really the same.
In JavaScript, you literally write the keyword "function," which means, hey,
browser, here comes the new function.
You then give that function a name.
I'll call it greet.
You then specify in parentheses whether or not
that function takes any arguments.
And for now I'm going to say no, none.
And then inside of curly braces, I can implement the actual function.
Well, what do I want to actually greet the user with?
Anything for now.
Let's keep it simple.
Let's actually use JavaScript's built-in function called alert,
and just say something like, how about, "hello, world," close quote, semicolon.
So the alert function, unlike greet, does come with the language.
Here, I'm going to go back to my browser, reload the page,
type in D-A-V-I-D. And now I'm going to click Submit.
And notice what happens.
I now get a fairly ugly pop-up, which is built into the browser itself.
But toward the middle of it, it indeed says "hello, world."
Now, that has nothing to do with the name I typed in.
But we can fix that.
Let me click OK.
Go back to VS Code.
And before I say "hello, world," let's do this.
Let's create a variable called name and set it equal to the following function,
though it's admittedly a mouthful-- document.querySelector, quote unquote,
"#name" .value semicolon.
There's a lot to unpack here.
So what's going on?
Well, recall that from Python, you can chain certain things together.
And recall from CN Python, you can use the dot operator
to go inside of structures or objects.
So that's a lot of what's going on here.
So it turns out there's a special global variable when using JavaScript
in a browser called "document," which refers to the document itself-- the DOM,
if you will.
And if you go inside of the document, it comes with a method, a.k.a., function
called querySelector-- capital S lowercase q.
And what querySelector lets you use, funny enough,
is the exact same syntax that CSS uses to select elements.
So you can select elements in the page by way of their name or type,
like body or header, or main or footer.
You can select elements by way of classes or by way of their IDs,
or other techniques as well.
Now, recall earlier that I did give this HTML input an ID of, quote unquote,
"name."
And so if I want to refer to that ID, recall from CSS
that the symbol is the hash symbol, and then the name of that identifier.
So what's happening here is, I'm saying go into the document.
Use the query selector method.
Look for the element whose unique ID is "name," and please grab its value--
that is, whatever the human typed into that input.
And store it from right to left in a variable called name.
Now all I have to do is include it in my alert to the user.
And just as in Python, there's different ways to do this.
What I'm going to go ahead and do first is our old friend, the plus operator,
after a space inside quotes, and append to or concatenate to hello,
comma, space, that person's name.
Now notice too, what I've deliberately done here is the following.
In the world of C, double quotes are what you use for strings,
and single quotes are what you use for characters.
In the world of Python, double quotes or single quotes
can be used for strings otherwise known as STRS.
In JavaScript, the same thing is true.
Double quotes or single quotes--
I will say conventionally, probably most JavaScript programmers
use single quotes, for better or for worse, for strings.
So that's the habit I'm going to adopt here,
if only to be consistent with that.
Let me now go back to my other browser page, reload, type in again my name
David.
And notice now when I click Submit, ah, now I get, if I zoom in, "hello, David."
So I've created a string there dynamically.
Notice too, once I dismiss this by clicking OK,
if I go back up to the URL bar, notice that I have not actually
submitted the form.
No question mark, no key value pairs have appeared in the URL.
All of this is indeed happening client-side.
Now, what more can I do with this?
Well, this arguably is not the best design, because as before with CSS,
I'm co-mingling one language with another.
And I've baked into my HTML some very explicit JavaScript code.
Can I get rid of this?
Well, I can, in fact, do that in a couple of different ways.
Let's go ahead and do this.
Let me go ahead and get rid of the onSubmit stuff,
leaving therefore just the form and the two inputs inside of it
that I had previously.
Just to avoid a problem, let me go below this now and add a script tag
after getting rid of this one up here.
So I'm going to deliberately move everything
to the bottom of the page for now, just so that this
works without creating a problem.
And what am I now going to do?
Well, it turns out in JavaScript, you can actually
use JavaScript to query the DOM for specific elements.
And then listen to events that might happen with those elements.
You don't need an onsubmit attribute.
You can do all of this in code.
So how might I do this.
Well, let me do this.
Let me create a JavaScript variable called form.
Set it equal to document.querySelector.
And then let me go ahead and select the one and only form in my page with,
quote unquote, "form."
I don't need a hash symbol.
I don't need a dot because I'm selecting that element by its type or its name,
which in this case is "form."
All right, what can I now do with this variable.
I can now use form., and a new method that we haven't yet seen.
It turns out in a web page, once you have a variable or some other value that
represents an element on the page, you can
call a method called addEventListener.
And as the name implies, that allows you, after the page has been created,
to start listening for some special event
on that element, that event being drawn from a list like this one here,
including the Submit event.
So how can I do this?
Well, this function takes one argument, which is, quote unquote,
"the type of event that you want to listen for."
And I could listen for any number of things.
But the one that's relevant for a text box in this case,
or one that's relevant for a form with this text box, is going to be,
quote unquote, "submit."
And then I can call a function that actually gets
called whenever that form is submitted.
Now, greet, again, does not yet exist, because I deleted it earlier.
But notice what's happening here, which is not
something we've done much before, except a little bit in Python.
I am calling the form variables addEventListener
function, a.k.a., method.
I'm telling it to please add an event listener on the Submit event.
And whenever that event is fired or triggered,
please call this function "greet."
So I'm passing in the name of the function.
I am not using parentheses after the name of this function,
because I don't want to call greet now.
I want to register greet as an event listener, so to speak,
so it's called later by its name by the browser for me.
Now, how can I go about implementing greet?
I can do something as before.
So above this code, so before I use it, let's say function greet, open paren,
close paren.
Then inside of this function, let's do something similar to before.
# Let name equals document.queryselector, quote unquote, "#name"
to get at the element with that unique ID, .value.
And below that, let's go ahead and use our alert function, saying again
hello, comma, space, plus, to use the concatenation operator,
that particular name.
Now, there's one other thing I do want to do here,
because by default, when forms are submitted,
they indeed get submitted to the server.
But that's behavior that we wanted to preempt.
The way we prevented that last time was by adding return
false inside of the event handler.
But there's actually a better way to do that.
It turns out that when adding an event listener using a function called greet,
you're actually going to be passed in an argument, whether you want it
or not, that I can refer to as event, or e for short.
But I'll be more explicit with "event."
And it turns out that argument that gets automatically
passed in for you, whenever that event is triggered,
allows you to call event.preventdefault, which
is a more programmatic, less hackish way than
previously, whereby I just returned false.
This is literally telling the browser, when you get this event,
let me do my own thing by alerting the user "hello so-and-so,"
but prevent the default behavior, which we know now to be submitting the form
itself.
So if I haven't made any mistakes here, and I go back to my browser,
reload this page, type in D-A-V-I-D again, and click Submit,
there we have it again.
The browser has shown me "hello, David."
But this is getting a little verbose, honestly.
And in fact, there's more JavaScript-like ways
to do things like this.
And let me propose to do this.
Notice that I am, one, using a variable called name here,
and then only using it in one place.
That's totally fine and very reasonable.
But we know from C and Python, that's not strictly necessary.
So if you're more comfortable, you can get rid of that whole variable,
like such, and then just concatenate to hello, comma, space
the return value of that same function.
Now, this fits on the screen nicely.
It's still pretty readable.
I would wager that this is reasonably well-designed, but if this line of code
got much longer, we probably do want to go back
to the version with an actual variable.
But we still want to prevent the default.
But what about this line here?
Notice that I'm calling a function called greet,
even though I'm only doing that once.
So we can actually do something in JavaScript
that's neat that we can't quite do in the same way in C or in Python,
or at least not nearly as elegantly.
It turns out that if I'm only using the function "greet" once,
I don't really need to give this function a name.
In fact, let me just get rid of that there and get rid of this here.
And let me propose this.
This will look ugly at first.
But I'm going to grab this whole function,
and I'm going to literally copy and paste it as the second argument
to addEventListener.
I'm going to go ahead and clean it up a little bit
to be a little conventional here.
I'm going to move my curly brace to this line.
I'm going to get rid of this space.
But now this is actually pretty compact.
Let me get rid of some of the blank lines.
And notice what I'm now doing.
I'm still using a variable called form to get the one form in the page.
I'm then telling that form to add an event listener for the Submit event.
But because I want to tell it what function
to call, what you can do in JavaScript, which you can actually do in Python too,
is you can pass in an anonymous function, otherwise known
as a lambda function, that still might take an argument,
but does not need a name.
Why?
Because if you're using it only one place, why bother even giving it a name?
So the only thing I've done is deleted the name "greet"
and simply calling it "function," and then passing in and specifying
the argument it should take.
But the next two lines are exactly the same.
And the only thing you have to be careful about
is, notice I've got the close curly brace here, and then
the close parenthesis, the first of which
closes this curly brace, the second of which closes this first parenthesis.
And if you really want to tighten things up,
we don't really need the form variable.
Let me get rid of that line of code and change that variable
to be this one-liner.
And so even though this is getting a little complicated visually,
for those unfamiliar with JavaScript, this
is fairly conventional syntax for doing a whole lot of things at once
in this particular language without unnecessarily
using variables and the like.
Now, let me demonstrate that still this here works.
If I reload the page and type in my name, David, and submit,
we do get that pop-up.
But let me do what I did previously, which
was to put this whole script tag inside of my head tag at the top of the page.
So I'll make room for it up there.
Same exact code, but now the script tag is above the form tag.
Let me go back to my browser here.
Click reload.
Type in D-A-V-I-D, and click Submit.
And dang it, we're somehow back to the broken version,
where still my name-- because I added that name attribute earlier,
is getting submitted to the server.
But I don't want this getting submitted to the server.
What is now going wrong?
Well, let's see if we can't diagnose this.
Let me go back.
Let me right-click or Control-click and inspect,
and show you one final tab today, which is that of the JavaScript console.
It turns out that in the Console tab of your developer tools,
you can see error messages from languages like JavaScript.
And if you see anything red, like this, odds are, I'm afraid you messed up.
Or in this case, I messed up.
And let's see if we can infer what's wrong.
"Cannot read properties of null," reading addEventListener.
Unfortunately just like Clang, just like Python,
the error messages in the computer world are not always that clear,
especially for first-time programmers.
But it at least seems to relate to line 7, character 43 of hello.html.
So let's go back to this line here.
Ah, line 7 here is in place.
Why might the form be null?
Well, notice that this global variable here is referring to the whole document.
QuerySelector is selecting some element from that document.
But if that element doesn't yet exist, this function
call here, which I've highlighted, will return null.
So this is like saying null.addEventListener,
which just like our time from C makes no sense.
You can't dereference null.
You can't do anything with null.
So something has gone wrong.
Now, why is that?
Well, much like Python, much like C, these languages
are typically read top to bottom, left to right.
And unfortunately, if you define the form on line 16,
but you try to access the form on line 7, it's just not going to work.
And so what you're seeing in JavaScript console here
is that it's null because it hasn't yet been read.
Now previously, I avoided that problem by moving the whole script
tag to the bottom of the page, just avoiding the problem.
But there is another way to do it.
And you'll see in lots of libraries, even though it's a bit of a mouthful,
let me go into hello.html here and add one more event listener,
which I'll type out myself--
Document.addEventListener.
And I'm going to listen for a very special event
that you have to capitalize.
Just write DOMContentloaded quote unquote.
And then I'm going to go ahead and call another anonymous function that
simply does all of this stuff together.
At the very bottom of what I just added, I'm going to add another--
whoops.
I'm going to add the close curly brace and another close parentheses
to now close this curly brace up here that I just added and this parentheses
here that I just added.
So this too is more of a mouthful.
But what is DOMContentloaded?
I mean, it does what it says.
When the DOM content, the entirety of it has been loaded,
then can you go ahead and execute these lines of code.
How do you know what lines of code to execute.
Well, here too, I've defined an anonymous function
in JavaScript, which just allows me to contain,
inside of these curly braces, the lines of code that I want to execute, not now,
but eventually, when the DOM's content has loaded.
So this is to say that, even in these simplistic examples we've seen already,
JavaScript very heavily tends to use these anonymous functions.
Or really, people who write JavaScript code
tend to heavily use these anonymous functions, if only
because it tightens things up.
And typically, once you have some experience with programming
in this or other languages, you'll get more and more familiar with this,
even though at a glance for the first time,
this admittedly looks way more complicated than the problem
it's actually trying to solve.
Now, that said, just like with CSS, we can get rid of all of this stuff.
Let me highlight and cut that out.
Let me delete all these new lines.
Let me go into my script tag.
And let me pretend for the moment, with a source attribute,
that I have a file called scripts.js.
And I could imagine now going into a file called scripts.js,
pasting all of the code.
I just cut out of this file, and then just
like CSS allowing one file to refer to the other.
So in other words, you can ultimately go ahead
and implement that same paradigm of separating one language from another
in JavaScript as well.
All right, that was a lot.
But let's now focus not so much on writing as much code like this,
but looking at some examples that I brought
with me to demonstrate what more we can do with JavaScript and my terminal
window.
Let me go ahead and grab a fifth version of this file from my src8 directory.
That's going to look a little something like this.
In hello.html now, which I wrote in advance this time,
we have some very similar code, such that I'm listening for the DOM content
to be loaded.
I am defining a variable, in this case called input, because I
wanted to find a text box on the page.
And I'm using another event listener, and we've
seen it on this here list, not just submit, but for instance,
key up when the human's finger comes up from the keyboard,
just after having typed something.
Let's see for the moment, before we dive in further,
to how this event is being used, what this page now looks like.
If I close my developer tools and reload the page,
notice that the Submit button is gone.
But I still have a text box.
And watch what happens when I start typing, like, the letter C or A or T,
or if I delete, delete, delete, W-O-R-L-D, delete, delete, delete,
delete.
And then there's a default value here as well.
So notice now, it's automatically updating the DOM of the page
as I'm typing.
In fact, let me do this.
Let me reopen my developer tools with Inspect.
Let me go to the Elements page by default. And notice the p tag here.
At the moment, in the browser's memory, is the phrase hello, comma,
whoever you are.
Let me start to type my own name now, instead of cat or world or anything
else, D. And notice that, not only am I seeing "hello, D" on the screen,
notice that the DOM, as represented by the Elements tab,
has been dynamically updated as well.
If I type in now an A, notice what happens in both places too.
The DOM gets updated again.
V-I-D- notice that, and it's flashing to draw your eye to it,
I'm updating the DOM in memory.
Meanwhile, if I close this, and open up the page source,
recall that this is a static version in here.
There is no mention of D-A-V-I-D in the actual HTML.
That's coming from me, the user.
So if we go back now to VS Code, let's look at how this works.
Again, on line 10, I created a variable called
input that just uses querySelector to find the input element, the text box.
Then I registered an EventListener on that text box for keyup.
So this thing responds as soon as the finger comes off the key.
I want this function anonymously to be called
whenever that key goes up, I, inside of this function,
define a variable called name.
And I use the querySelector to get another element on the page called p.
Well, where did that come from?
Well, let me open the page source again.
And notice, at the bottom of the page is not
only the form, which is super simple-- no submit button even.
But there's also an empty paragraph tag that I just put there as a default
element to fill with my content.
Let me go back to VS Code here.
And notice that, once I've got that, I've got room for the person's name.
So what I'm going to do is this.
If the input has a value, if the text books box has something typed in,
I'm going to do this, I'm going to go inside
of that name, the so-called paragraph.
I'm going to change its inner HTML capitalization
is important here-- lowercase inner, all caps HTML.
And I'm going to change it to be hello, comma, something.
More on that in a moment.
Else-- if there is no input value, that is it's blank,
so this Boolean expression is false, let's just change the innerHTML to be
"hello, whoever you are."
That's the default value.
The last thing to tease apart then is, what is going on here?
This is horrible to look at, I will admit.
And it's the ugliest of the syntax we've seen.
But just like in Python, we have those format strings, or f strings,
where you can put the f, and then quote marks,
and then curly braces inside to interpolate the value of some variable.
JavaScript has something similar, except it's much more ugly to look at.
Specifically, you use backticks, which vary in their location,
based on whether you have a US English keyboard or something
else-- but a backtick at the beginning and a backtick at the end.
And inside of those backticks, if you want
to interpolate the value of some variable, you do use curly braces.
But you also use dollar sign.
So it's like Python syntax, but worse.
But it's the exact same idea.
There's nothing really complicated beyond that,
other than remembering or googling the syntax for that technique.
So at the end of the day, the result is that we get this automatically updating
page that updates one keystroke at a time, based on what the user typed in,
this time based specifically on the keyup event instead of submit.
Well, let's do one other.
Let me go back to VS Code here.
Open up my terminal after closing hello.html.
Let me copy from my source directory today something called background.HTML.
And now let's go back to my directory listing
here, reload, and see background.HTML and click it.
This is very simple, but let's see if we can infer how this works.
I've got three buttons.
And they're not rectangular as much as they are square.
But that's just because the labels, G and B, are so short.
But watch what happens.
R turns my background red.
Green turns it green, B turns it blue.
Well, how is that happening?
Well, let me go back to VS Code here.
And let me actually open now this file, background.HTML.
And notice what's going on here.
Inside of my body, I've got three buttons, each of which has unique ID--
red, green, or blue, and each of which has super-short labels--
R, G, and B in all caps.
But then I have a script tag.
Notice first I'm creating a variable called
body that's just grabbing the element from the page, the type of which
is body.
And there's only one of those.
And then notice this.
I've got three nearly identical lines of code starting here.
I'm going into the document using querySelector
to find whatever element has a unique ID of red per the hash symbol.
On that element, I'm adding an event listener
for the click event, which is again on our list of events
that you can listen for in JavaScript, in addition to submit
and in addition to keyup.
Here, then, I'm listening for click.
And I'm calling this anonymous function when that button is clicked.
And when it is, I execute one line of code.
And here is where today comes together full circle.
I can, inside of my web page using JavaScript, modify the CSS of my page
too.
I can go into that body element, access its style attribute, which
is a variable inside of the body--
and that exists because that's how browsers work.
And I can access the backgroundColor property inside of that body tag style.
It's like accessing its style attribute, if you will.
And I can set it equal to quote unquote, "red."
# Or I could do #FF0000, but I kept it simple with, quote unquote, "red."
The next three lines of code are the same thing, but for green.
The last three lines are the same thing, but for blue.
The only thing that's weird here is where did backgroundColor come from,
because it's lowercase b and capital C. Unfortunately,
this is maybe not the best design historically.
In CSS, we saw text-align.
We saw color.
We saw a couple of other properties as well.
Unfortunately, there is, in CSS, a CSS property called background-color.
I just didn't happen to use it just yet.
Unfortunately, CSS uses background-color.
JavaScript necessarily uses backgroundColor with capital C. Why?
Well, in JavaScript, you can do math, like in most languages.
And unfortunately, the dash is already used as a minus sign.
So unfortunately, in JavaScript, if you wrote this property as background-color,
this would be like trying to subtract color from background-- so background
minus color, which makes no sense.
So left hand and right hand weren't really communicating, it seems.
So the solution was just to use camel case,
so to speak, like a camel with a hump, and capitalize the C,
but get rid of the hyphen.
And there is a mapping therefore from CSS properties
to JavaScript attributes in this way.
So that's all that's happening.
And in fact, we can see this again in our inspector.
Let me reload the page to go back to white.
Let me, again, open up the developer tools.
Let me click on the body of the page, which currently has no attributes.
And at right, there's no styles being applied to it,
other than the defaults from the user agent stylesheet.
But watch what happens now under element.style and on the body
tag itself.
When I click R, a style attribute will suddenly
appear programmatically on the body tag with a value
corresponding to background-color: red.
Notice over at right here too, we see a summary in Chrome's developer tools
of exactly that.
If I click on G, if I click on B, I can see exactly the same thing
happening for each of those colors.
So here now, we have the ability with JavaScript
not only to alter the DOM of the page, the contents of it,
what the user is seeing, but also it would seem the CSS thereof.
What more can we do?
Well, let's look at one other example that evokes a tag from yesteryear.
Let me go into my source directory and grab an example called blink.html,
and show you in this code here in.
If I hide my terminal window, we've got a function
in this file inside of my script tag called
blink, which apparently toggles visibility of greeting.
But what does that mean?
Well, let's try to infer here.
There's a variable called body, which is set equal to the return
value of querySelector.
And we're checking this question.
If the visibility of that element is hidden,
then change the visibility to visible, else change the visibility to hidden.
Now, this too is one of these left hand and right hand were not
intercommunicating.
I have no idea why the opposite of visible is not invisible,
but the opposite of visible in CSS is hidden, for better or for worse.
So what's really happening here is we have a conditional,
an if else construct, that's saying if the visibility is hidden,
make it visible.
But if it's visible, make it hidden, back or forth.
How is this being used?
Well, here is another function that comes with JavaScript.
There's a global variable called window, which
refers to the browser window itself.
That comes with a method called setInterval-- capital
I. That function takes two arguments, the first of which
is the name of a function to call.
Notice again, not using parentheses, because I
don't want to call blink on line 22.
I want to pass the name of that blink function to the setInterval function.
And 500 is the second argument.
That refers to a number of milliseconds.
And what set interval does, as you might imagine,
is it will now call the blink function every 500 milliseconds,
or half a second.
So the effect, if I go back to my browser tab--
close my developer tools, and click now on blink.html,
is a resurrection of a tag that actually existed when I was growing up,
whereby you could literally do open bracket, blink, close bracket.
And you could make your web pages text blink like this.
Even worse, there was a tag called marquee
that would scroll your text across the screen, very hideously so.
And in fact, among all of the features of HTML--
among the few that have been removed over the years
are exactly those two tags.
But with JavaScript, we can bring them back now in this way.
The point really is to demonstrate again how much
control we now have over our DOM and our web pages, thanks to JavaScript.
Let's do one final example here.
Let's go back to VS Code here.
Open my terminal.
And let me copy in one last file from today's distribution code
called autocomplete.HTML.
And let's go ahead and open up autocomplete.HTML here in VS Code.
Well, what's going on here?
It turns out that there's a body of this page, which
just has a text input that's of type text with a placeholder of query.
Below that, there's this empty unordered list with nothing
initially, much like there was an empty paragraph tag previously.
So I could put "hello, so and so."
Then there's this file here, using a script tag, referencing large.js.
So I actually need that file too.
That's in today's distribution, too.
So let me grab large.js, which if we open that up,
might look somewhat familiar.
It is a JavaScript version of the dictionary from problem set 5,
wherein you implemented the fastest spell checker that you could.
So there's 100,000-plus words in this file.
But notice, they're structured as a JavaScript variable called
WORDS all caps, to make clear that I mean for it to be global.
It's using square brackets, as on line 1, because that it turns out,
much like Python, is how JavaScript indicates an array.
But in JavaScript, they're again called arrays instead of lists.
And then I just have this comma-separated list
of strings using double quotes.
But I could have used single quotes for all 100,000-plus of those words.
So by including this file, this means that my script down here
has access to that WORDS variable.
What am I doing?
Well, I create a variable called input, and set
it equal to querySelector's return value,
just so I can get a variable pointing to that text box.
Then I'm, again as before, adding an event listener, listening for keyup,
so the finger coming up.
And whenever that happens, I call this anonymous function.
I first, in that function, set an HTML variable to,
quote unquote, so the empty string-- nothing, because what I want to do
is build up a list of words that match whatever the human has typed in.
And you'll perhaps see where this is going in a moment.
If the user then has typed something in-- there's a value in that text box,
do this.
Iterate over that array of words, so for each word of words.
Here too is a JavaScript specific feature, but it's similar in spirit
to Python, sort of similar in spirit to C.
But the preposition I'm using is indeed of.
And I'm saying, for each of the words of this words array--
it's a little weird, the English.
But this is how you can iterate over every element in a JavaScript array.
If the current word that we're iterating over starts with capital W--
so this is a function that comes with strings in JavaScript, that input value.
So in other words, if the word we're looking at in the dictionary
starts with the same letters that the human has typed into the text box,
let's do this.
Let's concatenate onto the HTML variable, which is just an empty string
initially, the following HTML.
Now, this too looks weird.
But remember that the backticks mean that you can interpolate variables
inside of curly braces.
So this means add to that HTML variable another li tag and another close li
tag, inside of which, though, is the word that
has matched the first few characters.
And do that again and again and again.
And plus equals here just means concatenate, concatenate, concatenate.
So we're essentially building up, in JavaScript,
more and more and more and more HTML dynamically,
based on the human's keystrokes.
And the very last thing I do is this.
I ask the document to querySelect the ul element, which
previously was an empty unordered list.
But change its inner HTML to be equal to the li tags
that I've been creating, creating, creating in one big variable.
So if I go back over to VS Code here, if I go back to my Browser tab
here and click back, and I now go into autocomplete.HTML, as the name suggests,
this is the essence of how autocomplete exists
in Google, in Bing, and in applications more generally on the web,
and in some mobile devices.
If I type in C, I see now an unordered list of all of the words
that start with C in this dictionary.
If I type A, nothing seems to happen, but that's because the list is so long.
If I type C-A-T, now notice I get every word that starts with C-A-T.
If I type in S, now I get just four words, including catsup at the end,
that starts with C-A-T-S.
Meanwhile, if I open up the web pages source, notice that none of those words
are in there.
They're in the large.js file, but not in this page.
If I instead close that and open up the inspector again,
and I go to the Elements tab, and after having typed in "cats,"
notice there are indeed four li elements there.
But watch what happens.
As soon as I delete mention of cats here, all four of those li's disappear.
And now I'm back to the ul alone.
So this is to say with HTML, we can structure our web pages.
With CSS, we can stylize our web pages.
And with JavaScript, we can dynamically update and modify our web pages.
And via JavaScript can we therefore implement
applications like Gmail and Google itself and CS50.ai,
and so much more, because it makes what's
otherwise a very static experience in the browser suddenly dynamic.
And indeed what JavaScript can even do is make more HTTP calls
to the server to get more and more data, more and more tiles from a map,
more and more emails from the server.
But today, we've seen just the fundamentals.
Through your coming problem sets and perhaps final project will
you have an opportunity to apply all three of these technologies
together to build the web applications and the mobile applications
that you and I already use every day.
That's it for CS50.
We will see you next time.
[THEME MUSIC]
